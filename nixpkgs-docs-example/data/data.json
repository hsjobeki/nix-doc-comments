[
  {
    "aliases": [
      ["lib", "zipWithNames"],
      ["lib", "zipAttrsWithNames"],
      ["lib", "attrsets", "zipWithNames"],
      ["lib", "attrsets", "zipAttrsWithNames"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "Merge sets of attributes and use the function `f` to merge attributes\nvalues.\n\n# Example\n\n```nix\nzipAttrsWithNames [\"a\"] (name: vs: vs) [{a = \"x\";} {a = \"y\"; b = \"z\";}]\n=> { a = [\"x\" \"y\"]; }\n```\n\n# Type\n\n```\nzipAttrsWithNames :: [ String ] -> (String -> [ Any ] -> Any) -> [ AttrSet ] -> AttrSet\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 879
        }
      }
    },
    "path": ["lib", "zipWithNames"]
  },
  {
    "aliases": [
      ["lib", "zipListsWith"],
      ["lib", "lists", "zipListsWith"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 92
        }
      },
      "lambdaDocs": {
        "content": "Merges two lists of the same size together. If the sizes aren't the same\nthe merging stops at the shortest. How both lists are merged is defined\nby the first argument.\n\n# Example\n\n```nix\nzipListsWith (a: b: a + b) [\"h\" \"l\"] [\"e\" \"o\"]\n=> [\"he\" \"lo\"]\n```\n\n# Type\n\n```\nzipListsWith :: (a -> b -> c) -> [a] -> [b] -> [c]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 613
        }
      }
    },
    "path": ["lib", "zipListsWith"]
  },
  {
    "aliases": [
      ["lib", "zipLists"],
      ["lib", "lists", "zipLists"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 92
        }
      },
      "lambdaDocs": {
        "content": "Merges two lists of the same size together. If the sizes aren't the same\nthe merging stops at the shortest. How both lists are merged is defined\nby the first argument.\n\n# Example\n\n```nix\nzipListsWith (a: b: a + b) [\"h\" \"l\"] [\"e\" \"o\"]\n=> [\"he\" \"lo\"]\n```\n\n# Type\n\n```\nzipListsWith :: (a -> b -> c) -> [a] -> [b] -> [c]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 615
        }
      }
    },
    "path": ["lib", "zipLists"]
  },
  {
    "aliases": [
      ["lib", "zipWithNames"],
      ["lib", "zipAttrsWithNames"],
      ["lib", "attrsets", "zipWithNames"],
      ["lib", "attrsets", "zipAttrsWithNames"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "Merge sets of attributes and use the function `f` to merge attributes\nvalues.\n\n# Example\n\n```nix\nzipAttrsWithNames [\"a\"] (name: vs: vs) [{a = \"x\";} {a = \"y\"; b = \"z\";}]\n=> { a = [\"x\" \"y\"]; }\n```\n\n# Type\n\n```\nzipAttrsWithNames :: [ String ] -> (String -> [ Any ] -> Any) -> [ AttrSet ] -> AttrSet\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 879
        }
      }
    },
    "path": ["lib", "zipAttrsWithNames"]
  },
  {
    "aliases": [
      ["lib", "zipAttrsWith"],
      ["lib", "zip"],
      ["lib", "attrsets", "zipAttrsWith"],
      ["lib", "attrsets", "zip"],
      ["builtins", "zipAttrsWith"],
      ["builtins", "zipAttrsWith"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "Transpose a list of attribute sets into an attribute set of lists,\nthen apply `mapAttrs`.\n\n`f` receives two arguments: the attribute name and a non-empty\nlist of all values encountered for that attribute name.\n\nThe result is an attribute set where the attribute names are the\nunion of the attribute names in each element of `list`. The attribute\nvalues are the return values of `f`.\n\n```nix\nbuiltins.zipAttrsWith\n  (name: values: { inherit name values; })\n  [ { a = \"x\"; } { a = \"y\"; b = \"z\"; } ]\n```\n\nevaluates to\n\n```\n{\n  a = { name = \"a\"; values = [ \"x\" \"y\" ]; };\n  b = { name = \"b\"; values = [ \"z\" ]; };\n}\n```",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "zipAttrsWith"]
  },
  {
    "aliases": [
      ["lib", "zipAttrs"],
      ["lib", "attrsets", "zipAttrs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "Merge sets of attributes and combine each attribute value in to a list.\n\nLike `lib.attrsets.zipAttrsWith` with `(name: values: values)` as the function.\n\n# Example\n\n```nix\nzipAttrs [{a = \"x\";} {a = \"y\"; b = \"z\";}]\n=> { a = [\"x\" \"y\"]; b = [\"z\"]; }\n```\n\n# Type\n\n```\nzipAttrs :: [ AttrSet ] -> AttrSet\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 936
        }
      }
    },
    "path": ["lib", "zipAttrs"]
  },
  {
    "aliases": [
      ["lib", "zipAttrsWith"],
      ["lib", "zip"],
      ["lib", "attrsets", "zipAttrsWith"],
      ["lib", "attrsets", "zip"],
      ["builtins", "zipAttrsWith"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "Transpose a list of attribute sets into an attribute set of lists,\nthen apply `mapAttrs`.\n\n`f` receives two arguments: the attribute name and a non-empty\nlist of all values encountered for that attribute name.\n\nThe result is an attribute set where the attribute names are the\nunion of the attribute names in each element of `list`. The attribute\nvalues are the return values of `f`.\n\n```nix\nbuiltins.zipAttrsWith\n  (name: values: { inherit name values; })\n  [ { a = \"x\"; } { a = \"y\"; b = \"z\"; } ]\n```\n\nevaluates to\n\n```\n{\n  a = { name = \"a\"; values = [ \"x\" \"y\" ]; };\n  b = { name = \"b\"; values = [ \"z\" ]; };\n}\n```",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "zip"]
  },
  {
    "aliases": [
      ["lib", "withFeatureAs"],
      ["lib", "strings", "withFeatureAs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "Create an --{with-<feat>=<value>,without-<feat>} string that can be passed to\nstandard GNU Autoconf scripts.\n\n# Example\n\n```nix\nwithFeatureAs true \"shared\" \"foo\"\n=> \"--with-shared=foo\"\nwithFeatureAs false \"shared\" (throw \"ignored\")\n=> \"--without-shared\"\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 19,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1193
        }
      }
    },
    "path": ["lib", "withFeatureAs"]
  },
  {
    "aliases": [
      ["lib", "withFeature"],
      ["lib", "strings", "withFeature"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "Create an --{with,without}-<feat> string that can be passed to\nstandard GNU Autoconf scripts.\n\n# Example\n\n```nix\nwithFeature true \"shared\"\n=> \"--with-shared\"\nwithFeature false \"shared\"\n=> \"--without-shared\"\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1176
        }
      }
    },
    "path": ["lib", "withFeature"]
  },
  {
    "aliases": [
      ["lib", "warnIfNot"],
      ["lib", "trivial", "warnIfNot"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 73
        }
      },
      "lambdaDocs": {
        "content": "Like warnIf, but negated (warn if the first argument is `false`).\n\n# Type\n\n```\nbool -> string -> a -> a\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 15,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 494
        }
      }
    },
    "path": ["lib", "warnIfNot"]
  },
  {
    "aliases": [
      ["lib", "warnIf"],
      ["lib", "trivial", "warnIf"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 73
        }
      },
      "lambdaDocs": {
        "content": "Like warn, but only warn when the first argument is `true`.\n\n# Type\n\n```\nbool -> string -> a -> a\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 12,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 483
        }
      }
    },
    "path": ["lib", "warnIf"]
  },
  {
    "aliases": [
      ["lib", "warn"],
      ["lib", "trivial", "warn"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 73
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 472
        }
      }
    },
    "path": ["lib", "warn"]
  },
  {
    "aliases": [
      ["lib", "versions", "splitVersion"],
      ["lib", "splitVersion"],
      ["builtins", "splitVersion"],
      ["builtins", "splitVersion"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Break a version string into its component parts.\n\n# Example\n\n```nix\nsplitVersion \"1.2.3\"\n=> [\"1\" \"2\" \"3\"]\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/versions.nix",
          "line": 18
        }
      },
      "lambdaDocs": {
        "content": "Split a string representing a version into its components, by the\nsame version splitting logic underlying the version comparison in\n[`nix-env -u`](../command-ref/nix-env.md#operation---upgrade).",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "versions", "splitVersion"]
  },
  {
    "aliases": [["lib", "versions", "patch"]],
    "docs": {
      "attrDocs": {
        "content": "Get the patch version string from a string.\n\n# Example\n\n```nix\npatch \"1.2.3\"\n=> \"3\"\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/versions.nix",
          "line": 54
        }
      },
      "lambdaDocs": {
        "content": "Get the patch version string from a string.\n\n# Example\n\n```nix\npatch \"1.2.3\"\n=> \"3\"\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 11,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/versions.nix",
          "line": 54
        }
      }
    },
    "path": ["lib", "versions", "patch"]
  },
  {
    "aliases": [["lib", "versions", "pad"]],
    "docs": {
      "attrDocs": {
        "content": "Pad a version string with zeros to match the given number of components.\n\n# Example\n\n```nix\npad 3 \"1.2\"\n=> \"1.2.0\"\npad 3 \"1.3-rc1\"\n=> \"1.3.0-rc1\"\npad 3 \"1.2.3.4\"\n=> \"1.2.3\"\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/versions.nix",
          "line": 85
        }
      },
      "lambdaDocs": {
        "content": "Pad a version string with zeros to match the given number of components.\n\n# Example\n\n```nix\npad 3 \"1.2\"\n=> \"1.2.0\"\npad 3 \"1.3-rc1\"\n=> \"1.3.0-rc1\"\npad 3 \"1.2.3.4\"\n=> \"1.2.3\"\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 9,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/versions.nix",
          "line": 85
        }
      }
    },
    "path": ["lib", "versions", "pad"]
  },
  {
    "aliases": [["lib", "versions", "minor"]],
    "docs": {
      "attrDocs": {
        "content": "Get the minor version string from a string.\n\n# Example\n\n```nix\nminor \"1.2.3\"\n=> \"2\"\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/versions.nix",
          "line": 42
        }
      },
      "lambdaDocs": {
        "content": "Get the minor version string from a string.\n\n# Example\n\n```nix\nminor \"1.2.3\"\n=> \"2\"\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 11,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/versions.nix",
          "line": 42
        }
      }
    },
    "path": ["lib", "versions", "minor"]
  },
  {
    "aliases": [["lib", "versions", "majorMinor"]],
    "docs": {
      "attrDocs": {
        "content": "Get string of the first two parts (major and minor)\nof a version string.\n\n# Example\n\n```nix\nmajorMinor \"1.2.3\"\n=> \"1.2\"\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/versions.nix",
          "line": 67
        }
      },
      "lambdaDocs": {
        "content": "Get string of the first two parts (major and minor)\nof a version string.\n\n# Example\n\n```nix\nmajorMinor \"1.2.3\"\n=> \"1.2\"\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 16,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/versions.nix",
          "line": 67
        }
      }
    },
    "path": ["lib", "versions", "majorMinor"]
  },
  {
    "aliases": [["lib", "versions", "major"]],
    "docs": {
      "attrDocs": {
        "content": "Get the major version string from a string.\n\n# Example\n\n```nix\nmajor \"1.2.3\"\n=> \"1\"\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/versions.nix",
          "line": 30
        }
      },
      "lambdaDocs": {
        "content": "Get the major version string from a string.\n\n# Example\n\n```nix\nmajor \"1.2.3\"\n=> \"1\"\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 11,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/versions.nix",
          "line": 30
        }
      }
    },
    "path": ["lib", "versions", "major"]
  },
  {
    "aliases": [
      ["lib", "versionOlder"],
      ["lib", "strings", "versionOlder"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "Return true if string v1 denotes a version older than v2.\n\n# Example\n\n```nix\nversionOlder \"1.1\" \"1.2\"\n=> true\nversionOlder \"1.1\" \"1.1\"\n=> false\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 18,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 972
        }
      }
    },
    "path": ["lib", "versionOlder"]
  },
  {
    "aliases": [
      ["lib", "versionAtLeast"],
      ["lib", "strings", "versionAtLeast"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "Return true if string v1 denotes a version equal to or newer than v2.\n\n# Example\n\n```nix\nversionAtLeast \"1.1\" \"1.0\"\n=> true\nversionAtLeast \"1.1\" \"1.1\"\n=> true\nversionAtLeast \"1.1\" \"1.2\"\n=> false\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 20,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 988
        }
      }
    },
    "path": ["lib", "versionAtLeast"]
  },
  {
    "aliases": [
      ["lib", "updateName"],
      ["lib", "meta", "updateName"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 120
        }
      },
      "lambdaDocs": {
        "content": "Like `setName`, but takes the previous name as an argument.\n\n# Example\n\n```nix\nupdateName (oldName: oldName + \"-experimental\") somePkg\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 16,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 47
        }
      }
    },
    "path": ["lib", "updateName"]
  },
  {
    "aliases": [
      ["lib", "updateManyAttrsByPath"],
      ["lib", "attrsets", "updateManyAttrsByPath"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 6,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 276
        }
      }
    },
    "path": ["lib", "updateManyAttrsByPath"]
  },
  {
    "aliases": [
      ["lib", "unique"],
      ["lib", "lists", "unique"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 92
        }
      },
      "lambdaDocs": {
        "content": "Reduce a list by applying a binary operator, from left to right,\ne.g. `foldl' op nul [x0 x1 x2 ...] = op (op (op nul x0) x1) x2)\n...`. For example, `foldl' (x: y: x + y) 0 [1 2 3]` evaluates to 6.\nThe return value of each application of `op` is evaluated immediately,\neven for intermediate values.",
        "countApplied": 2,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "unique"]
  },
  {
    "aliases": [
      ["lib", "uniqListExt"],
      ["lib", "misc", "uniqListExt"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 156
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 100
        }
      }
    },
    "path": ["lib", "uniqListExt"]
  },
  {
    "aliases": [
      ["lib", "uniqList"],
      ["lib", "misc", "uniqList"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 156
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 91
        }
      }
    },
    "path": ["lib", "uniqList"]
  },
  {
    "aliases": [
      ["lib", "unifyModuleSyntax"],
      ["lib", "modules", "unifyModuleSyntax"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 128
        }
      },
      "lambdaDocs": {
        "content": "Massage a module into canonical form, that is, a set consisting\nof ‘options’, ‘config’ and ‘imports’ attributes.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 458
        }
      }
    },
    "path": ["lib", "unifyModuleSyntax"]
  },
  {
    "aliases": [["lib", "types", "unique"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 603
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 603
        }
      }
    },
    "path": ["lib", "types", "unique"]
  },
  {
    "aliases": [["lib", "types", "uniq"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 591
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 12,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 591
        }
      }
    },
    "path": ["lib", "types", "uniq"]
  },
  {
    "aliases": [["lib", "types", "submoduleWith"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 714
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 7,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 715
        }
      }
    },
    "path": ["lib", "types", "submoduleWith"]
  },
  {
    "aliases": [["lib", "types", "submodule"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 650
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 650
        }
      }
    },
    "path": ["lib", "types", "submodule"]
  },
  {
    "aliases": [["lib", "types", "strMatching"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 407
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 19,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 407
        }
      }
    },
    "path": ["lib", "types", "strMatching"]
  },
  {
    "aliases": [
      ["lib", "types", "setType"],
      ["lib", "setType"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 72
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 13,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 72
        }
      }
    },
    "path": ["lib", "types", "setType"]
  },
  {
    "aliases": [["lib", "types", "separatedString"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 417
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 417
        }
      }
    },
    "path": ["lib", "types", "separatedString"]
  },
  {
    "aliases": [["lib", "types", "passwdEntry"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 447
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 19,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 447
        }
      }
    },
    "path": ["lib", "types", "passwdEntry"]
  },
  {
    "aliases": [["lib", "types", "optionDescriptionPhrase"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 205
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 29,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 205
        }
      }
    },
    "path": ["lib", "types", "optionDescriptionPhrase"]
  },
  {
    "aliases": [["lib", "types", "oneOf"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 882
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 13,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 882
        }
      }
    },
    "path": ["lib", "types", "oneOf"]
  },
  {
    "aliases": [["lib", "types", "nullOr"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 616
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 616
        }
      }
    },
    "path": ["lib", "types", "nullOr"]
  },
  {
    "aliases": [["lib", "types", "nonEmptyListOf"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 529
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 22,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 529
        }
      }
    },
    "path": ["lib", "types", "nonEmptyListOf"]
  },
  {
    "aliases": [
      ["lib", "types", "mkOptionType"],
      ["lib", "mkOptionType"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 108
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 109
        }
      }
    },
    "path": ["lib", "types", "mkOptionType"]
  },
  {
    "aliases": [["lib", "types", "loaOf"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 582
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 13,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 582
        }
      }
    },
    "path": ["lib", "types", "loaOf"]
  },
  {
    "aliases": [["lib", "types", "listOf"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 506
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 506
        }
      }
    },
    "path": ["lib", "types", "listOf"]
  },
  {
    "aliases": [["lib", "types", "lazyAttrsOf"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 560
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 19,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 560
        }
      }
    },
    "path": ["lib", "types", "lazyAttrsOf"]
  },
  {
    "aliases": [
      ["lib", "types", "isType"],
      ["lib", "isType"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 70
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 12,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 70
        }
      }
    },
    "path": ["lib", "types", "isType"]
  },
  {
    "aliases": [
      ["lib", "types", "isOptionType"],
      ["lib", "options", "isOption"],
      ["lib", "isOptionType"],
      ["lib", "isOption"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 107
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 18,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 70
        }
      }
    },
    "path": ["lib", "types", "isOptionType"]
  },
  {
    "aliases": [["lib", "types", "functionTo"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 635
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 18,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 635
        }
      }
    },
    "path": ["lib", "types", "functionTo"]
  },
  {
    "aliases": [["lib", "types", "enum"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 823
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 12,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 823
        }
      }
    },
    "path": ["lib", "types", "enum"]
  },
  {
    "aliases": [["lib", "types", "either"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 855
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 855
        }
      }
    },
    "path": ["lib", "types", "either"]
  },
  {
    "aliases": [["lib", "types", "deferredModuleWith"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 661
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 26,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 661
        }
      }
    },
    "path": ["lib", "types", "deferredModuleWith"]
  },
  {
    "aliases": [
      ["lib", "types", "defaultTypeMerge"],
      ["lib", "defaultTypeMerge"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 79
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 22,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 79
        }
      }
    },
    "path": ["lib", "types", "defaultTypeMerge"]
  },
  {
    "aliases": [
      ["lib", "types", "defaultFunctor"],
      ["lib", "defaultFunctor"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 99
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 20,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 99
        }
      }
    },
    "path": ["lib", "types", "defaultFunctor"]
  },
  {
    "aliases": [["lib", "types", "coercedTo"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 890
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 890
        }
      }
    },
    "path": ["lib", "types", "coercedTo"]
  },
  {
    "aliases": [["lib", "types", "attrsOf"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 536
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 15,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 536
        }
      }
    },
    "path": ["lib", "types", "attrsOf"]
  },
  {
    "aliases": [["lib", "types", "addCheck"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 915
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 16,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 915
        }
      }
    },
    "path": ["lib", "types", "addCheck"]
  },
  {
    "aliases": [
      ["lib", "warnIfNot"],
      ["lib", "trivial", "warnIfNot"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Like warnIf, but negated (warn if the first argument is `false`).\n\n# Type\n\n```\nbool -> string -> a -> a\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 494
        }
      },
      "lambdaDocs": {
        "content": "Like warnIf, but negated (warn if the first argument is `false`).\n\n# Type\n\n```\nbool -> string -> a -> a\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 15,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 494
        }
      }
    },
    "path": ["lib", "trivial", "warnIfNot"]
  },
  {
    "aliases": [
      ["lib", "warnIf"],
      ["lib", "trivial", "warnIf"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Like warn, but only warn when the first argument is `true`.\n\n# Type\n\n```\nbool -> string -> a -> a\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 483
        }
      },
      "lambdaDocs": {
        "content": "Like warn, but only warn when the first argument is `true`.\n\n# Type\n\n```\nbool -> string -> a -> a\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 12,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 483
        }
      }
    },
    "path": ["lib", "trivial", "warnIf"]
  },
  {
    "aliases": [
      ["lib", "warn"],
      ["lib", "trivial", "warn"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Print a warning before returning the second argument. This function behaves\nlike `builtins.trace`, but requires a string message and formats it as a\nwarning, including the `warning: ` prefix.\n\nTo get a call stack trace and abort evaluation, set the environment variable\n`NIX_ABORT_ON_WARN=true` and set the Nix options `--option pure-eval false --show-trace`\n\n# Type\n\n```\nstring -> a -> a\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 469
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 472
        }
      }
    },
    "path": ["lib", "trivial", "warn"]
  },
  {
    "aliases": [
      ["lib", "trivial", "toHexString"],
      ["lib", "toHexString"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Convert the given positive integer to a string of its hexadecimal\nrepresentation. For example:\n\ntoHexString 0 => \"0\"\n\ntoHexString 16 => \"10\"\n\ntoHexString 250 => \"FA\"",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 632
        }
      },
      "lambdaDocs": {
        "content": "Convert the given positive integer to a string of its hexadecimal\nrepresentation. For example:\n\ntoHexString 0 => \"0\"\n\ntoHexString 16 => \"10\"\n\ntoHexString 250 => \"FA\"",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 632
        }
      }
    },
    "path": ["lib", "trivial", "toHexString"]
  },
  {
    "aliases": [
      ["lib", "trivial", "toFunction"],
      ["lib", "toFunction"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Turns any non-callable values into constant functions.\nReturns callable values as is.\n\n# Example\n\n```nix\nnix-repl> lib.toFunction 1 2\n          1\n\n          nix-repl> lib.toFunction (x: x + 1) 2\n          3\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 615
        }
      },
      "lambdaDocs": {
        "content": "Turns any non-callable values into constant functions.\nReturns callable values as is.\n\n# Example\n\n```nix\nnix-repl> lib.toFunction 1 2\n          1\n\n          nix-repl> lib.toFunction (x: x + 1) 2\n          3\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 617
        }
      }
    },
    "path": ["lib", "trivial", "toFunction"]
  },
  {
    "aliases": [
      ["lib", "trivial", "toBaseDigits"],
      ["lib", "toBaseDigits"]
    ],
    "docs": {
      "attrDocs": {
        "content": "`toBaseDigits base i` converts the positive integer i to a list of its\ndigits in the given base. For example:\n\ntoBaseDigits 10 123 => [ 1 2 3 ]\n\ntoBaseDigits 2 6 => [ 1 1 0 ]\n\ntoBaseDigits 16 250 => [ 15 10 ]",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 659
        }
      },
      "lambdaDocs": {
        "content": "`toBaseDigits base i` converts the positive integer i to a list of its\ndigits in the given base. For example:\n\ntoBaseDigits 10 123 => [ 1 2 3 ]\n\ntoBaseDigits 2 6 => [ 1 1 0 ]\n\ntoBaseDigits 16 250 => [ 15 10 ]",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 18,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 659
        }
      }
    },
    "path": ["lib", "trivial", "toBaseDigits"]
  },
  {
    "aliases": [
      ["lib", "trivial", "throwIfNot"],
      ["lib", "throwIfNot"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Like the `assert b; e` expression, but with a custom error message and\nwithout the semicolon.\n\nIf true, return the identity function, `r: r`.\n\nIf false, throw the error message.\n\nCalls can be juxtaposed using function application, as `(r: r) a = a`, so\n`(r: r) (r: r) a = a`, and so forth.\n\n# Example\n\n```nix\nthrowIfNot (lib.isList overlays) \"The overlays argument to nixpkgs must be a list.\"\nlib.foldr (x: throwIfNot (lib.isFunction x) \"All overlays passed to nixpkgs must be functions.\") (r: r) overlays\npkgs\n```\n\n# Type\n\n```\nbool -> string -> a -> a\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 521
        }
      },
      "lambdaDocs": {
        "content": "Like the `assert b; e` expression, but with a custom error message and\nwithout the semicolon.\n\nIf true, return the identity function, `r: r`.\n\nIf false, throw the error message.\n\nCalls can be juxtaposed using function application, as `(r: r) a = a`, so\n`(r: r) (r: r) a = a`, and so forth.\n\n# Example\n\n```nix\nthrowIfNot (lib.isList overlays) \"The overlays argument to nixpkgs must be a list.\"\nlib.foldr (x: throwIfNot (lib.isFunction x) \"All overlays passed to nixpkgs must be functions.\") (r: r) overlays\npkgs\n```\n\n# Type\n\n```\nbool -> string -> a -> a\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 16,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 521
        }
      }
    },
    "path": ["lib", "trivial", "throwIfNot"]
  },
  {
    "aliases": [
      ["lib", "trivial", "throwIf"],
      ["lib", "throwIf"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Like throwIfNot, but negated (throw if the first argument is `true`).\n\n# Type\n\n```\nbool -> string -> a -> a\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 532
        }
      },
      "lambdaDocs": {
        "content": "Like throwIfNot, but negated (throw if the first argument is `true`).\n\n# Type\n\n```\nbool -> string -> a -> a\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 13,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 532
        }
      }
    },
    "path": ["lib", "trivial", "throwIf"]
  },
  {
    "aliases": [
      ["lib", "trivial", "sub"],
      ["lib", "sub"],
      ["builtins", "sub"],
      ["builtins", "sub"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 219
        }
      },
      "lambdaDocs": {
        "content": "Return the difference between the numbers *e1* and *e2*.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "trivial", "sub"]
  },
  {
    "aliases": [
      ["lib", "trivial", "splitByAndCompare"],
      ["lib", "splitByAndCompare"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Split type into two subtypes by predicate `p`, take all elements\nof the first subtype to be less than all the elements of the\nsecond subtype, compare elements of a single subtype with `yes`\nand `no` respectively.\n\n# Example\n\n```nix\nlet cmp = splitByAndCompare (hasPrefix \"foo\") compare compare; in\n\n           cmp \"a\" \"z\" => -1\n           cmp \"fooa\" \"fooz\" => -1\n\n           cmp \"f\" \"a\" => 1\n           cmp \"fooa\" \"a\" => -1\n           # while\n           compare \"fooa\" \"a\" => 1\n```\n\n# Type\n\n```\n(a -> bool) -> (a -> a -> int) -> (a -> a -> int) -> (a -> a -> int)\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 400
        }
      },
      "lambdaDocs": {
        "content": "Split type into two subtypes by predicate `p`, take all elements\nof the first subtype to be less than all the elements of the\nsecond subtype, compare elements of a single subtype with `yes`\nand `no` respectively.\n\n# Example\n\n```nix\nlet cmp = splitByAndCompare (hasPrefix \"foo\") compare compare; in\n\n           cmp \"a\" \"z\" => -1\n           cmp \"fooa\" \"fooz\" => -1\n\n           cmp \"f\" \"a\" => 1\n           cmp \"fooa\" \"a\" => -1\n           # while\n           compare \"fooa\" \"a\" => 1\n```\n\n# Type\n\n```\n(a -> bool) -> (a -> a -> int) -> (a -> a -> int) -> (a -> a -> int)\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 402
        }
      }
    },
    "path": ["lib", "trivial", "splitByAndCompare"]
  },
  {
    "aliases": [
      ["lib", "trivial", "showWarnings"],
      ["lib", "showWarnings"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 561
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 18,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 561
        }
      }
    },
    "path": ["lib", "trivial", "showWarnings"]
  },
  {
    "aliases": [
      ["lib", "trivial", "setFunctionArgs"],
      ["lib", "setFunctionArgs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Add metadata about expected function arguments to a function.\nThe metadata should match the format given by\nbuiltins.functionArgs, i.e. a set from expected argument to a bool\nrepresenting whether that argument has a default or not.\nsetFunctionArgs : (a → b) → Map String Bool → (a → b)\n\nThis function is necessary because you can't dynamically create a\nfunction of the { a, b ? foo, ... }: format, but some facilities\nlike callPackage expect to be able to query expected arguments.",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 576
        }
      },
      "lambdaDocs": {
        "content": "Add metadata about expected function arguments to a function.\nThe metadata should match the format given by\nbuiltins.functionArgs, i.e. a set from expected argument to a bool\nrepresenting whether that argument has a default or not.\nsetFunctionArgs : (a → b) → Map String Bool → (a → b)\n\nThis function is necessary because you can't dynamically create a\nfunction of the { a, b ? foo, ... }: format, but some facilities\nlike callPackage expect to be able to query expected arguments.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 576
        }
      }
    },
    "path": ["lib", "trivial", "setFunctionArgs"]
  },
  {
    "aliases": [
      ["lib", "trivial", "seq"],
      ["lib", "seq"],
      ["builtins", "seq"],
      ["builtins", "seq"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 219
        }
      },
      "lambdaDocs": {
        "content": "Evaluate *e1*, then evaluate and return *e2*. This ensures that a\ncomputation is strict in the value of *e1*.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "trivial", "seq"]
  },
  {
    "aliases": [["lib", "trivial", "revisionWithDefault"]],
    "docs": {
      "attrDocs": {
        "content": "Attempts to return the the current revision of nixpkgs and\nreturns the supplied default value otherwise.\n\n# Type\n\n```\nrevisionWithDefault :: string -> string\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 293
        }
      },
      "lambdaDocs": {
        "content": "Attempts to return the the current revision of nixpkgs and\nreturns the supplied default value otherwise.\n\n# Type\n\n```\nrevisionWithDefault :: string -> string\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 295
        }
      }
    },
    "path": ["lib", "trivial", "revisionWithDefault"]
  },
  {
    "aliases": [
      ["lib", "trivial", "readFile"],
      ["lib", "strings", "readFile"],
      ["lib", "readFile"],
      ["builtins", "readFile"],
      ["builtins", "readFile"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 219
        }
      },
      "lambdaDocs": {
        "content": "Return the contents of the file *path* as a string.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "trivial", "readFile"]
  },
  {
    "aliases": [
      ["lib", "trivial", "pipe"],
      ["lib", "pipe"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 84
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 84
        }
      }
    },
    "path": ["lib", "trivial", "pipe"]
  },
  {
    "aliases": [
      ["lib", "trivial", "pathExists"],
      ["lib", "pathExists"],
      ["builtins", "pathExists"],
      ["builtins", "pathExists"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 219
        }
      },
      "lambdaDocs": {
        "content": "Return `true` if the path *path* exists at evaluation time, and\n`false` otherwise.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "trivial", "pathExists"]
  },
  {
    "aliases": [
      ["lib", "trivial", "or"],
      ["lib", "or"]
    ],
    "docs": {
      "attrDocs": {
        "content": "boolean “or”",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 116
        }
      },
      "lambdaDocs": {
        "content": "boolean “or”",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 8,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 116
        }
      }
    },
    "path": ["lib", "trivial", "or"]
  },
  {
    "aliases": [
      ["lib", "trivial", "mod"],
      ["lib", "mod"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Integer modulus\n\n# Example\n\n```nix\nmod 11 10\n=> 1\nmod 1 10\n=> 1\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 355
        }
      },
      "lambdaDocs": {
        "content": "Integer modulus\n\n# Example\n\n```nix\nmod 11 10\n=> 1\nmod 1 10\n=> 1\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 9,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 355
        }
      }
    },
    "path": ["lib", "trivial", "mod"]
  },
  {
    "aliases": [
      ["lib", "trivial", "min"],
      ["lib", "min"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Return minimum of two numbers.",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 336
        }
      },
      "lambdaDocs": {
        "content": "Return minimum of two numbers.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 9,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 336
        }
      }
    },
    "path": ["lib", "trivial", "min"]
  },
  {
    "aliases": [
      ["lib", "trivial", "mergeAttrs"],
      ["lib", "mergeAttrs"],
      ["lib", "mergeAttrBy", "meta"],
      ["lib", "mergeAttrBy", "flags"],
      ["lib", "mergeAttrBy", "cfg"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Merge two attribute sets shallowly, right side trumps left\n\nmergeAttrs :: attrs -> attrs -> attrs\n\n# Example\n\n```nix\nmergeAttrs { a = 1; b = 2; } { b = 3; c = 4; }\n=> { a = 1; b = 3; c = 4; }\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 176
        }
      },
      "lambdaDocs": {
        "content": "Merge two attribute sets shallowly, right side trumps left\n\nmergeAttrs :: attrs -> attrs -> attrs\n\n# Example\n\n```nix\nmergeAttrs { a = 1; b = 2; } { b = 3; c = 4; }\n=> { a = 1; b = 3; c = 4; }\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 178
        }
      }
    },
    "path": ["lib", "trivial", "mergeAttrs"]
  },
  {
    "aliases": [
      ["lib", "trivial", "max"],
      ["lib", "max"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Return maximum of two numbers.",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 341
        }
      },
      "lambdaDocs": {
        "content": "Return maximum of two numbers.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 9,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 341
        }
      }
    },
    "path": ["lib", "trivial", "max"]
  },
  {
    "aliases": [
      ["lib", "trivial", "mapNullable"],
      ["lib", "mapNullable"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Apply function if the supplied argument is non-null.\n\n# Example\n\n```nix\nmapNullable (x: x+1) null\n=> null\nmapNullable (x: x+1) 22\n=> 23\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 212
        }
      },
      "lambdaDocs": {
        "content": "Apply function if the supplied argument is non-null.\n\n# Example\n\n```nix\nmapNullable (x: x+1) null\n=> null\nmapNullable (x: x+1) 22\n=> 23\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 214
        }
      }
    },
    "path": ["lib", "trivial", "mapNullable"]
  },
  {
    "aliases": [
      ["lib", "trivial", "lessThan"],
      ["lib", "lessThan"],
      ["builtins", "lessThan"],
      ["builtins", "lessThan"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 219
        }
      },
      "lambdaDocs": {
        "content": "Return `true` if the number *e1* is less than the number *e2*, and\n`false` otherwise. Evaluation aborts if either *e1* or *e2* does not\nevaluate to a number.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "trivial", "lessThan"]
  },
  {
    "aliases": [
      ["lib", "trivial", "isInt"],
      ["lib", "strings", "isInt"],
      ["lib", "isInt"],
      ["builtins", "isInt"],
      ["builtins", "isInt"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 219
        }
      },
      "lambdaDocs": {
        "content": "Return `true` if *e* evaluates to an integer, and `false` otherwise.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "trivial", "isInt"]
  },
  {
    "aliases": [
      ["lib", "trivial", "isInOldestRelease"],
      ["lib", "isInOldestRelease"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Whether a feature is supported in all supported releases (at the time of\nrelease branch-off, if applicable). See `oldestSupportedRelease`.",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 258
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 263
        }
      }
    },
    "path": ["lib", "trivial", "isInOldestRelease"]
  },
  {
    "aliases": [
      ["lib", "trivial", "isFunction"],
      ["lib", "isFunction"],
      ["builtins", "isFunction"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Check whether something is a function or something\nannotated with function args.",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 598
        }
      },
      "lambdaDocs": {
        "content": "Check whether something is a function or something\nannotated with function args.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 16,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 598
        }
      }
    },
    "path": ["lib", "trivial", "isFunction"]
  },
  {
    "aliases": [
      ["lib", "trivial", "isFloat"],
      ["lib", "isFloat"],
      ["builtins", "isFloat"],
      ["builtins", "isFloat"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 219
        }
      },
      "lambdaDocs": {
        "content": "Return `true` if *e* evaluates to a float, and `false` otherwise.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "trivial", "isFloat"]
  },
  {
    "aliases": [
      ["lib", "trivial", "isBool"],
      ["lib", "isBool"],
      ["builtins", "isBool"],
      ["builtins", "isBool"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 219
        }
      },
      "lambdaDocs": {
        "content": "Return `true` if *e* evaluates to a bool, and `false` otherwise.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "trivial", "isBool"]
  },
  {
    "aliases": [
      ["lib", "trivial", "info"],
      ["lib", "info"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 559
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 559
        }
      }
    },
    "path": ["lib", "trivial", "info"]
  },
  {
    "aliases": [
      ["lib", "trivial", "importTOML"],
      ["lib", "importTOML"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Reads a TOML file.\n\n# Type\n\n```\nimportTOML :: path -> any\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 437
        }
      },
      "lambdaDocs": {
        "content": "Reads a TOML file.\n\n# Type\n\n```\nimportTOML :: path -> any\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 16,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 437
        }
      }
    },
    "path": ["lib", "trivial", "importTOML"]
  },
  {
    "aliases": [
      ["lib", "trivial", "importJSON"],
      ["lib", "importJSON"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Reads a JSON file.\n\n# Type\n\n```\nimportJSON :: path -> any\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 425
        }
      },
      "lambdaDocs": {
        "content": "Reads a JSON file.\n\n# Type\n\n```\nimportJSON :: path -> any\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 16,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 425
        }
      }
    },
    "path": ["lib", "trivial", "importJSON"]
  },
  {
    "aliases": [
      ["lib", "trivial", "id"],
      ["lib", "options", "mdDoc"],
      ["lib", "modules", "mkFixStrictness"],
      ["lib", "mkFixStrictness"],
      ["lib", "mdDoc"],
      ["lib", "id"]
    ],
    "docs": {
      "attrDocs": {
        "content": "The identity function\nFor when you need a function that does “nothing”.\n\n# Type\n\n```\nid :: a -> a\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 17
        }
      },
      "lambdaDocs": {
        "content": "The identity function\nFor when you need a function that does “nothing”.\n\n# Type\n\n```\nid :: a -> a\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 19
        }
      }
    },
    "path": ["lib", "trivial", "id"]
  },
  {
    "aliases": [
      ["lib", "trivial", "genericClosure"],
      ["lib", "genericClosure"],
      ["builtins", "genericClosure"],
      ["builtins", "genericClosure"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 219
        }
      },
      "lambdaDocs": {
        "content": "Take an *attrset* with values named `startSet` and `operator` in order to\nreturn a *list of attrsets* by starting with the `startSet` and recursively\napplying the `operator` function to each `item`. The *attrsets* in the\n`startSet` and the *attrsets* produced by `operator` must contain a value\nnamed `key` which is comparable. The result is produced by calling `operator`\nfor each `item` with a value for `key` that has not been called yet including\nnewly produced `item`s. The function terminates when no new `item`s are\nproduced. The resulting *list of attrsets* contains only *attrsets* with a\nunique key. For example,\n\n```\nbuiltins.genericClosure {\n  startSet = [ {key = 5;} ];\n  operator = item: [{\n    key = if (item.key / 2 ) * 2 == item.key\n         then item.key / 2\n         else 3 * item.key + 1;\n  }];\n}\n```\nevaluates to\n```\n[ { key = 5; } { key = 16; } { key = 8; } { key = 4; } { key = 2; } { key = 1; } ]\n```",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "trivial", "genericClosure"]
  },
  {
    "aliases": [
      ["lib", "trivial", "functionArgs"],
      ["lib", "functionArgs"],
      ["builtins", "functionArgs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Extract the expected function arguments from a function.\nThis works both with nix-native { a, b ? foo, ... }: style\nfunctions and functions with args set with 'setFunctionArgs'. It\nhas the same return type and semantics as builtins.functionArgs.\nsetFunctionArgs : (a → b) → Map String Bool.",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 589
        }
      },
      "lambdaDocs": {
        "content": "Extract the expected function arguments from a function.\nThis works both with nix-native { a, b ? foo, ... }: style\nfunctions and functions with args set with 'setFunctionArgs'. It\nhas the same return type and semantics as builtins.functionArgs.\nsetFunctionArgs : (a → b) → Map String Bool.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 18,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 589
        }
      }
    },
    "path": ["lib", "trivial", "functionArgs"]
  },
  {
    "aliases": [
      ["lib", "trivial", "flip"],
      ["lib", "flip"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Flip the order of the arguments of a binary function.\n\n# Example\n\n```nix\nflip concat [1] [2]\n=> [ 2 1 ]\n```\n\n# Type\n\n```\nflip :: (a -> b -> c) -> (b -> a -> c)\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 198
        }
      },
      "lambdaDocs": {
        "content": "Flip the order of the arguments of a binary function.\n\n# Example\n\n```nix\nflip concat [1] [2]\n=> [ 2 1 ]\n```\n\n# Type\n\n```\nflip :: (a -> b -> c) -> (b -> a -> c)\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 198
        }
      }
    },
    "path": ["lib", "trivial", "flip"]
  },
  {
    "aliases": [
      ["lib", "trivial", "deepSeq"],
      ["lib", "deepSeq"],
      ["builtins", "deepSeq"],
      ["builtins", "deepSeq"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 219
        }
      },
      "lambdaDocs": {
        "content": "This is like `seq e1 e2`, except that *e1* is evaluated *deeply*:\nif it’s a list or set, its elements or attributes are also\nevaluated recursively.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "trivial", "deepSeq"]
  },
  {
    "aliases": [
      ["lib", "trivial", "const"],
      ["lib", "const"]
    ],
    "docs": {
      "attrDocs": {
        "content": "The constant function\n\nIgnores the second argument. If called with only one argument,\nconstructs a function that always returns a static value.\n\n# Example\n\n```nix\nlet f = const 5; in f 10\n=> 5\n```\n\n# Type\n\n```\nconst :: a -> b -> a\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 40
        }
      },
      "lambdaDocs": {
        "content": "The constant function\n\nIgnores the second argument. If called with only one argument,\nconstructs a function that always returns a static value.\n\n# Example\n\n```nix\nlet f = const 5; in f 10\n=> 5\n```\n\n# Type\n\n```\nconst :: a -> b -> a\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 42
        }
      }
    },
    "path": ["lib", "trivial", "const"]
  },
  {
    "aliases": [
      ["lib", "trivial", "concat"],
      ["lib", "mergeAttrBy", "propagatedBuildInputs"],
      ["lib", "mergeAttrBy", "prePhases"],
      ["lib", "mergeAttrBy", "postAll"],
      ["lib", "mergeAttrBy", "patches"],
      ["lib", "mergeAttrBy", "nativeBuildInputs"],
      ["lib", "mergeAttrBy", "configureFlags"],
      ["lib", "mergeAttrBy", "buildInputs"],
      ["lib", "concat"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Concatenate two lists\n\n# Example\n\n```nix\nconcat [ 1 2 ] [ 3 4 ]\n=> [ 1 2 3 4 ]\n```\n\n# Type\n\n```\nconcat :: [a] -> [a] -> [a]\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 111
        }
      },
      "lambdaDocs": {
        "content": "Concatenate two lists\n\n# Example\n\n```nix\nconcat [ 1 2 ] [ 3 4 ]\n=> [ 1 2 3 4 ]\n```\n\n# Type\n\n```\nconcat :: [a] -> [a] -> [a]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 12,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 111
        }
      }
    },
    "path": ["lib", "trivial", "concat"]
  },
  {
    "aliases": [
      ["lib", "trivial", "compare"],
      ["lib", "compare"]
    ],
    "docs": {
      "attrDocs": {
        "content": "C-style comparisons\n\na < b,  compare a b => -1\na == b, compare a b => 0\na > b,  compare a b => 1",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 367
        }
      },
      "lambdaDocs": {
        "content": "C-style comparisons\n\na < b,  compare a b => -1\na == b, compare a b => 0\na > b,  compare a b => 1",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 13,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 367
        }
      }
    },
    "path": ["lib", "trivial", "compare"]
  },
  {
    "aliases": [
      ["lib", "trivial", "checkListOfEnum"],
      ["lib", "checkListOfEnum"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Check if the elements in a list are valid values from a enum, returning the identity function, or throwing an error message otherwise.\n\n# Example\n\n```nix\nlet colorVariants = [\"bright\" \"dark\" \"black\"]\nin checkListOfEnum \"color variants\" [ \"standard\" \"light\" \"dark\" ] colorVariants;\n=>\nerror: color variants: bright, black unexpected; valid ones: standard, light, dark\n```\n\n# Type\n\n```\nString -> List ComparableVal -> List ComparableVal -> a -> a\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 552
        }
      },
      "lambdaDocs": {
        "content": "Check if the elements in a list are valid values from a enum, returning the identity function, or throwing an error message otherwise.\n\n# Example\n\n```nix\nlet colorVariants = [\"bright\" \"dark\" \"black\"]\nin checkListOfEnum \"color variants\" [ \"standard\" \"light\" \"dark\" ] colorVariants;\n=>\nerror: color variants: bright, black unexpected; valid ones: standard, light, dark\n```\n\n# Type\n\n```\nString -> List ComparableVal -> List ComparableVal -> a -> a\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 552
        }
      }
    },
    "path": ["lib", "trivial", "checkListOfEnum"]
  },
  {
    "aliases": [
      ["lib", "trivial", "boolToString"],
      ["lib", "boolToString"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Convert a boolean to a string.\n\nThis function uses the strings \"true\" and \"false\" to represent\nboolean values. Calling `toString` on a bool instead returns \"1\"\nand \"\" (sic!).\n\n# Type\n\n```\nboolToString :: bool -> string\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 162
        }
      },
      "lambdaDocs": {
        "content": "Convert a boolean to a string.\n\nThis function uses the strings \"true\" and \"false\" to represent\nboolean values. Calling `toString` on a bool instead returns \"1\"\nand \"\" (sic!).\n\n# Type\n\n```\nboolToString :: bool -> string\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 18,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 162
        }
      }
    },
    "path": ["lib", "trivial", "boolToString"]
  },
  {
    "aliases": [
      ["lib", "trivial", "bitXor"],
      ["lib", "bitXor"],
      ["builtins", "bitXor"],
      ["builtins", "bitXor"]
    ],
    "docs": {
      "attrDocs": {
        "content": "bitwise “xor”",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 140
        }
      },
      "lambdaDocs": {
        "content": "Return the bitwise XOR of the integers *e1* and *e2*.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "trivial", "bitXor"]
  },
  {
    "aliases": [
      ["lib", "trivial", "bitOr"],
      ["lib", "bitOr"],
      ["builtins", "bitOr"],
      ["builtins", "bitOr"]
    ],
    "docs": {
      "attrDocs": {
        "content": "bitwise “or”",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 133
        }
      },
      "lambdaDocs": {
        "content": "Return the bitwise OR of the integers *e1* and *e2*.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "trivial", "bitOr"]
  },
  {
    "aliases": [
      ["lib", "trivial", "bitNot"],
      ["lib", "bitNot"]
    ],
    "docs": {
      "attrDocs": {
        "content": "bitwise “not”",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 147
        }
      },
      "lambdaDocs": {
        "content": "Return the difference between the numbers *e1* and *e2*.",
        "countApplied": 1,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "trivial", "bitNot"]
  },
  {
    "aliases": [
      ["lib", "trivial", "bitAnd"],
      ["lib", "bitAnd"],
      ["builtins", "bitAnd"],
      ["builtins", "bitAnd"]
    ],
    "docs": {
      "attrDocs": {
        "content": "bitwise “and”",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 126
        }
      },
      "lambdaDocs": {
        "content": "Return the bitwise AND of the integers *e1* and *e2*.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "trivial", "bitAnd"]
  },
  {
    "aliases": [
      ["lib", "trivial", "and"],
      ["lib", "and"]
    ],
    "docs": {
      "attrDocs": {
        "content": "boolean “and”",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 121
        }
      },
      "lambdaDocs": {
        "content": "boolean “and”",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 9,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 121
        }
      }
    },
    "path": ["lib", "trivial", "and"]
  },
  {
    "aliases": [
      ["lib", "trivial", "add"],
      ["lib", "add"],
      ["builtins", "add"],
      ["builtins", "add"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 219
        }
      },
      "lambdaDocs": {
        "content": "Return the sum of the numbers *e1* and *e2*.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "trivial", "add"]
  },
  {
    "aliases": [
      ["lib", "traceValSeqNFn"],
      ["lib", "debug", "traceValSeqNFn"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 152
        }
      },
      "lambdaDocs": {
        "content": "A combination of `traceVal` and `traceSeqN` that applies a\nprovided function to the value to be traced.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/debug.nix",
          "line": 184
        }
      }
    },
    "path": ["lib", "traceValSeqNFn"]
  },
  {
    "aliases": [
      ["lib", "traceValSeqN"],
      ["lib", "debug", "traceValSeqN"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 152
        }
      },
      "lambdaDocs": {
        "content": "A combination of `traceVal` and `traceSeqN` that applies a\nprovided function to the value to be traced.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/debug.nix",
          "line": 185
        }
      }
    },
    "path": ["lib", "traceValSeqN"]
  },
  {
    "aliases": [
      ["lib", "traceValSeqFn"],
      ["lib", "debug", "traceValSeqFn"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 152
        }
      },
      "lambdaDocs": {
        "content": "A combination of `traceVal` and `traceSeq` that applies a\nprovided function to the value to be traced after `deepSeq`ing\nit.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/debug.nix",
          "line": 169
        }
      }
    },
    "path": ["lib", "traceValSeqFn"]
  },
  {
    "aliases": [
      ["lib", "traceValSeq"],
      ["lib", "debug", "traceValSeq"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 152
        }
      },
      "lambdaDocs": {
        "content": "A combination of `traceVal` and `traceSeq` that applies a\nprovided function to the value to be traced after `deepSeq`ing\nit.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/debug.nix",
          "line": 171
        }
      }
    },
    "path": ["lib", "traceValSeq"]
  },
  {
    "aliases": [
      ["lib", "traceValFn"],
      ["lib", "debug", "traceValFn"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 152
        }
      },
      "lambdaDocs": {
        "content": "Trace the supplied value after applying a function to it, and\nreturn the original value.\n\n# Example\n\n```nix\ntraceValFn (v: \"mystring ${v}\") \"foo\"\ntrace: mystring foo\n=> \"foo\"\n```\n\n# Type\n\n```\ntraceValFn :: (a -> b) -> a -> a\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/debug.nix",
          "line": 81
        }
      }
    },
    "path": ["lib", "traceValFn"]
  },
  {
    "aliases": [
      ["lib", "traceVal"],
      ["lib", "debug", "traceVal"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 152
        }
      },
      "lambdaDocs": {
        "content": "Trace the supplied value after applying a function to it, and\nreturn the original value.\n\n# Example\n\n```nix\ntraceValFn (v: \"mystring ${v}\") \"foo\"\ntrace: mystring foo\n=> \"foo\"\n```\n\n# Type\n\n```\ntraceValFn :: (a -> b) -> a -> a\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/debug.nix",
          "line": 83
        }
      }
    },
    "path": ["lib", "traceVal"]
  },
  {
    "aliases": [
      ["lib", "traceSeqN"],
      ["lib", "debug", "traceSeqN"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 152
        }
      },
      "lambdaDocs": {
        "content": "Like `traceSeq`, but only evaluate down to depth n.\nThis is very useful because lots of `traceSeq` usages\nlead to an infinite recursion.\n\n# Example\n\n```nix\ntraceSeqN 2 { a.b.c = 3; } null\ntrace: { a = { b = {…}; }; }\n=> null\n```\n\n# Type\n\n```\ntraceSeqN :: Int -> a -> b -> b\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 15,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/debug.nix",
          "line": 149
        }
      }
    },
    "path": ["lib", "traceSeqN"]
  },
  {
    "aliases": [
      ["lib", "traceSeq"],
      ["lib", "debug", "traceSeq"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 152
        }
      },
      "lambdaDocs": {
        "content": "`builtins.trace`, but the value is `builtins.deepSeq`ed first.\n\n# Example\n\n```nix\ntrace { a.b.c = 3; } null\ntrace: { a = <CODE>; }\n=> null\ntraceSeq { a.b.c = 3; } null\ntrace: { a = { b = { c = 3; }; }; }\n=> null\n```\n\n# Type\n\n```\ntraceSeq :: a -> b -> b\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/debug.nix",
          "line": 126
        }
      }
    },
    "path": ["lib", "traceSeq"]
  },
  {
    "aliases": [
      ["lib", "traceIf"],
      ["lib", "debug", "traceIf"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 152
        }
      },
      "lambdaDocs": {
        "content": "Conditionally trace the supplied message, based on a predicate.\n\n# Example\n\n```nix\ntraceIf true \"hello\" 3\ntrace: hello\n=> 3\n```\n\n# Type\n\n```\ntraceIf :: bool -> string -> a -> a\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/debug.nix",
          "line": 55
        }
      }
    },
    "path": ["lib", "traceIf"]
  },
  {
    "aliases": [
      ["lib", "traceFnSeqN"],
      ["lib", "debug", "traceFnSeqN"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 152
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/debug.nix",
          "line": 209
        }
      }
    },
    "path": ["lib", "traceFnSeqN"]
  },
  {
    "aliases": [
      ["lib", "trace"],
      ["builtins", "trace"],
      ["builtins", "trace"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 68
        }
      },
      "lambdaDocs": {
        "content": "Evaluate *e1* and print its abstract syntax representation on\nstandard error. Then return *e2*. This function is useful for\ndebugging.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "trace"]
  },
  {
    "aliases": [
      ["lib", "toposort"],
      ["lib", "lists", "toposort"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 92
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 722
        }
      }
    },
    "path": ["lib", "toposort"]
  },
  {
    "aliases": [
      ["lib", "toUpper"],
      ["lib", "toLower"],
      ["lib", "strings", "toUpper"],
      ["lib", "strings", "toLower"],
      ["lib", "strings", "escapeXML"],
      ["lib", "strings", "escapeURL"],
      ["lib", "strings", "escapeRegex"],
      ["lib", "escapeXML"],
      ["lib", "escapeURL"],
      ["lib", "escapeRegex"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "Given string *s*, replace every occurrence of the strings in *from*\nwith the corresponding string in *to*.\n\nThe argument *to* is lazy, that is, it is only evaluated when its corresponding pattern in *from* is matched in the string *s*\n\nExample:\n\n```nix\nbuiltins.replaceStrings [\"oo\" \"a\"] [\"a\" \"i\"] \"foobar\"\n```\n\nevaluates to `\"fabir\"`.",
        "countApplied": 2,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "toUpper"]
  },
  {
    "aliases": [
      ["lib", "toShellVars"],
      ["lib", "strings", "toShellVars"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "Translate an attribute set into corresponding shell variable declarations\nusing `toShellVar`.\n\n# Example\n\n```nix\nlet\n  foo = \"value\";\n  bar = foo;\nin ''\n  ${toShellVars { inherit foo bar; }}\n  [[ \"$foo\" == \"$bar\" ]]\n''\n```\n\n# Type\n\n```\nattrsOf (string | listOf string | attrsOf string) -> string\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 715
        }
      }
    },
    "path": ["lib", "toShellVars"]
  },
  {
    "aliases": [
      ["lib", "toShellVar"],
      ["lib", "strings", "toShellVar"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "Translate a Nix value into a shell variable declaration, with proper escaping.\n\nThe value can be a string (mapped to a regular variable), a list of strings\n(mapped to a Bash-style array) or an attribute set of strings (mapped to a\nBash-style associative array). Note that \"string\" includes string-coercible\nvalues like paths or derivations.\n\nStrings are translated into POSIX sh-compatible code; lists and attribute sets\nassume a shell that understands Bash syntax (e.g. Bash or ZSH).\n\n# Example\n\n```nix\n''\n  ${toShellVar \"foo\" \"some string\"}\n  [[ \"$foo\" == \"some string\" ]]\n''\n```\n\n# Type\n\n```\nstring -> (string | listOf string | attrsOf string) -> string\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 16,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 679
        }
      }
    },
    "path": ["lib", "toShellVar"]
  },
  {
    "aliases": [
      ["lib", "toUpper"],
      ["lib", "toLower"],
      ["lib", "strings", "toUpper"],
      ["lib", "strings", "toLower"],
      ["lib", "strings", "escapeXML"],
      ["lib", "strings", "escapeURL"],
      ["lib", "strings", "escapeRegex"],
      ["lib", "escapeXML"],
      ["lib", "escapeURL"],
      ["lib", "escapeRegex"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "Given string *s*, replace every occurrence of the strings in *from*\nwith the corresponding string in *to*.\n\nThe argument *to* is lazy, that is, it is only evaluated when its corresponding pattern in *from* is matched in the string *s*\n\nExample:\n\n```nix\nbuiltins.replaceStrings [\"oo\" \"a\"] [\"a\" \"i\"] \"foobar\"\n```\n\nevaluates to `\"fabir\"`.",
        "countApplied": 2,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "toLower"]
  },
  {
    "aliases": [
      ["lib", "toList"],
      ["lib", "lists", "toList"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 92
        }
      },
      "lambdaDocs": {
        "content": "If argument is a list, return it; else, wrap it in a singleton\nlist.  If you're using this, you should almost certainly\nreconsider if there isn't a more \"well-typed\" approach.\n\n# Example\n\n```nix\ntoList [ 1 2 ]\n=> [ 1 2 ]\ntoList \"hi\"\n=> [ \"hi \"]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 12,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 483
        }
      }
    },
    "path": ["lib", "toList"]
  },
  {
    "aliases": [
      ["lib", "toIntBase10"],
      ["lib", "strings", "toIntBase10"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1402
        }
      }
    },
    "path": ["lib", "toIntBase10"]
  },
  {
    "aliases": [
      ["lib", "toInt"],
      ["lib", "strings", "toInt"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "Parse a string as an int. Does not support parsing of integers with preceding zero due to\nambiguity between zero-padded and octal numbers. See toIntBase10.\n\n# Example\n\n```nix\ntoInt \"1337\"\n           => 1337\n\n           toInt \"-4\"\n           => -4\n\n           toInt \" 123 \"\n           => 123\n\n           toInt \"00024\"\n           => error: Ambiguity in interpretation of 00024 between octal and zero padded integer.\n\n           toInt \"3.14\"\n           => error: floating point JSON numbers are not supported\n```\n\n# Type\n\n```\nstring -> int\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 11,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1343
        }
      }
    },
    "path": ["lib", "toInt"]
  },
  {
    "aliases": [
      ["lib", "trivial", "toHexString"],
      ["lib", "toHexString"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 73
        }
      },
      "lambdaDocs": {
        "content": "Convert the given positive integer to a string of its hexadecimal\nrepresentation. For example:\n\ntoHexString 0 => \"0\"\n\ntoHexString 16 => \"10\"\n\ntoHexString 250 => \"FA\"",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 632
        }
      }
    },
    "path": ["lib", "toHexString"]
  },
  {
    "aliases": [
      ["lib", "trivial", "toFunction"],
      ["lib", "toFunction"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 73
        }
      },
      "lambdaDocs": {
        "content": "Turns any non-callable values into constant functions.\nReturns callable values as is.\n\n# Example\n\n```nix\nnix-repl> lib.toFunction 1 2\n          1\n\n          nix-repl> lib.toFunction (x: x + 1) 2\n          3\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 617
        }
      }
    },
    "path": ["lib", "toFunction"]
  },
  {
    "aliases": [
      ["lib", "toDerivation"],
      ["lib", "attrsets", "toDerivation"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "Converts a store path to a fake derivation.\n\n# Type\n\n```\ntoDerivation :: Path -> Derivation\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 6,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 819
        }
      }
    },
    "path": ["lib", "toDerivation"]
  },
  {
    "aliases": [
      ["lib", "trivial", "toBaseDigits"],
      ["lib", "toBaseDigits"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 73
        }
      },
      "lambdaDocs": {
        "content": "`toBaseDigits base i` converts the positive integer i to a list of its\ndigits in the given base. For example:\n\ntoBaseDigits 10 123 => [ 1 2 3 ]\n\ntoBaseDigits 2 6 => [ 1 1 0 ]\n\ntoBaseDigits 16 250 => [ 15 10 ]",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 18,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 659
        }
      }
    },
    "path": ["lib", "toBaseDigits"]
  },
  {
    "aliases": [
      ["lib", "trivial", "throwIfNot"],
      ["lib", "throwIfNot"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 73
        }
      },
      "lambdaDocs": {
        "content": "Like the `assert b; e` expression, but with a custom error message and\nwithout the semicolon.\n\nIf true, return the identity function, `r: r`.\n\nIf false, throw the error message.\n\nCalls can be juxtaposed using function application, as `(r: r) a = a`, so\n`(r: r) (r: r) a = a`, and so forth.\n\n# Example\n\n```nix\nthrowIfNot (lib.isList overlays) \"The overlays argument to nixpkgs must be a list.\"\nlib.foldr (x: throwIfNot (lib.isFunction x) \"All overlays passed to nixpkgs must be functions.\") (r: r) overlays\npkgs\n```\n\n# Type\n\n```\nbool -> string -> a -> a\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 16,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 521
        }
      }
    },
    "path": ["lib", "throwIfNot"]
  },
  {
    "aliases": [
      ["lib", "trivial", "throwIf"],
      ["lib", "throwIf"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 73
        }
      },
      "lambdaDocs": {
        "content": "Like throwIfNot, but negated (throw if the first argument is `true`).\n\n# Type\n\n```\nbool -> string -> a -> a\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 13,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 532
        }
      }
    },
    "path": ["lib", "throwIf"]
  },
  {
    "aliases": [
      ["lib", "textClosureMap"],
      ["lib", "stringsWithDeps", "textClosureMap"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 35,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 114
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 20,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings-with-deps.nix",
          "line": 77
        }
      }
    },
    "path": ["lib", "textClosureMap"]
  },
  {
    "aliases": [
      ["lib", "textClosureList"],
      ["lib", "stringsWithDeps", "textClosureList"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 35,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 114
        }
      },
      "lambdaDocs": {
        "content": "!!! The interface of this function is kind of messed up, since\nit's way too overloaded and almost but not quite computes a\ntopological sort of the depstrings.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings-with-deps.nix",
          "line": 61
        }
      }
    },
    "path": ["lib", "textClosureList"]
  },
  {
    "aliases": [
      ["lib", "testAllTrue"],
      ["lib", "debug", "testAllTrue"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 152
        }
      },
      "lambdaDocs": {
        "content": "Create a test assuming that list elements are `true`.\n\n# Example\n\n```nix\n{ testX = allTrue [ true ]; }\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/debug.nix",
          "line": 307
        }
      }
    },
    "path": ["lib", "testAllTrue"]
  },
  {
    "aliases": [
      ["lib", "take"],
      ["lib", "lists", "take"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 92
        }
      },
      "lambdaDocs": {
        "content": "Return the first (at most) N elements of a list.\n\n# Example\n\n```nix\ntake 2 [ \"a\" \"b\" \"c\" \"d\" ]\n=> [ \"a\" \"b\" ]\ntake 2 [ ]\n=> [ ]\n```\n\n# Type\n\n```\ntake :: int -> [a] -> [a]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 842
        }
      }
    },
    "path": ["lib", "take"]
  },
  {
    "aliases": [
      ["lib", "tail"],
      ["lib", "strings", "tail"],
      ["lib", "lists", "tail"],
      ["builtins", "tail"],
      ["builtins", "tail"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 68
        }
      },
      "lambdaDocs": {
        "content": "Return the second to last elements of a list; abort evaluation if\nthe argument isn’t a list or is an empty list.\n\n> **Warning**\n>\n> This function should generally be avoided since it's inefficient:\n> unlike Haskell's `tail`, it takes O(n) time, so recursing over a\n> list by repeatedly calling `tail` takes O(n^2) time.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "tail"]
  },
  {
    "aliases": [["lib", "systems", "equals"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/systems/default.nix",
          "line": 26
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 8,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/systems/default.nix",
          "line": 28
        }
      }
    },
    "path": ["lib", "systems", "equals"]
  },
  {
    "aliases": [["lib", "systems", "elaborate"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/systems/default.nix",
          "line": 43
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 15,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/systems/default.nix",
          "line": 43
        }
      }
    },
    "path": ["lib", "systems", "elaborate"]
  },
  {
    "aliases": [
      ["lib", "subtractLists"],
      ["lib", "lists", "subtractLists"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 92
        }
      },
      "lambdaDocs": {
        "content": "Subtracts list 'e' from another list. O(nm) complexity.\n\n# Example\n\n```nix\nsubtractLists [ 3 2 ] [ 1 2 3 4 5 3 ]\n=> [ 1 4 5 ]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 19,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 1085
        }
      }
    },
    "path": ["lib", "subtractLists"]
  },
  {
    "aliases": [
      ["lib", "substring"],
      ["lib", "strings", "substring"],
      ["builtins", "substring"],
      ["builtins", "substring"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 68
        }
      },
      "lambdaDocs": {
        "content": "Return the substring of *s* from character position *start*\n(zero-based) up to but not including *start + len*. If *start* is\ngreater than the length of the string, an empty string is returned,\nand if *start + len* lies beyond the end of the string, only the\nsubstring up to the end of the string is returned. *start* must be\nnon-negative. For example,\n\n```nix\nbuiltins.substring 0 3 \"nixos\"\n```\n\nevaluates to `\"nix\"`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "substring"]
  },
  {
    "aliases": [
      ["lib", "sublist"],
      ["lib", "lists", "sublist"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 92
        }
      },
      "lambdaDocs": {
        "content": "Return a list consisting of at most `count` elements of `list`,\nstarting at index `start`.\n\n# Example\n\n```nix\nsublist 1 3 [ \"a\" \"b\" \"c\" \"d\" \"e\" ]\n=> [ \"b\" \"c\" \"d\" ]\nsublist 1 3 [ ]\n=> [ ]\n```\n\n# Type\n\n```\nsublist :: int -> int -> [a] -> [a]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 939
        }
      }
    },
    "path": ["lib", "sublist"]
  },
  {
    "aliases": [
      ["lib", "trivial", "sub"],
      ["lib", "sub"],
      ["builtins", "sub"],
      ["builtins", "sub"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 68
        }
      },
      "lambdaDocs": {
        "content": "Return the difference between the numbers *e1* and *e2*.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "sub"]
  },
  {
    "aliases": [
      ["lib", "textClosureMap"],
      ["lib", "stringsWithDeps", "textClosureMap"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings-with-deps.nix",
          "line": 77
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 20,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings-with-deps.nix",
          "line": 77
        }
      }
    },
    "path": ["lib", "stringsWithDeps", "textClosureMap"]
  },
  {
    "aliases": [
      ["lib", "textClosureList"],
      ["lib", "stringsWithDeps", "textClosureList"]
    ],
    "docs": {
      "attrDocs": {
        "content": "!!! The interface of this function is kind of messed up, since\nit's way too overloaded and almost but not quite computes a\ntopological sort of the depstrings.",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings-with-deps.nix",
          "line": 61
        }
      },
      "lambdaDocs": {
        "content": "!!! The interface of this function is kind of messed up, since\nit's way too overloaded and almost but not quite computes a\ntopological sort of the depstrings.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings-with-deps.nix",
          "line": 61
        }
      }
    },
    "path": ["lib", "stringsWithDeps", "textClosureList"]
  },
  {
    "aliases": [
      ["lib", "stringsWithDeps", "stringAfter"],
      ["lib", "stringAfter"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings-with-deps.nix",
          "line": 84
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings-with-deps.nix",
          "line": 84
        }
      }
    },
    "path": ["lib", "stringsWithDeps", "stringAfter"]
  },
  {
    "aliases": [
      ["lib", "stringsWithDeps", "packEntry"],
      ["lib", "packEntry"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings-with-deps.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 15,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings-with-deps.nix",
          "line": 82
        }
      }
    },
    "path": ["lib", "stringsWithDeps", "packEntry"]
  },
  {
    "aliases": [
      ["lib", "stringsWithDeps", "noDepEntry"],
      ["lib", "noDepEntry"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings-with-deps.nix",
          "line": 80
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 16,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings-with-deps.nix",
          "line": 80
        }
      }
    },
    "path": ["lib", "stringsWithDeps", "noDepEntry"]
  },
  {
    "aliases": [
      ["lib", "stringsWithDeps", "fullDepEntry"],
      ["lib", "fullDepEntry"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings-with-deps.nix",
          "line": 81
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 18,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings-with-deps.nix",
          "line": 81
        }
      }
    },
    "path": ["lib", "stringsWithDeps", "fullDepEntry"]
  },
  {
    "aliases": [
      ["lib", "withFeatureAs"],
      ["lib", "strings", "withFeatureAs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Create an --{with-<feat>=<value>,without-<feat>} string that can be passed to\nstandard GNU Autoconf scripts.\n\n# Example\n\n```nix\nwithFeatureAs true \"shared\" \"foo\"\n=> \"--with-shared=foo\"\nwithFeatureAs false \"shared\" (throw \"ignored\")\n=> \"--without-shared\"\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1193
        }
      },
      "lambdaDocs": {
        "content": "Create an --{with-<feat>=<value>,without-<feat>} string that can be passed to\nstandard GNU Autoconf scripts.\n\n# Example\n\n```nix\nwithFeatureAs true \"shared\" \"foo\"\n=> \"--with-shared=foo\"\nwithFeatureAs false \"shared\" (throw \"ignored\")\n=> \"--without-shared\"\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 19,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1193
        }
      }
    },
    "path": ["lib", "strings", "withFeatureAs"]
  },
  {
    "aliases": [
      ["lib", "withFeature"],
      ["lib", "strings", "withFeature"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Create an --{with,without}-<feat> string that can be passed to\nstandard GNU Autoconf scripts.\n\n# Example\n\n```nix\nwithFeature true \"shared\"\n=> \"--with-shared\"\nwithFeature false \"shared\"\n=> \"--without-shared\"\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1176
        }
      },
      "lambdaDocs": {
        "content": "Create an --{with,without}-<feat> string that can be passed to\nstandard GNU Autoconf scripts.\n\n# Example\n\n```nix\nwithFeature true \"shared\"\n=> \"--with-shared\"\nwithFeature false \"shared\"\n=> \"--without-shared\"\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1176
        }
      }
    },
    "path": ["lib", "strings", "withFeature"]
  },
  {
    "aliases": [
      ["lib", "versionOlder"],
      ["lib", "strings", "versionOlder"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Return true if string v1 denotes a version older than v2.\n\n# Example\n\n```nix\nversionOlder \"1.1\" \"1.2\"\n=> true\nversionOlder \"1.1\" \"1.1\"\n=> false\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 972
        }
      },
      "lambdaDocs": {
        "content": "Return true if string v1 denotes a version older than v2.\n\n# Example\n\n```nix\nversionOlder \"1.1\" \"1.2\"\n=> true\nversionOlder \"1.1\" \"1.1\"\n=> false\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 18,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 972
        }
      }
    },
    "path": ["lib", "strings", "versionOlder"]
  },
  {
    "aliases": [
      ["lib", "versionAtLeast"],
      ["lib", "strings", "versionAtLeast"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Return true if string v1 denotes a version equal to or newer than v2.\n\n# Example\n\n```nix\nversionAtLeast \"1.1\" \"1.0\"\n=> true\nversionAtLeast \"1.1\" \"1.1\"\n=> true\nversionAtLeast \"1.1\" \"1.2\"\n=> false\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 988
        }
      },
      "lambdaDocs": {
        "content": "Return true if string v1 denotes a version equal to or newer than v2.\n\n# Example\n\n```nix\nversionAtLeast \"1.1\" \"1.0\"\n=> true\nversionAtLeast \"1.1\" \"1.1\"\n=> true\nversionAtLeast \"1.1\" \"1.2\"\n=> false\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 20,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 988
        }
      }
    },
    "path": ["lib", "strings", "versionAtLeast"]
  },
  {
    "aliases": [["builtins", "unsafeDiscardStringContext"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 17
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "strings", "unsafeDiscardStringContext"]
  },
  {
    "aliases": [
      ["lib", "strings", "typeOf"],
      ["builtins", "typeOf"],
      ["builtins", "typeOf"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 17
        }
      },
      "lambdaDocs": {
        "content": "Return a string representing the type of the value *e*, namely\n`\"int\"`, `\"bool\"`, `\"string\"`, `\"path\"`, `\"null\"`, `\"set\"`,\n`\"list\"`, `\"lambda\"` or `\"float\"`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "strings", "typeOf"]
  },
  {
    "aliases": [
      ["lib", "toUpper"],
      ["lib", "toLower"],
      ["lib", "strings", "toUpper"],
      ["lib", "strings", "toLower"],
      ["lib", "strings", "escapeXML"],
      ["lib", "strings", "escapeURL"],
      ["lib", "strings", "escapeRegex"],
      ["lib", "escapeXML"],
      ["lib", "escapeURL"],
      ["lib", "escapeRegex"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Converts an ASCII string to upper-case.\n\n# Example\n\n```nix\ntoUpper \"home\"\n=> \"HOME\"\n```\n\n# Type\n\n```\ntoUpper :: string -> string\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 838
        }
      },
      "lambdaDocs": {
        "content": "Given string *s*, replace every occurrence of the strings in *from*\nwith the corresponding string in *to*.\n\nThe argument *to* is lazy, that is, it is only evaluated when its corresponding pattern in *from* is matched in the string *s*\n\nExample:\n\n```nix\nbuiltins.replaceStrings [\"oo\" \"a\"] [\"a\" \"i\"] \"foobar\"\n```\n\nevaluates to `\"fabir\"`.",
        "countApplied": 2,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "strings", "toUpper"]
  },
  {
    "aliases": [
      ["lib", "toShellVars"],
      ["lib", "strings", "toShellVars"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Translate an attribute set into corresponding shell variable declarations\nusing `toShellVar`.\n\n# Example\n\n```nix\nlet\n  foo = \"value\";\n  bar = foo;\nin ''\n  ${toShellVars { inherit foo bar; }}\n  [[ \"$foo\" == \"$bar\" ]]\n''\n```\n\n# Type\n\n```\nattrsOf (string | listOf string | attrsOf string) -> string\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 715
        }
      },
      "lambdaDocs": {
        "content": "Translate an attribute set into corresponding shell variable declarations\nusing `toShellVar`.\n\n# Example\n\n```nix\nlet\n  foo = \"value\";\n  bar = foo;\nin ''\n  ${toShellVars { inherit foo bar; }}\n  [[ \"$foo\" == \"$bar\" ]]\n''\n```\n\n# Type\n\n```\nattrsOf (string | listOf string | attrsOf string) -> string\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 715
        }
      }
    },
    "path": ["lib", "strings", "toShellVars"]
  },
  {
    "aliases": [
      ["lib", "toShellVar"],
      ["lib", "strings", "toShellVar"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Translate a Nix value into a shell variable declaration, with proper escaping.\n\nThe value can be a string (mapped to a regular variable), a list of strings\n(mapped to a Bash-style array) or an attribute set of strings (mapped to a\nBash-style associative array). Note that \"string\" includes string-coercible\nvalues like paths or derivations.\n\nStrings are translated into POSIX sh-compatible code; lists and attribute sets\nassume a shell that understands Bash syntax (e.g. Bash or ZSH).\n\n# Example\n\n```nix\n''\n  ${toShellVar \"foo\" \"some string\"}\n  [[ \"$foo\" == \"some string\" ]]\n''\n```\n\n# Type\n\n```\nstring -> (string | listOf string | attrsOf string) -> string\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 679
        }
      },
      "lambdaDocs": {
        "content": "Translate a Nix value into a shell variable declaration, with proper escaping.\n\nThe value can be a string (mapped to a regular variable), a list of strings\n(mapped to a Bash-style array) or an attribute set of strings (mapped to a\nBash-style associative array). Note that \"string\" includes string-coercible\nvalues like paths or derivations.\n\nStrings are translated into POSIX sh-compatible code; lists and attribute sets\nassume a shell that understands Bash syntax (e.g. Bash or ZSH).\n\n# Example\n\n```nix\n''\n  ${toShellVar \"foo\" \"some string\"}\n  [[ \"$foo\" == \"some string\" ]]\n''\n```\n\n# Type\n\n```\nstring -> (string | listOf string | attrsOf string) -> string\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 16,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 679
        }
      }
    },
    "path": ["lib", "strings", "toShellVar"]
  },
  {
    "aliases": [
      ["lib", "toUpper"],
      ["lib", "toLower"],
      ["lib", "strings", "toUpper"],
      ["lib", "strings", "toLower"],
      ["lib", "strings", "escapeXML"],
      ["lib", "strings", "escapeURL"],
      ["lib", "strings", "escapeRegex"],
      ["lib", "escapeXML"],
      ["lib", "escapeURL"],
      ["lib", "escapeRegex"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Converts an ASCII string to lower-case.\n\n# Example\n\n```nix\ntoLower \"HOME\"\n=> \"home\"\n```\n\n# Type\n\n```\ntoLower :: string -> string\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 820
        }
      },
      "lambdaDocs": {
        "content": "Given string *s*, replace every occurrence of the strings in *from*\nwith the corresponding string in *to*.\n\nThe argument *to* is lazy, that is, it is only evaluated when its corresponding pattern in *from* is matched in the string *s*\n\nExample:\n\n```nix\nbuiltins.replaceStrings [\"oo\" \"a\"] [\"a\" \"i\"] \"foobar\"\n```\n\nevaluates to `\"fabir\"`.",
        "countApplied": 2,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "strings", "toLower"]
  },
  {
    "aliases": [
      ["lib", "strings", "toJSON"],
      ["builtins", "toJSON"],
      ["builtins", "toJSON"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 17
        }
      },
      "lambdaDocs": {
        "content": "Return a string containing a JSON representation of *e*. Strings,\nintegers, floats, booleans, nulls and lists are mapped to their JSON\nequivalents. Sets (except derivations) are represented as objects.\nDerivations are translated to a JSON string containing the\nderivation’s output path. Paths are copied to the store and\nrepresented as a JSON string of the resulting store path.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "strings", "toJSON"]
  },
  {
    "aliases": [
      ["lib", "toIntBase10"],
      ["lib", "strings", "toIntBase10"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Parse a string as a base 10 int. This supports parsing of zero-padded integers.\n\n# Example\n\n```nix\ntoIntBase10 \"1337\"\n           => 1337\n\n           toIntBase10 \"-4\"\n           => -4\n\n           toIntBase10 \" 123 \"\n           => 123\n\n           toIntBase10 \"00024\"\n           => 24\n\n           toIntBase10 \"3.14\"\n           => error: floating point JSON numbers are not supported\n```\n\n# Type\n\n```\nstring -> int\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1402
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1402
        }
      }
    },
    "path": ["lib", "strings", "toIntBase10"]
  },
  {
    "aliases": [
      ["lib", "toInt"],
      ["lib", "strings", "toInt"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Parse a string as an int. Does not support parsing of integers with preceding zero due to\nambiguity between zero-padded and octal numbers. See toIntBase10.\n\n# Example\n\n```nix\ntoInt \"1337\"\n           => 1337\n\n           toInt \"-4\"\n           => -4\n\n           toInt \" 123 \"\n           => 123\n\n           toInt \"00024\"\n           => error: Ambiguity in interpretation of 00024 between octal and zero padded integer.\n\n           toInt \"3.14\"\n           => error: floating point JSON numbers are not supported\n```\n\n# Type\n\n```\nstring -> int\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1343
        }
      },
      "lambdaDocs": {
        "content": "Parse a string as an int. Does not support parsing of integers with preceding zero due to\nambiguity between zero-padded and octal numbers. See toIntBase10.\n\n# Example\n\n```nix\ntoInt \"1337\"\n           => 1337\n\n           toInt \"-4\"\n           => -4\n\n           toInt \" 123 \"\n           => 123\n\n           toInt \"00024\"\n           => error: Ambiguity in interpretation of 00024 between octal and zero padded integer.\n\n           toInt \"3.14\"\n           => error: floating point JSON numbers are not supported\n```\n\n# Type\n\n```\nstring -> int\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 11,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1343
        }
      }
    },
    "path": ["lib", "strings", "toInt"]
  },
  {
    "aliases": [
      ["lib", "tail"],
      ["lib", "strings", "tail"],
      ["lib", "lists", "tail"],
      ["builtins", "tail"],
      ["builtins", "tail"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 17
        }
      },
      "lambdaDocs": {
        "content": "Return the second to last elements of a list; abort evaluation if\nthe argument isn’t a list or is an empty list.\n\n> **Warning**\n>\n> This function should generally be avoided since it's inefficient:\n> unlike Haskell's `tail`, it takes O(n) time, so recursing over a\n> list by repeatedly calling `tail` takes O(n^2) time.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "strings", "tail"]
  },
  {
    "aliases": [
      ["lib", "substring"],
      ["lib", "strings", "substring"],
      ["builtins", "substring"],
      ["builtins", "substring"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 17
        }
      },
      "lambdaDocs": {
        "content": "Return the substring of *s* from character position *start*\n(zero-based) up to but not including *start + len*. If *start* is\ngreater than the length of the string, an empty string is returned,\nand if *start + len* lies beyond the end of the string, only the\nsubstring up to the end of the string is returned. *start* must be\nnon-negative. For example,\n\n```nix\nbuiltins.substring 0 3 \"nixos\"\n```\n\nevaluates to `\"nix\"`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "strings", "substring"]
  },
  {
    "aliases": [
      ["lib", "strings", "stringToCharacters"],
      ["lib", "stringToCharacters"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Convert a string to a list of characters (i.e. singleton strings).\nThis allows you to, e.g., map a function over each character.  However,\nnote that this will likely be horribly inefficient; Nix is not a\ngeneral purpose programming language. Complex string manipulations\nshould, if appropriate, be done in a derivation.\nAlso note that Nix treats strings as a list of bytes and thus doesn't\nhandle unicode.\n\n# Example\n\n```nix\nstringToCharacters \"\"\n=> [ ]\nstringToCharacters \"abc\"\n=> [ \"a\" \"b\" \"c\" ]\nstringToCharacters \"🦄\"\n=> [ \"�\" \"�\" \"�\" \"�\" ]\n```\n\n# Type\n\n```\nstringToCharacters :: string -> [string]\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 487
        }
      },
      "lambdaDocs": {
        "content": "Convert a string to a list of characters (i.e. singleton strings).\nThis allows you to, e.g., map a function over each character.  However,\nnote that this will likely be horribly inefficient; Nix is not a\ngeneral purpose programming language. Complex string manipulations\nshould, if appropriate, be done in a derivation.\nAlso note that Nix treats strings as a list of bytes and thus doesn't\nhandle unicode.\n\n# Example\n\n```nix\nstringToCharacters \"\"\n=> [ ]\nstringToCharacters \"abc\"\n=> [ \"a\" \"b\" \"c\" ]\nstringToCharacters \"🦄\"\n=> [ \"�\" \"�\" \"�\" \"�\" ]\n```\n\n# Type\n\n```\nstringToCharacters :: string -> [string]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 487
        }
      }
    },
    "path": ["lib", "strings", "stringToCharacters"]
  },
  {
    "aliases": [
      ["lib", "strings", "stringLength"],
      ["lib", "stringLength"],
      ["builtins", "stringLength"],
      ["builtins", "stringLength"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 17
        }
      },
      "lambdaDocs": {
        "content": "Return the length of the string *e*. If *e* is not a string,\nevaluation is aborted.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "strings", "stringLength"]
  },
  {
    "aliases": [
      ["lib", "strings", "stringAsChars"],
      ["lib", "stringAsChars"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Manipulate a string character by character and replace them by\nstrings before concatenating the results.\n\n# Example\n\n```nix\nstringAsChars (x: if x == \"a\" then \"i\" else x) \"nax\"\n=> \"nix\"\n```\n\n# Type\n\n```\nstringAsChars :: (string -> string) -> string -> string\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 507
        }
      },
      "lambdaDocs": {
        "content": "Manipulate a string character by character and replace them by\nstrings before concatenating the results.\n\n# Example\n\n```nix\nstringAsChars (x: if x == \"a\" then \"i\" else x) \"nax\"\n=> \"nix\"\n```\n\n# Type\n\n```\nstringAsChars :: (string -> string) -> string -> string\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 509
        }
      }
    },
    "path": ["lib", "strings", "stringAsChars"]
  },
  {
    "aliases": [
      ["lib", "strings", "splitString"],
      ["lib", "splitString"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 872
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 872
        }
      }
    },
    "path": ["lib", "strings", "splitString"]
  },
  {
    "aliases": [
      ["lib", "strings", "split"],
      ["builtins", "split"],
      ["builtins", "split"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 17
        }
      },
      "lambdaDocs": {
        "content": "Returns a list composed of non matched strings interleaved with the\nlists of the [extended POSIX regular\nexpression](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04)\n*regex* matches of *str*. Each item in the lists of matched\nsequences is a regex group.\n\n```nix\nbuiltins.split \"(a)b\" \"abc\"\n```\n\nEvaluates to `[ \"\" [ \"a\" ] \"c\" ]`.\n\n```nix\nbuiltins.split \"([ac])\" \"abc\"\n```\n\nEvaluates to `[ \"\" [ \"a\" ] \"b\" [ \"c\" ] \"\" ]`.\n\n```nix\nbuiltins.split \"(a)|(c)\" \"abc\"\n```\n\nEvaluates to `[ \"\" [ \"a\" null ] \"b\" [ null \"c\" ] \"\" ]`.\n\n```nix\nbuiltins.split \"([[:upper:]]+)\" \" FOO \"\n```\n\nEvaluates to `[ \" \" [ \"FOO\" ] \" \" ]`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "strings", "split"]
  },
  {
    "aliases": [["lib", "strings", "sanitizeDerivationName"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1500
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1503
        }
      }
    },
    "path": ["lib", "strings", "sanitizeDerivationName"]
  },
  {
    "aliases": [
      ["lib", "strings", "replaceStrings"],
      ["lib", "strings", "replaceChars"],
      ["lib", "replaceStrings"],
      ["lib", "replaceChars"],
      ["builtins", "replaceStrings"],
      ["builtins", "replaceStrings"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 17
        }
      },
      "lambdaDocs": {
        "content": "Given string *s*, replace every occurrence of the strings in *from*\nwith the corresponding string in *to*.\n\nThe argument *to* is lazy, that is, it is only evaluated when its corresponding pattern in *from* is matched in the string *s*\n\nExample:\n\n```nix\nbuiltins.replaceStrings [\"oo\" \"a\"] [\"a\" \"i\"] \"foobar\"\n```\n\nevaluates to `\"fabir\"`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "strings", "replaceStrings"]
  },
  {
    "aliases": [
      ["lib", "strings", "replaceStrings"],
      ["lib", "strings", "replaceChars"],
      ["lib", "replaceStrings"],
      ["lib", "replaceChars"],
      ["builtins", "replaceStrings"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 798
        }
      },
      "lambdaDocs": {
        "content": "Given string *s*, replace every occurrence of the strings in *from*\nwith the corresponding string in *to*.\n\nThe argument *to* is lazy, that is, it is only evaluated when its corresponding pattern in *from* is matched in the string *s*\n\nExample:\n\n```nix\nbuiltins.replaceStrings [\"oo\" \"a\"] [\"a\" \"i\"] \"foobar\"\n```\n\nevaluates to `\"fabir\"`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "strings", "replaceChars"]
  },
  {
    "aliases": [
      ["lib", "strings", "removeSuffix"],
      ["lib", "removeSuffix"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Return a string without the specified suffix, if the suffix matches.\n\n# Example\n\n```nix\nremoveSuffix \"front\" \"homefront\"\n=> \"home\"\nremoveSuffix \"xxx\" \"homefront\"\n=> \"homefront\"\n```\n\n# Type\n\n```\nstring -> string -> string\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 937
        }
      },
      "lambdaDocs": {
        "content": "Return a string without the specified suffix, if the suffix matches.\n\n# Example\n\n```nix\nremoveSuffix \"front\" \"homefront\"\n=> \"home\"\nremoveSuffix \"xxx\" \"homefront\"\n=> \"homefront\"\n```\n\n# Type\n\n```\nstring -> string -> string\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 939
        }
      }
    },
    "path": ["lib", "strings", "removeSuffix"]
  },
  {
    "aliases": [
      ["lib", "strings", "removePrefix"],
      ["lib", "removePrefix"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Return a string without the specified prefix, if the prefix matches.\n\n# Example\n\n```nix\nremovePrefix \"foo.\" \"foo.bar.baz\"\n=> \"bar.baz\"\nremovePrefix \"xxx\" \"foo.bar.baz\"\n=> \"foo.bar.baz\"\n```\n\n# Type\n\n```\nstring -> string -> string\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 896
        }
      },
      "lambdaDocs": {
        "content": "Return a string without the specified prefix, if the prefix matches.\n\n# Example\n\n```nix\nremovePrefix \"foo.\" \"foo.bar.baz\"\n=> \"bar.baz\"\nremovePrefix \"xxx\" \"foo.bar.baz\"\n=> \"foo.bar.baz\"\n```\n\n# Type\n\n```\nstring -> string -> string\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 898
        }
      }
    },
    "path": ["lib", "strings", "removePrefix"]
  },
  {
    "aliases": [
      ["lib", "strings", "readPathsFromFile"],
      ["lib", "readPathsFromFile"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1449
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 6,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1450
        }
      }
    },
    "path": ["lib", "strings", "readPathsFromFile"]
  },
  {
    "aliases": [
      ["lib", "trivial", "readFile"],
      ["lib", "strings", "readFile"],
      ["lib", "readFile"],
      ["builtins", "readFile"],
      ["builtins", "readFile"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 17
        }
      },
      "lambdaDocs": {
        "content": "Return the contents of the file *path* as a string.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "strings", "readFile"]
  },
  {
    "aliases": [
      ["lib", "strings", "parseDrvName"],
      ["builtins", "parseDrvName"],
      ["builtins", "parseDrvName"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 17
        }
      },
      "lambdaDocs": {
        "content": "Split the string *s* into a package name and version. The package\nname is everything up to but not including the first dash not followed\nby a letter, and the version is everything following that dash. The\nresult is returned in a set `{ name, version }`. Thus,\n`builtins.parseDrvName \"nix-0.12pre12876\"` returns `{ name =\n\"nix\"; version = \"0.12pre12876\"; }`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "strings", "parseDrvName"]
  },
  {
    "aliases": [
      ["lib", "strings", "optionalString"],
      ["lib", "optionalString"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Depending on the boolean `cond', return either the given string\nor the empty string. Useful to concatenate against a bigger string.\n\n# Example\n\n```nix\noptionalString true \"some-string\"\n=> \"some-string\"\noptionalString false \"some-string\"\n=> \"\"\n```\n\n# Type\n\n```\noptionalString :: bool -> string -> string\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 345
        }
      },
      "lambdaDocs": {
        "content": "Depending on the boolean `cond', return either the given string\nor the empty string. Useful to concatenate against a bigger string.\n\n# Example\n\n```nix\noptionalString true \"some-string\"\n=> \"some-string\"\noptionalString false \"some-string\"\n=> \"\"\n```\n\n# Type\n\n```\noptionalString :: bool -> string -> string\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 347
        }
      }
    },
    "path": ["lib", "strings", "optionalString"]
  },
  {
    "aliases": [["lib", "strings", "normalizePath"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 311
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 19,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 311
        }
      }
    },
    "path": ["lib", "strings", "normalizePath"]
  },
  {
    "aliases": [
      ["lib", "strings", "nameFromURL"],
      ["lib", "nameFromURL"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1045
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1045
        }
      }
    },
    "path": ["lib", "strings", "nameFromURL"]
  },
  {
    "aliases": [
      ["lib", "strings", "mesonOption"],
      ["lib", "mesonOption"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Create a -D<feature>=<value> string that can be passed to typical Meson\ninvocations.\n\n# Example\n\n```nix\nmesonOption \"engine\" \"opengl\"\n=> \"-Dengine=opengl\"\n```\n\n# Type\n\n```\nmesonOption :: string -> string -> string\n\n@param feature The feature to be set\n@param value The desired value\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1072
        }
      },
      "lambdaDocs": {
        "content": "Create a -D<feature>=<value> string that can be passed to typical Meson\ninvocations.\n\n# Example\n\n```nix\nmesonOption \"engine\" \"opengl\"\n=> \"-Dengine=opengl\"\n```\n\n# Type\n\n```\nmesonOption :: string -> string -> string\n\n@param feature The feature to be set\n@param value The desired value\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1072
        }
      }
    },
    "path": ["lib", "strings", "mesonOption"]
  },
  {
    "aliases": [
      ["lib", "strings", "mesonEnable"],
      ["lib", "mesonEnable"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Create a -D<feature>={enabled,disabled} string that can be passed to\ntypical Meson invocations.\n\n# Example\n\n```nix\nmesonEnable \"docs\" true\n=> \"-Ddocs=enabled\"\nmesonEnable \"savage\" false\n=> \"-Dsavage=disabled\"\n```\n\n# Type\n\n```\nmesonEnable :: string -> bool -> string\n\n@param feature The feature to be enabled or disabled\n@param flag The controlling flag\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1126
        }
      },
      "lambdaDocs": {
        "content": "Create a -D<feature>={enabled,disabled} string that can be passed to\ntypical Meson invocations.\n\n# Example\n\n```nix\nmesonEnable \"docs\" true\n=> \"-Ddocs=enabled\"\nmesonEnable \"savage\" false\n=> \"-Dsavage=disabled\"\n```\n\n# Type\n\n```\nmesonEnable :: string -> bool -> string\n\n@param feature The feature to be enabled or disabled\n@param flag The controlling flag\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1126
        }
      }
    },
    "path": ["lib", "strings", "mesonEnable"]
  },
  {
    "aliases": [
      ["lib", "strings", "mesonBool"],
      ["lib", "mesonBool"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Create a -D<condition>={true,false} string that can be passed to typical\nMeson invocations.\n\n# Example\n\n```nix\nmesonBool \"hardened\" true\n=> \"-Dhardened=true\"\nmesonBool \"static\" false\n=> \"-Dstatic=false\"\n```\n\n# Type\n\n```\nmesonBool :: string -> bool -> string\n\n@param condition The condition to be made true or false\n@param flag The controlling flag of the condition\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1099
        }
      },
      "lambdaDocs": {
        "content": "Create a -D<condition>={true,false} string that can be passed to typical\nMeson invocations.\n\n# Example\n\n```nix\nmesonBool \"hardened\" true\n=> \"-Dhardened=true\"\nmesonBool \"static\" false\n=> \"-Dstatic=false\"\n```\n\n# Type\n\n```\nmesonBool :: string -> bool -> string\n\n@param condition The condition to be made true or false\n@param flag The controlling flag of the condition\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 15,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1099
        }
      }
    },
    "path": ["lib", "strings", "mesonBool"]
  },
  {
    "aliases": [
      ["lib", "strings", "match"],
      ["builtins", "match"],
      ["builtins", "match"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 17
        }
      },
      "lambdaDocs": {
        "content": "Returns a list if the [extended POSIX regular\nexpression](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04)\n*regex* matches *str* precisely, otherwise returns `null`. Each item\nin the list is a regex group.\n\n```nix\nbuiltins.match \"ab\" \"abc\"\n```\n\nEvaluates to `null`.\n\n```nix\nbuiltins.match \"abc\" \"abc\"\n```\n\nEvaluates to `[ ]`.\n\n```nix\nbuiltins.match \"a(b)(c)\" \"abc\"\n```\n\nEvaluates to `[ \"b\" \"c\" ]`.\n\n```nix\nbuiltins.match \"[[:space:]]+([[:upper:]]+)[[:space:]]+\" \"  FOO   \"\n```\n\nEvaluates to `[ \"FOO\" ]`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "strings", "match"]
  },
  {
    "aliases": [
      ["lib", "strings", "makeSearchPathOutput"],
      ["lib", "makeSearchPathOutput"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 258
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 260
        }
      }
    },
    "path": ["lib", "strings", "makeSearchPathOutput"]
  },
  {
    "aliases": [
      ["lib", "strings", "makeSearchPath"],
      ["lib", "makeSearchPath"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 232
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 234
        }
      }
    },
    "path": ["lib", "strings", "makeSearchPath"]
  },
  {
    "aliases": [
      ["lib", "strings", "makeLibraryPath"],
      ["lib", "strings", "makeBinPath"],
      ["lib", "makeLibraryPath"],
      ["lib", "makeBinPath"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 280
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 264
        }
      }
    },
    "path": ["lib", "strings", "makeLibraryPath"]
  },
  {
    "aliases": [
      ["lib", "strings", "makeLibraryPath"],
      ["lib", "strings", "makeBinPath"],
      ["lib", "makeLibraryPath"],
      ["lib", "makeBinPath"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 293
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 264
        }
      }
    },
    "path": ["lib", "strings", "makeBinPath"]
  },
  {
    "aliases": [["lib", "strings", "levenshteinAtMost"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1609
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 8,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1650
        }
      }
    },
    "path": ["lib", "strings", "levenshteinAtMost"]
  },
  {
    "aliases": [["lib", "strings", "levenshtein"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1547
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1547
        }
      }
    },
    "path": ["lib", "strings", "levenshtein"]
  },
  {
    "aliases": [
      ["lib", "strings", "isValidPosixName"],
      ["lib", "isValidPosixName"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Test whether the given name is a valid POSIX shell variable name.\n\n# Example\n\n```nix\nisValidPosixName \"foo_bar000\"\n=> true\nisValidPosixName \"0-bad.jpg\"\n=> false\n```\n\n# Type\n\n```\nstring -> bool\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 651
        }
      },
      "lambdaDocs": {
        "content": "Test whether the given name is a valid POSIX shell variable name.\n\n# Example\n\n```nix\nisValidPosixName \"foo_bar000\"\n=> true\nisValidPosixName \"0-bad.jpg\"\n=> false\n```\n\n# Type\n\n```\nstring -> bool\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 22,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 651
        }
      }
    },
    "path": ["lib", "strings", "isValidPosixName"]
  },
  {
    "aliases": [
      ["lib", "strings", "isStringLike"],
      ["lib", "isStringLike"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Check whether a value can be coerced to a string.\nThe value must be a string, path, or attribute set.\n\nString-like values can be used without explicit conversion in\nstring interpolations and in most functions that expect a string.",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1284
        }
      },
      "lambdaDocs": {
        "content": "Check whether a value can be coerced to a string.\nThe value must be a string, path, or attribute set.\n\nString-like values can be used without explicit conversion in\nstring interpolations and in most functions that expect a string.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 18,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1284
        }
      }
    },
    "path": ["lib", "strings", "isStringLike"]
  },
  {
    "aliases": [
      ["lib", "strings", "isString"],
      ["lib", "isString"],
      ["builtins", "isString"],
      ["builtins", "isString"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 17
        }
      },
      "lambdaDocs": {
        "content": "Return `true` if *e* evaluates to a string, and `false` otherwise.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "strings", "isString"]
  },
  {
    "aliases": [
      ["lib", "strings", "isStorePath"],
      ["lib", "isStorePath"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1306
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1306
        }
      }
    },
    "path": ["lib", "strings", "isStorePath"]
  },
  {
    "aliases": [
      ["lib", "strings", "isPath"],
      ["lib", "isPath"],
      ["builtins", "isPath"],
      ["builtins", "isPath"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 17
        }
      },
      "lambdaDocs": {
        "content": "Return `true` if *e* evaluates to a path, and `false` otherwise.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "strings", "isPath"]
  },
  {
    "aliases": [
      ["lib", "strings", "isList"],
      ["lib", "lists", "isList"],
      ["lib", "isList"],
      ["builtins", "isList"],
      ["builtins", "isList"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 17
        }
      },
      "lambdaDocs": {
        "content": "Return `true` if *e* evaluates to a list, and `false` otherwise.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "strings", "isList"]
  },
  {
    "aliases": [
      ["lib", "trivial", "isInt"],
      ["lib", "strings", "isInt"],
      ["lib", "isInt"],
      ["builtins", "isInt"],
      ["builtins", "isInt"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 17
        }
      },
      "lambdaDocs": {
        "content": "Return `true` if *e* evaluates to an integer, and `false` otherwise.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "strings", "isInt"]
  },
  {
    "aliases": [
      ["lib", "strings", "isConvertibleWithToString"],
      ["lib", "strings", "isCoercibleToString"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Check whether a list or other value can be passed to toString.\n\nMany types of value are coercible to string this way, including int, float,\nnull, bool, list of similarly coercible values.",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1272
        }
      },
      "lambdaDocs": {
        "content": "Check whether a list or other value can be passed to toString.\n\nMany types of value are coercible to string this way, including int, float,\nnull, bool, list of similarly coercible values.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 31,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1272
        }
      }
    },
    "path": ["lib", "strings", "isConvertibleWithToString"]
  },
  {
    "aliases": [
      ["lib", "strings", "isConvertibleWithToString"],
      ["lib", "strings", "isCoercibleToString"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Soft-deprecated function. While the original implementation is available as\nisConvertibleWithToString, consider using isStringLike instead, if suitable.",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1262
        }
      },
      "lambdaDocs": {
        "content": "Check whether a list or other value can be passed to toString.\n\nMany types of value are coercible to string this way, including int, float,\nnull, bool, list of similarly coercible values.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 31,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1272
        }
      }
    },
    "path": ["lib", "strings", "isCoercibleToString"]
  },
  {
    "aliases": [
      ["lib", "strings", "isAttrs"],
      ["lib", "isAttrs"],
      ["lib", "attrsets", "isAttrs"],
      ["builtins", "isAttrs"],
      ["builtins", "isAttrs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 17
        }
      },
      "lambdaDocs": {
        "content": "Return `true` if *e* evaluates to a set, and `false` otherwise.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "strings", "isAttrs"]
  },
  {
    "aliases": [
      ["lib", "strings", "intersperse"],
      ["lib", "intersperse"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 115
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 117
        }
      }
    },
    "path": ["lib", "strings", "intersperse"]
  },
  {
    "aliases": [
      ["lib", "strings", "head"],
      ["lib", "lists", "head"],
      ["lib", "head"],
      ["builtins", "head"],
      ["builtins", "head"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 17
        }
      },
      "lambdaDocs": {
        "content": "Return the first element of a list; abort evaluation if the argument\nisn’t a list or is an empty list. You can test whether a list is\nempty by comparing it with `[]`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "strings", "head"]
  },
  {
    "aliases": [
      ["lib", "strings", "hasSuffix"],
      ["lib", "hasSuffix"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Determine whether a string has given suffix.\n\n# Example\n\n```nix\nhasSuffix \"foo\" \"foobar\"\n=> false\nhasSuffix \"foo\" \"barfoo\"\n=> true\n```\n\n# Type\n\n```\nhasSuffix :: string -> string -> bool\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 404
        }
      },
      "lambdaDocs": {
        "content": "Determine whether a string has given suffix.\n\n# Example\n\n```nix\nhasSuffix \"foo\" \"foobar\"\n=> false\nhasSuffix \"foo\" \"barfoo\"\n=> true\n```\n\n# Type\n\n```\nhasSuffix :: string -> string -> bool\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 406
        }
      }
    },
    "path": ["lib", "strings", "hasSuffix"]
  },
  {
    "aliases": [
      ["lib", "strings", "hasPrefix"],
      ["lib", "hasPrefix"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Determine whether a string has given prefix.\n\n# Example\n\n```nix\nhasPrefix \"foo\" \"foobar\"\n=> true\nhasPrefix \"foo\" \"barfoo\"\n=> false\n```\n\n# Type\n\n```\nhasPrefix :: string -> string -> bool\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 369
        }
      },
      "lambdaDocs": {
        "content": "Determine whether a string has given prefix.\n\n# Example\n\n```nix\nhasPrefix \"foo\" \"foobar\"\n=> true\nhasPrefix \"foo\" \"barfoo\"\n=> false\n```\n\n# Type\n\n```\nhasPrefix :: string -> string -> bool\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 371
        }
      }
    },
    "path": ["lib", "strings", "hasPrefix"]
  },
  {
    "aliases": [
      ["lib", "strings", "hasInfix"],
      ["lib", "hasInfix"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Determine whether a string contains the given infix\n\n# Example\n\n```nix\nhasInfix \"bc\" \"abcd\"\n=> true\nhasInfix \"ab\" \"abcd\"\n=> true\nhasInfix \"cd\" \"abcd\"\n=> true\nhasInfix \"foo\" \"abcd\"\n=> false\n```\n\n# Type\n\n```\nhasInfix :: string -> string -> bool\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 449
        }
      },
      "lambdaDocs": {
        "content": "Determine whether a string contains the given infix\n\n# Example\n\n```nix\nhasInfix \"bc\" \"abcd\"\n=> true\nhasInfix \"ab\" \"abcd\"\n=> true\nhasInfix \"cd\" \"abcd\"\n=> true\nhasInfix \"foo\" \"abcd\"\n=> false\n```\n\n# Type\n\n```\nhasInfix :: string -> string -> bool\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 449
        }
      }
    },
    "path": ["lib", "strings", "hasInfix"]
  },
  {
    "aliases": [
      ["lib", "strings", "getVersion"],
      ["lib", "getVersion"]
    ],
    "docs": {
      "attrDocs": {
        "content": "This function takes an argument that's either a derivation or a\nderivation's \"name\" attribute and extracts the version part from that\nargument.\n\n# Example\n\n```nix\ngetVersion \"youtube-dl-2016.01.01\"\n=> \"2016.01.01\"\ngetVersion pkgs.youtube-dl\n=> \"2016.01.01\"\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1025
        }
      },
      "lambdaDocs": {
        "content": "This function takes an argument that's either a derivation or a\nderivation's \"name\" attribute and extracts the version part from that\nargument.\n\n# Example\n\n```nix\ngetVersion \"youtube-dl-2016.01.01\"\n=> \"2016.01.01\"\ngetVersion pkgs.youtube-dl\n=> \"2016.01.01\"\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 16,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1025
        }
      }
    },
    "path": ["lib", "strings", "getVersion"]
  },
  {
    "aliases": [
      ["lib", "strings", "getName"],
      ["lib", "getName"]
    ],
    "docs": {
      "attrDocs": {
        "content": "This function takes an argument that's either a derivation or a\nderivation's \"name\" attribute and extracts the name part from that\nargument.\n\n# Example\n\n```nix\ngetName \"youtube-dl-2016.01.01\"\n=> \"youtube-dl\"\ngetName pkgs.youtube-dl\n=> \"youtube-dl\"\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1004
        }
      },
      "lambdaDocs": {
        "content": "This function takes an argument that's either a derivation or a\nderivation's \"name\" attribute and extracts the name part from that\nargument.\n\n# Example\n\n```nix\ngetName \"youtube-dl-2016.01.01\"\n=> \"youtube-dl\"\ngetName pkgs.youtube-dl\n=> \"youtube-dl\"\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 13,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1004
        }
      }
    },
    "path": ["lib", "strings", "getName"]
  },
  {
    "aliases": [
      ["lib", "strings", "genList"],
      ["lib", "lists", "genList"],
      ["lib", "genList"],
      ["builtins", "genList"],
      ["builtins", "genList"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 17
        }
      },
      "lambdaDocs": {
        "content": "Generate list of size *length*, with each element *i* equal to the\nvalue returned by *generator* `i`. For example,\n\n```nix\nbuiltins.genList (x: x * x) 5\n```\n\nreturns the list `[ 0 1 4 9 16 ]`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "strings", "genList"]
  },
  {
    "aliases": [
      ["lib", "strings", "fromJSON"],
      ["builtins", "fromJSON"],
      ["builtins", "fromJSON"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 17
        }
      },
      "lambdaDocs": {
        "content": "Convert a JSON string to a Nix value. For example,\n\n```nix\nbuiltins.fromJSON ''{\"x\": [1, 2, 3], \"y\": null}''\n```\n\nreturns the value `{ x = [ 1 2 3 ]; y = null; }`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "strings", "fromJSON"]
  },
  {
    "aliases": [["lib", "strings", "floatToString"]],
    "docs": {
      "attrDocs": {
        "content": "Convert a float to a string, but emit a warning when precision is lost\nduring the conversion\n\n# Example\n\n```nix\nfloatToString 0.000001\n=> \"0.000001\"\nfloatToString 0.0000001\n=> trace: warning: Imprecise conversion from float to string 0.000000\n   \"0.000000\"\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1252
        }
      },
      "lambdaDocs": {
        "content": "Convert a float to a string, but emit a warning when precision is lost\nduring the conversion\n\n# Example\n\n```nix\nfloatToString 0.000001\n=> \"0.000001\"\nfloatToString 0.0000001\n=> trace: warning: Imprecise conversion from float to string 0.000000\n   \"0.000000\"\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 19,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1252
        }
      }
    },
    "path": ["lib", "strings", "floatToString"]
  },
  {
    "aliases": [
      ["lib", "strings", "fixedWidthString"],
      ["lib", "fixedWidthString"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Create a fixed width string with additional prefix to match\nrequired width.\n\nThis function will fail if the input string is longer than the\nrequested length.\n\n# Example\n\n```nix\nfixedWidthString 5 \"0\" (toString 15)\n=> \"00015\"\n```\n\n# Type\n\n```\nfixedWidthString :: int -> string -> string -> string\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1215
        }
      },
      "lambdaDocs": {
        "content": "Create a fixed width string with additional prefix to match\nrequired width.\n\nThis function will fail if the input string is longer than the\nrequested length.\n\n# Example\n\n```nix\nfixedWidthString 5 \"0\" (toString 15)\n=> \"00015\"\n```\n\n# Type\n\n```\nfixedWidthString :: int -> string -> string -> string\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 22,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1215
        }
      }
    },
    "path": ["lib", "strings", "fixedWidthString"]
  },
  {
    "aliases": [
      ["lib", "strings", "fixedWidthNumber"],
      ["lib", "fixedWidthNumber"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Format a number adding leading zeroes up to fixed width.\n\n# Example\n\n```nix\nfixedWidthNumber 5 15\n=> \"00015\"\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1236
        }
      },
      "lambdaDocs": {
        "content": "Format a number adding leading zeroes up to fixed width.\n\n# Example\n\n```nix\nfixedWidthNumber 5 15\n=> \"00015\"\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 22,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1236
        }
      }
    },
    "path": ["lib", "strings", "fixedWidthNumber"]
  },
  {
    "aliases": [
      ["lib", "strings", "filter"],
      ["lib", "lists", "filter"],
      ["lib", "filter"],
      ["builtins", "filter"],
      ["builtins", "filter"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 17
        }
      },
      "lambdaDocs": {
        "content": "Return a list consisting of the elements of *list* for which the\nfunction *f* returns `true`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "strings", "filter"]
  },
  {
    "aliases": [
      ["lib", "strings", "fileContents"],
      ["lib", "fileContents"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1477
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 18,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1477
        }
      }
    },
    "path": ["lib", "strings", "fileContents"]
  },
  {
    "aliases": [
      ["lib", "toUpper"],
      ["lib", "toLower"],
      ["lib", "strings", "toUpper"],
      ["lib", "strings", "toLower"],
      ["lib", "strings", "escapeXML"],
      ["lib", "strings", "escapeURL"],
      ["lib", "strings", "escapeRegex"],
      ["lib", "escapeXML"],
      ["lib", "escapeURL"],
      ["lib", "escapeRegex"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Escapes a string such that it is safe to include verbatim in an XML\ndocument.\n\n# Example\n\n```nix\nescapeXML ''\"test\" 'test' < & >''\n=> \"&quot;test&quot; &apos;test&apos; &lt; &amp; &gt;\"\n```\n\n# Type\n\n```\nstring -> string\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 793
        }
      },
      "lambdaDocs": {
        "content": "Given string *s*, replace every occurrence of the strings in *from*\nwith the corresponding string in *to*.\n\nThe argument *to* is lazy, that is, it is only evaluated when its corresponding pattern in *from* is matched in the string *s*\n\nExample:\n\n```nix\nbuiltins.replaceStrings [\"oo\" \"a\"] [\"a\" \"i\"] \"foobar\"\n```\n\nevaluates to `\"fabir\"`.",
        "countApplied": 2,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "strings", "escapeXML"]
  },
  {
    "aliases": [
      ["lib", "toUpper"],
      ["lib", "toLower"],
      ["lib", "strings", "toUpper"],
      ["lib", "strings", "toLower"],
      ["lib", "strings", "escapeXML"],
      ["lib", "strings", "escapeURL"],
      ["lib", "strings", "escapeRegex"],
      ["lib", "escapeXML"],
      ["lib", "escapeURL"],
      ["lib", "escapeRegex"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 591
        }
      },
      "lambdaDocs": {
        "content": "Given string *s*, replace every occurrence of the strings in *from*\nwith the corresponding string in *to*.\n\nThe argument *to* is lazy, that is, it is only evaluated when its corresponding pattern in *from* is matched in the string *s*\n\nExample:\n\n```nix\nbuiltins.replaceStrings [\"oo\" \"a\"] [\"a\" \"i\"] \"foobar\"\n```\n\nevaluates to `\"fabir\"`.",
        "countApplied": 2,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "strings", "escapeURL"]
  },
  {
    "aliases": [
      ["lib", "strings", "escapeShellArgs"],
      ["lib", "escapeShellArgs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Quote all arguments to be safely passed to the Bourne shell.\n\n# Example\n\n```nix\nescapeShellArgs [\"one\" \"two three\" \"four'five\"]\n=> \"'one' 'two three' 'four'\\\\''five'\"\n```\n\n# Type\n\n```\nescapeShellArgs :: [string] -> string\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 631
        }
      },
      "lambdaDocs": {
        "content": "Maps a function over a list of strings and then concatenates the\nresult with the specified separator interspersed between\nelements.\n\n# Example\n\n```nix\nconcatMapStringsSep \"-\" (x: toUpper x)  [\"foo\" \"bar\" \"baz\"]\n=> \"FOO-BAR-BAZ\"\n```\n\n# Type\n\n```\nconcatMapStringsSep :: string -> (a -> string) -> [a] -> string\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 167
        }
      }
    },
    "path": ["lib", "strings", "escapeShellArgs"]
  },
  {
    "aliases": [
      ["lib", "strings", "escapeShellArg"],
      ["lib", "escapeShellArg"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Quote string to be used safely within the Bourne shell.\n\n# Example\n\n```nix\nescapeShellArg \"esc'ape\\nme\"\n=> \"'esc'\\\\''ape\\nme'\"\n```\n\n# Type\n\n```\nescapeShellArg :: string -> string\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 613
        }
      },
      "lambdaDocs": {
        "content": "Quote string to be used safely within the Bourne shell.\n\n# Example\n\n```nix\nescapeShellArg \"esc'ape\\nme\"\n=> \"'esc'\\\\''ape\\nme'\"\n```\n\n# Type\n\n```\nescapeShellArg :: string -> string\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 20,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 613
        }
      }
    },
    "path": ["lib", "strings", "escapeShellArg"]
  },
  {
    "aliases": [
      ["lib", "toUpper"],
      ["lib", "toLower"],
      ["lib", "strings", "toUpper"],
      ["lib", "strings", "toLower"],
      ["lib", "strings", "escapeXML"],
      ["lib", "strings", "escapeURL"],
      ["lib", "strings", "escapeRegex"],
      ["lib", "escapeXML"],
      ["lib", "escapeURL"],
      ["lib", "escapeRegex"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 751
        }
      },
      "lambdaDocs": {
        "content": "Given string *s*, replace every occurrence of the strings in *from*\nwith the corresponding string in *to*.\n\nThe argument *to* is lazy, that is, it is only evaluated when its corresponding pattern in *from* is matched in the string *s*\n\nExample:\n\n```nix\nbuiltins.replaceStrings [\"oo\" \"a\"] [\"a\" \"i\"] \"foobar\"\n```\n\nevaluates to `\"fabir\"`.",
        "countApplied": 2,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "strings", "escapeRegex"]
  },
  {
    "aliases": [["lib", "strings", "escapeNixString"]],
    "docs": {
      "attrDocs": {
        "content": "Turn a string into a Nix expression representing that string\n\n# Example\n\n```nix\nescapeNixString \"hello\\${}\\n\"\n=> \"\\\"hello\\\\\\${}\\\\n\\\"\"\n```\n\n# Type\n\n```\nstring -> string\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 733
        }
      },
      "lambdaDocs": {
        "content": "Turn a string into a Nix expression representing that string\n\n# Example\n\n```nix\nescapeNixString \"hello\\${}\\n\"\n=> \"\\\"hello\\\\\\${}\\\\n\\\"\"\n```\n\n# Type\n\n```\nstring -> string\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 733
        }
      }
    },
    "path": ["lib", "strings", "escapeNixString"]
  },
  {
    "aliases": [["lib", "strings", "escapeNixIdentifier"]],
    "docs": {
      "attrDocs": {
        "content": "Quotes a string if it can't be used as an identifier directly.\n\n# Example\n\n```nix\nescapeNixIdentifier \"hello\"\n=> \"hello\"\nescapeNixIdentifier \"0abc\"\n=> \"\\\"0abc\\\"\"\n```\n\n# Type\n\n```\nstring -> string\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 771
        }
      },
      "lambdaDocs": {
        "content": "Quotes a string if it can't be used as an identifier directly.\n\n# Example\n\n```nix\nescapeNixIdentifier \"hello\"\n=> \"hello\"\nescapeNixIdentifier \"0abc\"\n=> \"\\\"0abc\\\"\"\n```\n\n# Type\n\n```\nstring -> string\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 771
        }
      }
    },
    "path": ["lib", "strings", "escapeNixIdentifier"]
  },
  {
    "aliases": [["lib", "strings", "escapeC"]],
    "docs": {
      "attrDocs": {
        "content": "Escape occurrence of the element of `list` in `string` by\nconverting to its ASCII value and prefixing it with \\\\x.\nOnly works for printable ascii characters.\n\n# Example\n\n```nix\nescapeC [\" \"] \"foo bar\"\n=> \"foo\\\\x20bar\"\n```\n\n# Type\n\n```\nescapeC = [string] -> string -> string\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 572
        }
      },
      "lambdaDocs": {
        "content": "Escape occurrence of the element of `list` in `string` by\nconverting to its ASCII value and prefixing it with \\\\x.\nOnly works for printable ascii characters.\n\n# Example\n\n```nix\nescapeC [\" \"] \"foo bar\"\n=> \"foo\\\\x20bar\"\n```\n\n# Type\n\n```\nescapeC = [string] -> string -> string\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 13,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 572
        }
      }
    },
    "path": ["lib", "strings", "escapeC"]
  },
  {
    "aliases": [
      ["lib", "strings", "escape"],
      ["lib", "escape"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Escape occurrence of the elements of `list` in `string` by\nprefixing it with a backslash.\n\n# Example\n\n```nix\nescape [\"(\" \")\"] \"(foo)\"\n=> \"\\\\(foo\\\\)\"\n```\n\n# Type\n\n```\nescape :: [string] -> string -> string\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 552
        }
      },
      "lambdaDocs": {
        "content": "Escape occurrence of the elements of `list` in `string` by\nprefixing it with a backslash.\n\n# Example\n\n```nix\nescape [\"(\" \")\"] \"(foo)\"\n=> \"\\\\(foo\\\\)\"\n```\n\n# Type\n\n```\nescape :: [string] -> string -> string\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 12,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 552
        }
      }
    },
    "path": ["lib", "strings", "escape"]
  },
  {
    "aliases": [
      ["lib", "strings", "enableFeatureAs"],
      ["lib", "enableFeatureAs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Create an --{enable-<feat>=<value>,disable-<feat>} string that can be passed to\nstandard GNU Autoconf scripts.\n\n# Example\n\n```nix\nenableFeatureAs true \"shared\" \"foo\"\n=> \"--enable-shared=foo\"\nenableFeatureAs false \"shared\" (throw \"ignored\")\n=> \"--disable-shared\"\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1161
        }
      },
      "lambdaDocs": {
        "content": "Create an --{enable-<feat>=<value>,disable-<feat>} string that can be passed to\nstandard GNU Autoconf scripts.\n\n# Example\n\n```nix\nenableFeatureAs true \"shared\" \"foo\"\n=> \"--enable-shared=foo\"\nenableFeatureAs false \"shared\" (throw \"ignored\")\n=> \"--disable-shared\"\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1161
        }
      }
    },
    "path": ["lib", "strings", "enableFeatureAs"]
  },
  {
    "aliases": [
      ["lib", "strings", "enableFeature"],
      ["lib", "enableFeature"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Create an --{enable,disable}-<feat> string that can be passed to\nstandard GNU Autoconf scripts.\n\n# Example\n\n```nix\nenableFeature true \"shared\"\n=> \"--enable-shared\"\nenableFeature false \"shared\"\n=> \"--disable-shared\"\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1144
        }
      },
      "lambdaDocs": {
        "content": "Create an --{enable,disable}-<feat> string that can be passed to\nstandard GNU Autoconf scripts.\n\n# Example\n\n```nix\nenableFeature true \"shared\"\n=> \"--enable-shared\"\nenableFeature false \"shared\"\n=> \"--disable-shared\"\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 19,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1144
        }
      }
    },
    "path": ["lib", "strings", "enableFeature"]
  },
  {
    "aliases": [
      ["lib", "strings", "elemAt"],
      ["lib", "lists", "elemAt"],
      ["lib", "elemAt"],
      ["builtins", "elemAt"],
      ["builtins", "elemAt"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 17
        }
      },
      "lambdaDocs": {
        "content": "Return element *n* from the list *xs*. Elements are counted starting\nfrom 0. A fatal error occurs if the index is out of bounds.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "strings", "elemAt"]
  },
  {
    "aliases": [
      ["lib", "strings", "elem"],
      ["lib", "lists", "elem"],
      ["lib", "elem"],
      ["builtins", "elem"],
      ["builtins", "elem"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 17
        }
      },
      "lambdaDocs": {
        "content": "Return `true` if a value equal to *x* occurs in the list *xs*, and\n`false` otherwise.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "strings", "elem"]
  },
  {
    "aliases": [
      ["lib", "strings", "concatStringsSep"],
      ["lib", "concatStringsSep"],
      ["builtins", "concatStringsSep"],
      ["builtins", "concatStringsSep"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 140
        }
      },
      "lambdaDocs": {
        "content": "Concatenate a list of strings with a separator between each\nelement, e.g. `concatStringsSep \"/\" [\"usr\" \"local\" \"bin\"] ==\n\"usr/local/bin\"`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "strings", "concatStringsSep"]
  },
  {
    "aliases": [
      ["lib", "strings", "concatStrings"],
      ["lib", "concatStrings"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Concatenate a list of strings.\n\n# Example\n\n```nix\nconcatStrings [\"foo\" \"bar\"]\n=> \"foobar\"\n```\n\n# Type\n\n```\nconcatStrings :: [string] -> string\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 60
        }
      },
      "lambdaDocs": {
        "content": "Concatenate a list of strings with a separator between each\nelement, e.g. `concatStringsSep \"/\" [\"usr\" \"local\" \"bin\"] ==\n\"usr/local/bin\"`.",
        "countApplied": 1,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "strings", "concatStrings"]
  },
  {
    "aliases": [
      ["lib", "strings", "concatMapStringsSep"],
      ["lib", "concatMapStringsSep"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Maps a function over a list of strings and then concatenates the\nresult with the specified separator interspersed between\nelements.\n\n# Example\n\n```nix\nconcatMapStringsSep \"-\" (x: toUpper x)  [\"foo\" \"bar\" \"baz\"]\n=> \"FOO-BAR-BAZ\"\n```\n\n# Type\n\n```\nconcatMapStringsSep :: string -> (a -> string) -> [a] -> string\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 161
        }
      },
      "lambdaDocs": {
        "content": "Maps a function over a list of strings and then concatenates the\nresult with the specified separator interspersed between\nelements.\n\n# Example\n\n```nix\nconcatMapStringsSep \"-\" (x: toUpper x)  [\"foo\" \"bar\" \"baz\"]\n=> \"FOO-BAR-BAZ\"\n```\n\n# Type\n\n```\nconcatMapStringsSep :: string -> (a -> string) -> [a] -> string\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 163
        }
      }
    },
    "path": ["lib", "strings", "concatMapStringsSep"]
  },
  {
    "aliases": [
      ["lib", "strings", "concatMapStrings"],
      ["lib", "concatMapStrings"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Map a function over a list and concatenate the resulting strings.\n\n# Example\n\n```nix\nconcatMapStrings (x: \"a\" + x) [\"foo\" \"bar\"]\n=> \"afooabar\"\n```\n\n# Type\n\n```\nconcatMapStrings :: (a -> string) -> [a] -> string\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 78
        }
      },
      "lambdaDocs": {
        "content": "Map a function over a list and concatenate the resulting strings.\n\n# Example\n\n```nix\nconcatMapStrings (x: \"a\" + x) [\"foo\" \"bar\"]\n=> \"afooabar\"\n```\n\n# Type\n\n```\nconcatMapStrings :: (a -> string) -> [a] -> string\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 22,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 78
        }
      }
    },
    "path": ["lib", "strings", "concatMapStrings"]
  },
  {
    "aliases": [
      ["lib", "strings", "concatLines"],
      ["lib", "concatLines"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Concatenate a list of strings, adding a newline at the end of each one.\nDefined as `concatMapStrings (s: s + \"\\n\")`.\n\n# Example\n\n```nix\nconcatLines [ \"foo\" \"bar\" ]\n=> \"foo\\nbar\\n\"\n```\n\n# Type\n\n```\nconcatLines :: [string] -> string\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 211
        }
      },
      "lambdaDocs": {
        "content": "Map a function over a list and concatenate the resulting strings.\n\n# Example\n\n```nix\nconcatMapStrings (x: \"a\" + x) [\"foo\" \"bar\"]\n=> \"afooabar\"\n```\n\n# Type\n\n```\nconcatMapStrings :: (a -> string) -> [a] -> string\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 78
        }
      }
    },
    "path": ["lib", "strings", "concatLines"]
  },
  {
    "aliases": [
      ["lib", "strings", "concatImapStringsSep"],
      ["lib", "concatImapStringsSep"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 186
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 188
        }
      }
    },
    "path": ["lib", "strings", "concatImapStringsSep"]
  },
  {
    "aliases": [
      ["lib", "strings", "concatImapStrings"],
      ["lib", "concatImapStrings"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Like `concatMapStrings` except that the f functions also gets the\nposition as a parameter.\n\n# Example\n\n```nix\nconcatImapStrings (pos: x: \"${toString pos}-${x}\") [\"foo\" \"bar\"]\n=> \"1-foo2-bar\"\n```\n\n# Type\n\n```\nconcatImapStrings :: (int -> a -> string) -> [a] -> string\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 97
        }
      },
      "lambdaDocs": {
        "content": "Like `concatMapStrings` except that the f functions also gets the\nposition as a parameter.\n\n# Example\n\n```nix\nconcatImapStrings (pos: x: \"${toString pos}-${x}\") [\"foo\" \"bar\"]\n=> \"1-foo2-bar\"\n```\n\n# Type\n\n```\nconcatImapStrings :: (int -> a -> string) -> [a] -> string\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 97
        }
      }
    },
    "path": ["lib", "strings", "concatImapStrings"]
  },
  {
    "aliases": [
      ["lib", "strings", "compareVersions"],
      ["builtins", "compareVersions"],
      ["builtins", "compareVersions"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 17
        }
      },
      "lambdaDocs": {
        "content": "Compare two strings representing versions and return `-1` if\nversion *s1* is older than version *s2*, `0` if they are the same,\nand `1` if *s1* is newer than *s2*. The version comparison\nalgorithm is the same as the one used by [`nix-env\n-u`](../command-ref/nix-env.md#operation---upgrade).",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "strings", "compareVersions"]
  },
  {
    "aliases": [["lib", "strings", "commonSuffixLength"]],
    "docs": {
      "attrDocs": {
        "content": "Returns the length of the suffix common to both strings.",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1578
        }
      },
      "lambdaDocs": {
        "content": "Returns the length of the suffix common to both strings.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1578
        }
      }
    },
    "path": ["lib", "strings", "commonSuffixLength"]
  },
  {
    "aliases": [["lib", "strings", "commonPrefixLength"]],
    "docs": {
      "attrDocs": {
        "content": "Returns the length of the prefix common to both strings.",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1569
        }
      },
      "lambdaDocs": {
        "content": "Returns the length of the prefix common to both strings.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1569
        }
      }
    },
    "path": ["lib", "strings", "commonPrefixLength"]
  },
  {
    "aliases": [["lib", "strings", "charToInt"]],
    "docs": {
      "attrDocs": {
        "content": "Convert char to ascii value, must be in printable range\n\n# Example\n\n```nix\ncharToInt \"A\"\n=> 65\ncharToInt \"(\"\n=> 40\n```\n\n# Type\n\n```\ncharToInt :: string -> int\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 533
        }
      },
      "lambdaDocs": {
        "content": "Convert char to ascii value, must be in printable range\n\n# Example\n\n```nix\ncharToInt \"A\"\n=> 65\ncharToInt \"(\"\n=> 40\n```\n\n# Type\n\n```\ncharToInt :: string -> int\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 15,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 533
        }
      }
    },
    "path": ["lib", "strings", "charToInt"]
  },
  {
    "aliases": [
      ["lib", "strings", "addContextFrom"],
      ["lib", "addContextFrom"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Appends string context from another string.  This is an implementation\ndetail of Nix and should be used carefully.\n\nStrings in Nix carry an invisible `context` which is a list of strings\nrepresenting store paths.  If the string is later used in a derivation\nattribute, the derivation will properly populate the inputDrvs and\ninputSrcs.\n\n# Example\n\n```nix\npkgs = import <nixpkgs> { };\naddContextFrom pkgs.coreutils \"bar\"\n=> \"bar\"\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 857
        }
      },
      "lambdaDocs": {
        "content": "Appends string context from another string.  This is an implementation\ndetail of Nix and should be used carefully.\n\nStrings in Nix carry an invisible `context` which is a list of strings\nrepresenting store paths.  If the string is later used in a derivation\nattribute, the derivation will properly populate the inputDrvs and\ninputSrcs.\n\n# Example\n\n```nix\npkgs = import <nixpkgs> { };\naddContextFrom pkgs.coreutils \"bar\"\n=> \"bar\"\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 20,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 857
        }
      }
    },
    "path": ["lib", "strings", "addContextFrom"]
  },
  {
    "aliases": [
      ["lib", "strings", "stringToCharacters"],
      ["lib", "stringToCharacters"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "Convert a string to a list of characters (i.e. singleton strings).\nThis allows you to, e.g., map a function over each character.  However,\nnote that this will likely be horribly inefficient; Nix is not a\ngeneral purpose programming language. Complex string manipulations\nshould, if appropriate, be done in a derivation.\nAlso note that Nix treats strings as a list of bytes and thus doesn't\nhandle unicode.\n\n# Example\n\n```nix\nstringToCharacters \"\"\n=> [ ]\nstringToCharacters \"abc\"\n=> [ \"a\" \"b\" \"c\" ]\nstringToCharacters \"🦄\"\n=> [ \"�\" \"�\" \"�\" \"�\" ]\n```\n\n# Type\n\n```\nstringToCharacters :: string -> [string]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 487
        }
      }
    },
    "path": ["lib", "stringToCharacters"]
  },
  {
    "aliases": [
      ["lib", "strings", "stringLength"],
      ["lib", "stringLength"],
      ["builtins", "stringLength"],
      ["builtins", "stringLength"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 68
        }
      },
      "lambdaDocs": {
        "content": "Return the length of the string *e*. If *e* is not a string,\nevaluation is aborted.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "stringLength"]
  },
  {
    "aliases": [
      ["lib", "strings", "stringAsChars"],
      ["lib", "stringAsChars"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "Manipulate a string character by character and replace them by\nstrings before concatenating the results.\n\n# Example\n\n```nix\nstringAsChars (x: if x == \"a\" then \"i\" else x) \"nax\"\n=> \"nix\"\n```\n\n# Type\n\n```\nstringAsChars :: (string -> string) -> string -> string\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 509
        }
      }
    },
    "path": ["lib", "stringAsChars"]
  },
  {
    "aliases": [
      ["lib", "stringsWithDeps", "stringAfter"],
      ["lib", "stringAfter"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 35,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 114
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings-with-deps.nix",
          "line": 84
        }
      }
    },
    "path": ["lib", "stringAfter"]
  },
  {
    "aliases": [
      ["lib", "versions", "splitVersion"],
      ["lib", "splitVersion"],
      ["builtins", "splitVersion"],
      ["builtins", "splitVersion"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 166
        }
      },
      "lambdaDocs": {
        "content": "Split a string representing a version into its components, by the\nsame version splitting logic underlying the version comparison in\n[`nix-env -u`](../command-ref/nix-env.md#operation---upgrade).",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "splitVersion"]
  },
  {
    "aliases": [
      ["lib", "strings", "splitString"],
      ["lib", "splitString"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 872
        }
      }
    },
    "path": ["lib", "splitString"]
  },
  {
    "aliases": [
      ["lib", "trivial", "splitByAndCompare"],
      ["lib", "splitByAndCompare"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 73
        }
      },
      "lambdaDocs": {
        "content": "Split type into two subtypes by predicate `p`, take all elements\nof the first subtype to be less than all the elements of the\nsecond subtype, compare elements of a single subtype with `yes`\nand `no` respectively.\n\n# Example\n\n```nix\nlet cmp = splitByAndCompare (hasPrefix \"foo\") compare compare; in\n\n           cmp \"a\" \"z\" => -1\n           cmp \"fooa\" \"fooz\" => -1\n\n           cmp \"f\" \"a\" => 1\n           cmp \"fooa\" \"a\" => -1\n           # while\n           compare \"fooa\" \"a\" => 1\n```\n\n# Type\n\n```\n(a -> bool) -> (a -> a -> int) -> (a -> a -> int) -> (a -> a -> int)\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 402
        }
      }
    },
    "path": ["lib", "splitByAndCompare"]
  },
  {
    "aliases": [
      ["lib", "sources", "trace"],
      ["builtins", "trace"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/sources.nix",
          "line": 295
        }
      },
      "lambdaDocs": {
        "content": "Add logging to a source, for troubleshooting the filtering behavior.\n\n# Type\n\n```\nsources.trace :: sourceLike -> Source\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/sources.nix",
          "line": 109
        }
      }
    },
    "path": ["lib", "sources", "trace"]
  },
  {
    "aliases": [
      ["lib", "sources", "sourceFilesBySuffices"],
      ["lib", "sourceFilesBySuffices"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/sources.nix",
          "line": 295
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/sources.nix",
          "line": 165
        }
      }
    },
    "path": ["lib", "sources", "sourceFilesBySuffices"]
  },
  {
    "aliases": [
      ["lib", "sources", "sourceByRegex"],
      ["lib", "sourceByRegex"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/sources.nix",
          "line": 295
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 19,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/sources.nix",
          "line": 134
        }
      }
    },
    "path": ["lib", "sources", "sourceByRegex"]
  },
  {
    "aliases": [
      ["lib", "sources", "pathType"],
      ["lib", "pathType"],
      ["lib", "filesystem", "pathType"],
      ["builtins", "readFileType"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/sources.nix",
          "line": 283
        }
      },
      "lambdaDocs": {
        "content": "Determine the directory entry type of a filesystem node, being\none of \"directory\", \"regular\", \"symlink\", or \"unknown\".",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "sources", "pathType"]
  },
  {
    "aliases": [
      ["lib", "sources", "pathIsRegularFile"],
      ["lib", "pathIsRegularFile"],
      ["lib", "filesystem", "pathIsRegularFile"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/sources.nix",
          "line": 291
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/filesystem.nix",
          "line": 102
        }
      }
    },
    "path": ["lib", "sources", "pathIsRegularFile"]
  },
  {
    "aliases": [
      ["lib", "sources", "pathIsGitRepo"],
      ["lib", "pathIsGitRepo"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/sources.nix",
          "line": 295
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 19,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/sources.nix",
          "line": 173
        }
      }
    },
    "path": ["lib", "sources", "pathIsGitRepo"]
  },
  {
    "aliases": [
      ["lib", "sources", "pathIsDirectory"],
      ["lib", "pathIsDirectory"],
      ["lib", "filesystem", "pathIsDirectory"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/sources.nix",
          "line": 287
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/filesystem.nix",
          "line": 77
        }
      }
    },
    "path": ["lib", "sources", "pathIsDirectory"]
  },
  {
    "aliases": [
      ["lib", "sources", "pathHasContext"],
      ["lib", "pathHasContext"],
      ["builtins", "hasContext"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/sources.nix",
          "line": 295
        }
      },
      "lambdaDocs": {
        "content": "Return `true` if string *s* has a non-empty context. The\ncontext can be obtained with\n[`getContext`](#builtins-getContext).",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "sources", "pathHasContext"]
  },
  {
    "aliases": [
      ["lib", "sources", "commitIdFromGitRepo"],
      ["lib", "commitIdFromGitRepo"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/sources.nix",
          "line": 295
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/sources.nix",
          "line": 184
        }
      }
    },
    "path": ["lib", "sources", "commitIdFromGitRepo"]
  },
  {
    "aliases": [
      ["lib", "sources", "cleanSourceWith"],
      ["lib", "cleanSourceWith"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/sources.nix",
          "line": 295
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/sources.nix",
          "line": 76
        }
      }
    },
    "path": ["lib", "sources", "cleanSourceWith"]
  },
  {
    "aliases": [
      ["lib", "sources", "cleanSourceFilter"],
      ["lib", "cleanSourceFilter"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/sources.nix",
          "line": 295
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/sources.nix",
          "line": 26
        }
      }
    },
    "path": ["lib", "sources", "cleanSourceFilter"]
  },
  {
    "aliases": [
      ["lib", "sources", "cleanSource"],
      ["lib", "cleanSource"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/sources.nix",
          "line": 295
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/sources.nix",
          "line": 52
        }
      }
    },
    "path": ["lib", "sources", "cleanSource"]
  },
  {
    "aliases": [
      ["lib", "sources", "canCleanSource"],
      ["lib", "canCleanSource"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/sources.nix",
          "line": 295
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 20,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/sources.nix",
          "line": 247
        }
      }
    },
    "path": ["lib", "sources", "canCleanSource"]
  },
  {
    "aliases": [
      ["lib", "sources", "sourceFilesBySuffices"],
      ["lib", "sourceFilesBySuffices"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 124
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/sources.nix",
          "line": 165
        }
      }
    },
    "path": ["lib", "sourceFilesBySuffices"]
  },
  {
    "aliases": [
      ["lib", "sources", "sourceByRegex"],
      ["lib", "sourceByRegex"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 124
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 19,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/sources.nix",
          "line": 134
        }
      }
    },
    "path": ["lib", "sourceByRegex"]
  },
  {
    "aliases": [
      ["lib", "sortProperties"],
      ["lib", "modules", "sortProperties"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 128
        }
      },
      "lambdaDocs": {
        "content": "Sort a list of properties.  The sort priority of a property is\ndefaultOrderPriority by default, but can be overridden by wrapping the property\nusing mkOrder.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 20,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 951
        }
      }
    },
    "path": ["lib", "sortProperties"]
  },
  {
    "aliases": [
      ["lib", "sort"],
      ["lib", "lists", "sort"],
      ["builtins", "sort"],
      ["builtins", "sort"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 92
        }
      },
      "lambdaDocs": {
        "content": "Return *list* in sorted order. It repeatedly calls the function\n*comparator* with two elements. The comparator should return `true`\nif the first element is less than the second, and `false` otherwise.\nFor example,\n\n```nix\nbuiltins.sort builtins.lessThan [ 483 249 526 147 42 77 ]\n```\n\nproduces the list `[ 42 77 147 249 483 526 ]`.\n\nThis is a stable sort: it preserves the relative order of elements\ndeemed equal by the comparator.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "sort"]
  },
  {
    "aliases": [
      ["lib", "singleton"],
      ["lib", "lists", "singleton"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 92
        }
      },
      "lambdaDocs": {
        "content": "Create a list consisting of a single element.  `singleton x` is\nsometimes more convenient with respect to indentation than `[x]`\nwhen x spans multiple lines.\n\n# Example\n\n```nix\nsingleton \"foo\"\n=> [ \"foo\" ]\n```\n\n# Type\n\n```\nsingleton :: a -> [a]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 15,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 31
        }
      }
    },
    "path": ["lib", "singleton"]
  },
  {
    "aliases": [
      ["lib", "trivial", "showWarnings"],
      ["lib", "showWarnings"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 73
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 18,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 561
        }
      }
    },
    "path": ["lib", "showWarnings"]
  },
  {
    "aliases": [
      ["lib", "showOptionWithDefLocs"],
      ["lib", "options", "showOptionWithDefLocs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 140
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 461
        }
      }
    },
    "path": ["lib", "showOptionWithDefLocs"]
  },
  {
    "aliases": [
      ["lib", "showOption"],
      ["lib", "options", "showOption"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 140
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 16,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 426
        }
      }
    },
    "path": ["lib", "showOption"]
  },
  {
    "aliases": [
      ["lib", "showFiles"],
      ["lib", "options", "showFiles"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 140
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 15,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 440
        }
      }
    },
    "path": ["lib", "showFiles"]
  },
  {
    "aliases": [
      ["lib", "showAttrPath"],
      ["lib", "attrsets", "showAttrPath"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "Turns a list of strings into a human-readable description of those\nstrings represented as an attribute path. The result of this function is\nnot intended to be machine-readable.\nCreate a new attribute set with `value` set at the nested attribute location specified in `attrPath`.\n\n# Example\n\n```nix\nshowAttrPath [ \"foo\" \"10\" \"bar\" ]\n=> \"foo.\\\"10\\\".bar\"\nshowAttrPath []\n=> \"<root attribute path>\"\n```\n\n# Type\n\n```\nshowAttrPath :: [String] -> String\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1156
        }
      }
    },
    "path": ["lib", "showAttrPath"]
  },
  {
    "aliases": [
      ["lib", "types", "setType"],
      ["lib", "setType"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 148
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 13,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 72
        }
      }
    },
    "path": ["lib", "setType"]
  },
  {
    "aliases": [
      ["lib", "setPrio"],
      ["lib", "meta", "setPrio"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 120
        }
      },
      "lambdaDocs": {
        "content": "Set the nix-env priority of the package.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 13,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 66
        }
      }
    },
    "path": ["lib", "setPrio"]
  },
  {
    "aliases": [
      ["lib", "setName"],
      ["lib", "meta", "setName"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 120
        }
      },
      "lambdaDocs": {
        "content": "Change the symbolic name of a package for presentation purposes\n(i.e., so that nix-env users can tell them apart).",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 13,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 35
        }
      }
    },
    "path": ["lib", "setName"]
  },
  {
    "aliases": [
      ["lib", "trivial", "setFunctionArgs"],
      ["lib", "setFunctionArgs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 73
        }
      },
      "lambdaDocs": {
        "content": "Add metadata about expected function arguments to a function.\nThe metadata should match the format given by\nbuiltins.functionArgs, i.e. a set from expected argument to a bool\nrepresenting whether that argument has a default or not.\nsetFunctionArgs : (a → b) → Map String Bool → (a → b)\n\nThis function is necessary because you can't dynamically create a\nfunction of the { a, b ? foo, ... }: format, but some facilities\nlike callPackage expect to be able to query expected arguments.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 576
        }
      }
    },
    "path": ["lib", "setFunctionArgs"]
  },
  {
    "aliases": [
      ["lib", "setDefaultModuleLocation"],
      ["lib", "modules", "setDefaultModuleLocation"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 128
        }
      },
      "lambdaDocs": {
        "content": "Wrap a module with a default location for reporting errors.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 30,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 451
        }
      }
    },
    "path": ["lib", "setDefaultModuleLocation"]
  },
  {
    "aliases": [
      ["lib", "setAttrMerge"],
      ["lib", "misc", "setAttrMerge"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 156
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 18,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 202
        }
      }
    },
    "path": ["lib", "setAttrMerge"]
  },
  {
    "aliases": [
      ["lib", "setAttrByPath"],
      ["lib", "attrsets", "setAttrByPath"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "Create a new attribute set with `value` set at the nested attribute location specified in `attrPath`.\n\n# Example\n\n```nix\nsetAttrByPath [\"a\" \"b\"] 3\n=> { a = { b = 3; }; }\n```\n\n# Type\n\n```\nsetAttrByPath :: [String] -> Any -> AttrSet\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 100
        }
      }
    },
    "path": ["lib", "setAttrByPath"]
  },
  {
    "aliases": [
      ["lib", "setAttr"],
      ["lib", "misc", "setAttr"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 156
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 13,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 197
        }
      }
    },
    "path": ["lib", "setAttr"]
  },
  {
    "aliases": [
      ["lib", "trivial", "seq"],
      ["lib", "seq"],
      ["builtins", "seq"],
      ["builtins", "seq"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 68
        }
      },
      "lambdaDocs": {
        "content": "Evaluate *e1*, then evaluate and return *e2*. This ensures that a\ncomputation is strict in the value of *e1*.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "seq"]
  },
  {
    "aliases": [
      ["lib", "scrubOptionValue"],
      ["lib", "options", "scrubOptionValue"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 140
        }
      },
      "lambdaDocs": {
        "content": "This function recursively removes all derivation attributes from\n`x` except for the `name` attribute.\n\nThis is to make the generation of `options.xml` much more\nefficient: the XML representation of derivations is very large\n(on the order of megabytes) and is not actually used by the\nmanual generator.\n\nThis function was made obsolete by renderOptionValue and is kept for\ncompatibility with out-of-tree code.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 22,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 361
        }
      }
    },
    "path": ["lib", "scrubOptionValue"]
  },
  {
    "aliases": [
      ["lib", "runTests"],
      ["lib", "debug", "runTests"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 152
        }
      },
      "lambdaDocs": {
        "content": "Evaluates a set of tests.\n\nA test is an attribute set `{expr, expected}`,\ndenoting an expression and its expected result.\n\nThe result is a `list` of __failed tests__, each represented as\n`{name, expected, result}`,\n\n- expected\n- What was passed as `expected`\n- result\n- The actual `result` of the test\n\nUsed for regression testing of the functions in lib; see\ntests.nix for more examples.\n\nImportant: Only attributes that start with `test` are executed.\n\n- If you want to run only a subset of the tests add the attribute `tests = [\"testName\"];`\n\n# Example\n\n```nix\nrunTests {\n  testAndOk = {\n    expr = lib.and true false;\n    expected = false;\n  };\n  testAndFail = {\n    expr = lib.and true false;\n    expected = true;\n  };\n}\n->\n[\n  {\n    name = \"testAndFail\";\n    expected = true;\n    result = false;\n  }\n]\n```\n\n# Type\n\n```\nrunTests :: {\ntests = [ String ];\n${testName} :: {\nexpr :: a;\nexpected :: a;\n};\n}\n->\n[\n{\nname :: String;\nexpected :: a;\nresult :: a;\n}\n]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/debug.nix",
          "line": 289
        }
      }
    },
    "path": ["lib", "runTests"]
  },
  {
    "aliases": [
      ["lib", "reverseList"],
      ["lib", "lists", "reverseList"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 92
        }
      },
      "lambdaDocs": {
        "content": "Reverse the order of the elements of a list.\n\n# Example\n\n```nix\nreverseList [ \"b\" \"o\" \"j\" ]\n=> [ \"j\" \"o\" \"b\" ]\n```\n\n# Type\n\n```\nreverseList :: [a] -> [a]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 656
        }
      }
    },
    "path": ["lib", "reverseList"]
  },
  {
    "aliases": [
      ["lib", "replicate"],
      ["lib", "lists", "replicate"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 92
        }
      },
      "lambdaDocs": {
        "content": "Return a list with `n` copies of an element.\n\n# Example\n\n```nix\nreplicate 3 \"a\"\n=> [ \"a\" \"a\" \"a\" ]\nreplicate 2 true\n=> [ true true ]\n```\n\n# Type\n\n```\nreplicate :: int -> a -> [a]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 15,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 531
        }
      }
    },
    "path": ["lib", "replicate"]
  },
  {
    "aliases": [
      ["lib", "strings", "replaceStrings"],
      ["lib", "strings", "replaceChars"],
      ["lib", "replaceStrings"],
      ["lib", "replaceChars"],
      ["builtins", "replaceStrings"],
      ["builtins", "replaceStrings"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 68
        }
      },
      "lambdaDocs": {
        "content": "Given string *s*, replace every occurrence of the strings in *from*\nwith the corresponding string in *to*.\n\nThe argument *to* is lazy, that is, it is only evaluated when its corresponding pattern in *from* is matched in the string *s*\n\nExample:\n\n```nix\nbuiltins.replaceStrings [\"oo\" \"a\"] [\"a\" \"i\"] \"foobar\"\n```\n\nevaluates to `\"fabir\"`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "replaceStrings"]
  },
  {
    "aliases": [
      ["lib", "strings", "replaceStrings"],
      ["lib", "strings", "replaceChars"],
      ["lib", "replaceStrings"],
      ["lib", "replaceChars"],
      ["builtins", "replaceStrings"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "Given string *s*, replace every occurrence of the strings in *from*\nwith the corresponding string in *to*.\n\nThe argument *to* is lazy, that is, it is only evaluated when its corresponding pattern in *from* is matched in the string *s*\n\nExample:\n\n```nix\nbuiltins.replaceStrings [\"oo\" \"a\"] [\"a\" \"i\"] \"foobar\"\n```\n\nevaluates to `\"fabir\"`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "replaceChars"]
  },
  {
    "aliases": [
      ["lib", "strings", "removeSuffix"],
      ["lib", "removeSuffix"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "Return a string without the specified suffix, if the suffix matches.\n\n# Example\n\n```nix\nremoveSuffix \"front\" \"homefront\"\n=> \"home\"\nremoveSuffix \"xxx\" \"homefront\"\n=> \"homefront\"\n```\n\n# Type\n\n```\nstring -> string -> string\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 939
        }
      }
    },
    "path": ["lib", "removeSuffix"]
  },
  {
    "aliases": [
      ["lib", "strings", "removePrefix"],
      ["lib", "removePrefix"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "Return a string without the specified prefix, if the prefix matches.\n\n# Example\n\n```nix\nremovePrefix \"foo.\" \"foo.bar.baz\"\n=> \"bar.baz\"\nremovePrefix \"xxx\" \"foo.bar.baz\"\n=> \"foo.bar.baz\"\n```\n\n# Type\n\n```\nstring -> string -> string\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 898
        }
      }
    },
    "path": ["lib", "removePrefix"]
  },
  {
    "aliases": [
      ["lib", "remove"],
      ["lib", "lists", "remove"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 92
        }
      },
      "lambdaDocs": {
        "content": "Remove elements equal to 'e' from a list.  Useful for buildInputs.\n\n# Example\n\n```nix\nremove 3 [ 1 3 4 3 ]\n=> [ 1 4 ]\n```\n\n# Type\n\n```\nremove :: a -> [a] -> [a]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 228
        }
      }
    },
    "path": ["lib", "remove"]
  },
  {
    "aliases": [
      ["lib", "recursiveUpdateUntil"],
      ["lib", "attrsets", "recursiveUpdateUntil"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1021
        }
      }
    },
    "path": ["lib", "recursiveUpdateUntil"]
  },
  {
    "aliases": [
      ["lib", "recursiveUpdate"],
      ["lib", "attrsets", "recursiveUpdate"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1068
        }
      }
    },
    "path": ["lib", "recursiveUpdate"]
  },
  {
    "aliases": [
      ["lib", "recurseIntoAttrs"],
      ["lib", "attrsets", "recurseIntoAttrs"],
      ["pkgs", "recurseIntoAttrs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "Make various Nix tools consider the contents of the resulting\nattribute set when looking for what to build, find, etc.\n\nThis function only affects a single attribute set; it does not\napply itself recursively for nested attribute sets.\n\n# Example\n\n```nix\n{ pkgs ? import <nixpkgs> {} }:\n{\n  myTools = pkgs.lib.recurseIntoAttrs {\n    inherit (pkgs) hello figlet;\n  };\n}\n```\n\n# Type\n\n```\nrecurseIntoAttrs :: AttrSet -> AttrSet\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1302
        }
      }
    },
    "path": ["lib", "recurseIntoAttrs"]
  },
  {
    "aliases": [
      ["lib", "strings", "readPathsFromFile"],
      ["lib", "readPathsFromFile"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 6,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1450
        }
      }
    },
    "path": ["lib", "readPathsFromFile"]
  },
  {
    "aliases": [
      ["lib", "trivial", "readFile"],
      ["lib", "strings", "readFile"],
      ["lib", "readFile"],
      ["builtins", "readFile"],
      ["builtins", "readFile"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 68
        }
      },
      "lambdaDocs": {
        "content": "Return the contents of the file *path* as a string.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "readFile"]
  },
  {
    "aliases": [
      ["lib", "range"],
      ["lib", "lists", "range"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 92
        }
      },
      "lambdaDocs": {
        "content": "Return a list of integers from `first` up to and including `last`.\n\n# Example\n\n```nix\nrange 2 4\n=> [ 2 3 4 ]\nrange 3 2\n=> [ ]\n```\n\n# Type\n\n```\nrange :: int -> int -> [int]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 505
        }
      }
    },
    "path": ["lib", "range"]
  },
  {
    "aliases": [
      ["lib", "pushDownProperties"],
      ["lib", "modules", "pushDownProperties"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 128
        }
      },
      "lambdaDocs": {
        "content": "Given a config set, expand mkMerge properties, and push down the\nother properties into the children.  The result is a list of\nconfig sets that do not have properties at top-level.  For\nexample,\n\nmkMerge [ { boot = set1; } (mkIf cond { boot = set2; services = set3; }) ]\n\nis transformed into\n\n[ { boot = set1; } { boot = mkIf cond set2; services = mkIf cond set3; } ].\n\nThis transform is the critical step that allows mkIf conditions\nto refer to the full configuration without creating an infinite\nrecursion.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 879
        }
      }
    },
    "path": ["lib", "pushDownProperties"]
  },
  {
    "aliases": [
      ["lib", "trivial", "pipe"],
      ["lib", "pipe"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 73
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 84
        }
      }
    },
    "path": ["lib", "pipe"]
  },
  {
    "aliases": [
      ["lib", "sources", "pathType"],
      ["lib", "pathType"],
      ["lib", "filesystem", "pathType"],
      ["builtins", "readFileType"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 30,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 123
        }
      },
      "lambdaDocs": {
        "content": "Determine the directory entry type of a filesystem node, being\none of \"directory\", \"regular\", \"symlink\", or \"unknown\".",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "pathType"]
  },
  {
    "aliases": [
      ["lib", "sources", "pathIsRegularFile"],
      ["lib", "pathIsRegularFile"],
      ["lib", "filesystem", "pathIsRegularFile"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 30,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 123
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/filesystem.nix",
          "line": 102
        }
      }
    },
    "path": ["lib", "pathIsRegularFile"]
  },
  {
    "aliases": [
      ["lib", "sources", "pathIsGitRepo"],
      ["lib", "pathIsGitRepo"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 124
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 19,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/sources.nix",
          "line": 173
        }
      }
    },
    "path": ["lib", "pathIsGitRepo"]
  },
  {
    "aliases": [
      ["lib", "sources", "pathIsDirectory"],
      ["lib", "pathIsDirectory"],
      ["lib", "filesystem", "pathIsDirectory"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 30,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 123
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/filesystem.nix",
          "line": 77
        }
      }
    },
    "path": ["lib", "pathIsDirectory"]
  },
  {
    "aliases": [
      ["lib", "sources", "pathHasContext"],
      ["lib", "pathHasContext"],
      ["builtins", "hasContext"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 124
        }
      },
      "lambdaDocs": {
        "content": "Return `true` if string *s* has a non-empty context. The\ncontext can be obtained with\n[`getContext`](#builtins-getContext).",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "pathHasContext"]
  },
  {
    "aliases": [
      ["lib", "trivial", "pathExists"],
      ["lib", "pathExists"],
      ["builtins", "pathExists"],
      ["builtins", "pathExists"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 68
        }
      },
      "lambdaDocs": {
        "content": "Return `true` if the path *path* exists at evaluation time, and\n`false` otherwise.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "pathExists"]
  },
  {
    "aliases": [["lib", "path", "splitRoot"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/path/default.nix",
          "line": 310
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/path/default.nix",
          "line": 312
        }
      }
    },
    "path": ["lib", "path", "splitRoot"]
  },
  {
    "aliases": [["lib", "path", "removePrefix"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/path/default.nix",
          "line": 245
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/path/default.nix",
          "line": 246
        }
      }
    },
    "path": ["lib", "path", "removePrefix"]
  },
  {
    "aliases": [["lib", "path", "hasPrefix"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/path/default.nix",
          "line": 200
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/path/default.nix",
          "line": 201
        }
      }
    },
    "path": ["lib", "path", "hasPrefix"]
  },
  {
    "aliases": [["lib", "path", "append"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/path/default.nix",
          "line": 166
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/path/default.nix",
          "line": 168
        }
      }
    },
    "path": ["lib", "path", "append"]
  },
  {
    "aliases": [
      ["lib", "partition"],
      ["lib", "lists", "partition"],
      ["builtins", "partition"],
      ["builtins", "partition"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 92
        }
      },
      "lambdaDocs": {
        "content": "Given a predicate function *pred*, this function returns an\nattrset containing a list named `right`, containing the elements\nin *list* for which *pred* returned `true`, and a list named\n`wrong`, containing the elements for which it returned\n`false`. For example,\n\n```nix\nbuiltins.partition (x: x > 10) [1 23 9 3 42]\n```\n\nevaluates to\n\n```nix\n{ right = [ 23 42 ]; wrong = [ 1 9 3 ]; }\n```",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "partition"]
  },
  {
    "aliases": [
      ["lib", "stringsWithDeps", "packEntry"],
      ["lib", "packEntry"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 35,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 114
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 15,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings-with-deps.nix",
          "line": 82
        }
      }
    },
    "path": ["lib", "packEntry"]
  },
  {
    "aliases": [
      ["lib", "overrideExisting"],
      ["lib", "attrsets", "overrideExisting"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "Override only the attributes that are already present in the old set\nuseful for deep-overriding.\n\n# Example\n\n```nix\noverrideExisting {} { a = 1; }\n=> {}\noverrideExisting { b = 2; } { a = 1; }\n=> { b = 2; }\noverrideExisting { a = 3; b = 2; } { a = 1; }\n=> { a = 1; b = 2; }\n```\n\n# Type\n\n```\noverrideExisting :: AttrSet -> AttrSet -> AttrSet\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1127
        }
      }
    },
    "path": ["lib", "overrideExisting"]
  },
  {
    "aliases": [
      ["lib", "overrideDerivation"],
      ["lib", "customisation", "overrideDerivation"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 33,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 116
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/customisation.nix",
          "line": 40
        }
      }
    },
    "path": ["lib", "overrideDerivation"]
  },
  {
    "aliases": [
      ["lib", "trivial", "or"],
      ["lib", "or"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 73
        }
      },
      "lambdaDocs": {
        "content": "boolean “or”",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 8,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 116
        }
      }
    },
    "path": ["lib", "or"]
  },
  {
    "aliases": [
      ["lib", "showOptionWithDefLocs"],
      ["lib", "options", "showOptionWithDefLocs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 461
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 461
        }
      }
    },
    "path": ["lib", "options", "showOptionWithDefLocs"]
  },
  {
    "aliases": [
      ["lib", "showOption"],
      ["lib", "options", "showOption"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 426
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 16,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 426
        }
      }
    },
    "path": ["lib", "options", "showOption"]
  },
  {
    "aliases": [
      ["lib", "showFiles"],
      ["lib", "options", "showFiles"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 440
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 15,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 440
        }
      }
    },
    "path": ["lib", "options", "showFiles"]
  },
  {
    "aliases": [["lib", "options", "showDefs"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 442
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 442
        }
      }
    },
    "path": ["lib", "options", "showDefs"]
  },
  {
    "aliases": [
      ["lib", "scrubOptionValue"],
      ["lib", "options", "scrubOptionValue"]
    ],
    "docs": {
      "attrDocs": {
        "content": "This function recursively removes all derivation attributes from\n`x` except for the `name` attribute.\n\nThis is to make the generation of `options.xml` much more\nefficient: the XML representation of derivations is very large\n(on the order of megabytes) and is not actually used by the\nmanual generator.\n\nThis function was made obsolete by renderOptionValue and is kept for\ncompatibility with out-of-tree code.",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 361
        }
      },
      "lambdaDocs": {
        "content": "This function recursively removes all derivation attributes from\n`x` except for the `name` attribute.\n\nThis is to make the generation of `options.xml` much more\nefficient: the XML representation of derivations is very large\n(on the order of megabytes) and is not actually used by the\nmanual generator.\n\nThis function was made obsolete by renderOptionValue and is kept for\ncompatibility with out-of-tree code.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 22,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 361
        }
      }
    },
    "path": ["lib", "options", "scrubOptionValue"]
  },
  {
    "aliases": [["lib", "options", "renderOptionValue"]],
    "docs": {
      "attrDocs": {
        "content": "Ensures that the given option value (default or example) is a `_type`d string\nby rendering Nix values to `literalExpression`s.",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 373
        }
      },
      "lambdaDocs": {
        "content": "Ensures that the given option value (default or example) is a `_type`d string\nby rendering Nix values to `literalExpression`s.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 373
        }
      }
    },
    "path": ["lib", "options", "renderOptionValue"]
  },
  {
    "aliases": [
      ["lib", "options", "optionAttrSetToDocList'"],
      ["lib", "optionAttrSetToDocList'"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 308
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 29,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 308
        }
      }
    },
    "path": ["lib", "options", "optionAttrSetToDocList'"]
  },
  {
    "aliases": [
      ["lib", "options", "optionAttrSetToDocList"],
      ["lib", "optionAttrSetToDocList"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 306
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 32,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 308
        }
      }
    },
    "path": ["lib", "options", "optionAttrSetToDocList"]
  },
  {
    "aliases": [
      ["lib", "options", "mkSinkUndeclaredOptions"],
      ["lib", "mkSinkUndeclaredOptions"]
    ],
    "docs": {
      "attrDocs": {
        "content": "This option accepts anything, but it does not produce any result.\n\nThis is useful for sharing a module across different module sets\nwithout having to implement similar features as long as the\nvalues of the options are not accessed.",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 221
        }
      },
      "lambdaDocs": {
        "content": "This option accepts anything, but it does not produce any result.\n\nThis is useful for sharing a module across different module sets\nwithout having to implement similar features as long as the\nvalues of the options are not accessed.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 29,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 221
        }
      }
    },
    "path": ["lib", "options", "mkSinkUndeclaredOptions"]
  },
  {
    "aliases": [
      ["lib", "options", "mkPackageOptionMD"],
      ["lib", "options", "mkPackageOption"],
      ["lib", "mkPackageOptionMD"],
      ["lib", "mkPackageOption"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Alias of mkPackageOption. Previously used to create options with markdown\ndocumentation, which is no longer required.",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 212
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 174
        }
      }
    },
    "path": ["lib", "options", "mkPackageOptionMD"]
  },
  {
    "aliases": [
      ["lib", "options", "mkPackageOptionMD"],
      ["lib", "options", "mkPackageOption"],
      ["lib", "mkPackageOptionMD"],
      ["lib", "mkPackageOption"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 172
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 174
        }
      }
    },
    "path": ["lib", "options", "mkPackageOption"]
  },
  {
    "aliases": [
      ["lib", "options", "mkOption"],
      ["lib", "mkOption"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 78
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 79
        }
      }
    },
    "path": ["lib", "options", "mkOption"]
  },
  {
    "aliases": [
      ["lib", "options", "mkEnableOption"],
      ["lib", "mkEnableOption"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Creates an Option attribute set for a boolean value option i.e an\noption to be toggled on or off:\n\n# Example\n\n```nix\nmkEnableOption \"foo\"\n=> { _type = \"option\"; default = false; description = \"Whether to enable foo.\"; example = true; type = { ... }; }\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 114
        }
      },
      "lambdaDocs": {
        "content": "Creates an Option attribute set for a boolean value option i.e an\noption to be toggled on or off:\n\n# Example\n\n```nix\nmkEnableOption \"foo\"\n=> { _type = \"option\"; default = false; description = \"Whether to enable foo.\"; example = true; type = { ... }; }\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 116
        }
      }
    },
    "path": ["lib", "options", "mkEnableOption"]
  },
  {
    "aliases": [
      ["lib", "options", "mergeUniqueOption"],
      ["lib", "mergeUniqueOption"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 247
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 247
        }
      }
    },
    "path": ["lib", "options", "mergeUniqueOption"]
  },
  {
    "aliases": [
      ["lib", "options", "mergeOneOption"],
      ["lib", "mergeOneOption"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 245
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 36,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 247
        }
      }
    },
    "path": ["lib", "options", "mergeOneOption"]
  },
  {
    "aliases": [
      ["lib", "options", "mergeEqualOption"],
      ["lib", "mergeEqualOption"]
    ],
    "docs": {
      "attrDocs": {
        "content": "\"Merge\" option definitions by checking that they all have the same value.",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 256
        }
      },
      "lambdaDocs": {
        "content": "\"Merge\" option definitions by checking that they all have the same value.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 22,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 256
        }
      }
    },
    "path": ["lib", "options", "mergeEqualOption"]
  },
  {
    "aliases": [
      ["lib", "options", "mergeDefaultOption"],
      ["lib", "mergeDefaultOption"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 234
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 234
        }
      }
    },
    "path": ["lib", "options", "mergeDefaultOption"]
  },
  {
    "aliases": [
      ["lib", "trivial", "id"],
      ["lib", "options", "mdDoc"],
      ["lib", "modules", "mkFixStrictness"],
      ["lib", "mkFixStrictness"],
      ["lib", "mdDoc"],
      ["lib", "id"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Transition marker for documentation that's already migrated to markdown\nsyntax. This is a no-op and no longer needed.",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 397
        }
      },
      "lambdaDocs": {
        "content": "The identity function\nFor when you need a function that does “nothing”.\n\n# Type\n\n```\nid :: a -> a\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 19
        }
      }
    },
    "path": ["lib", "options", "mdDoc"]
  },
  {
    "aliases": [
      ["lib", "options", "literalMD"],
      ["lib", "literalMD"]
    ],
    "docs": {
      "attrDocs": {
        "content": "For use in the `defaultText` and `example` option attributes. Causes the\ngiven MD text to be inserted verbatim in the documentation, for when\na `literalExpression` would be too hard to read.",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 404
        }
      },
      "lambdaDocs": {
        "content": "For use in the `defaultText` and `example` option attributes. Causes the\ngiven MD text to be inserted verbatim in the documentation, for when\na `literalExpression` would be too hard to read.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 15,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 404
        }
      }
    },
    "path": ["lib", "options", "literalMD"]
  },
  {
    "aliases": [
      ["lib", "options", "literalExpression"],
      ["lib", "options", "literalExample"],
      ["lib", "literalExpression"],
      ["lib", "literalExample"]
    ],
    "docs": {
      "attrDocs": {
        "content": "For use in the `defaultText` and `example` option attributes. Causes the\ngiven string to be rendered verbatim in the documentation as Nix code. This\nis necessary for complex values, e.g. functions, or values that depend on\nother values or packages.",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 387
        }
      },
      "lambdaDocs": {
        "content": "For use in the `defaultText` and `example` option attributes. Causes the\ngiven string to be rendered verbatim in the documentation as Nix code. This\nis necessary for complex values, e.g. functions, or values that depend on\nother values or packages.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 387
        }
      }
    },
    "path": ["lib", "options", "literalExpression"]
  },
  {
    "aliases": [
      ["lib", "options", "literalExpression"],
      ["lib", "options", "literalExample"],
      ["lib", "literalExpression"],
      ["lib", "literalExample"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 391
        }
      },
      "lambdaDocs": {
        "content": "For use in the `defaultText` and `example` option attributes. Causes the\ngiven string to be rendered verbatim in the documentation as Nix code. This\nis necessary for complex values, e.g. functions, or values that depend on\nother values or packages.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 387
        }
      }
    },
    "path": ["lib", "options", "literalExample"]
  },
  {
    "aliases": [
      ["lib", "types", "isOptionType"],
      ["lib", "options", "isOption"],
      ["lib", "isOptionType"],
      ["lib", "isOption"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 64
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 18,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 70
        }
      }
    },
    "path": ["lib", "options", "isOption"]
  },
  {
    "aliases": [
      ["lib", "options", "getValues"],
      ["lib", "options", "getFiles"],
      ["lib", "getValues"],
      ["lib", "getFiles"],
      ["pkgs", "copyPathsToStore"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 284
        }
      },
      "lambdaDocs": {
        "content": "Apply the function *f* to each element in the list *list*. For\nexample,\n\n```nix\nmap (x: \"foo\" + x) [ \"bar\" \"bla\" \"abc\" ]\n```\n\nevaluates to `[ \"foobar\" \"foobla\" \"fooabc\" ]`.",
        "countApplied": 1,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "options", "getValues"]
  },
  {
    "aliases": [
      ["lib", "options", "getValues"],
      ["lib", "options", "getFiles"],
      ["lib", "getValues"],
      ["lib", "getFiles"],
      ["pkgs", "copyPathsToStore"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 302
        }
      },
      "lambdaDocs": {
        "content": "Apply the function *f* to each element in the list *list*. For\nexample,\n\n```nix\nmap (x: \"foo\" + x) [ \"bar\" \"bla\" \"abc\" ]\n```\n\nevaluates to `[ \"foobar\" \"foobla\" \"fooabc\" ]`.",
        "countApplied": 1,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "options", "getFiles"]
  },
  {
    "aliases": [
      ["lib", "optionals"],
      ["lib", "lists", "optionals"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 92
        }
      },
      "lambdaDocs": {
        "content": "Return a list or an empty list, depending on a boolean value.\n\n# Example\n\n```nix\noptionals true [ 2 3 ]\n=> [ 2 3 ]\noptionals false [ 2 3 ]\n=> [ ]\n```\n\n# Type\n\n```\noptionals :: bool -> [a] -> [a]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 464
        }
      }
    },
    "path": ["lib", "optionals"]
  },
  {
    "aliases": [
      ["lib", "strings", "optionalString"],
      ["lib", "optionalString"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "Depending on the boolean `cond', return either the given string\nor the empty string. Useful to concatenate against a bigger string.\n\n# Example\n\n```nix\noptionalString true \"some-string\"\n=> \"some-string\"\noptionalString false \"some-string\"\n=> \"\"\n```\n\n# Type\n\n```\noptionalString :: bool -> string -> string\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 347
        }
      }
    },
    "path": ["lib", "optionalString"]
  },
  {
    "aliases": [
      ["lib", "optionalAttrs"],
      ["lib", "attrsets", "optionalAttrs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "If `cond` is true, return the attribute set `as`,\notherwise an empty attribute set.\n\n# Example\n\n```nix\noptionalAttrs (true) { my = \"set\"; }\n=> { my = \"set\"; }\noptionalAttrs (false) { my = \"set\"; }\n=> { }\n```\n\n# Type\n\n```\noptionalAttrs :: Bool -> AttrSet -> AttrSet\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 854
        }
      }
    },
    "path": ["lib", "optionalAttrs"]
  },
  {
    "aliases": [
      ["lib", "optional"],
      ["lib", "lists", "optional"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 92
        }
      },
      "lambdaDocs": {
        "content": "Return a singleton list or an empty list, depending on a boolean\nvalue.  Useful when building lists with optional elements\n(e.g. `++ optional (system == \"i686-linux\") firefox`).\n\n# Example\n\n```nix\noptional true \"foo\"\n=> [ \"foo\" ]\noptional false \"foo\"\n=> [ ]\n```\n\n# Type\n\n```\noptional :: bool -> a -> [a]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 442
        }
      }
    },
    "path": ["lib", "optional"]
  },
  {
    "aliases": [
      ["lib", "options", "optionAttrSetToDocList'"],
      ["lib", "optionAttrSetToDocList'"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 140
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 29,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 308
        }
      }
    },
    "path": ["lib", "optionAttrSetToDocList'"]
  },
  {
    "aliases": [
      ["lib", "options", "optionAttrSetToDocList"],
      ["lib", "optionAttrSetToDocList"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 140
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 32,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 308
        }
      }
    },
    "path": ["lib", "optionAttrSetToDocList"]
  },
  {
    "aliases": [
      ["lib", "nvs"],
      ["lib", "misc", "nvs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 156
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 9,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 195
        }
      }
    },
    "path": ["lib", "nvs"]
  },
  {
    "aliases": [
      ["lib", "stringsWithDeps", "noDepEntry"],
      ["lib", "noDepEntry"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 35,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 114
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 16,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings-with-deps.nix",
          "line": 80
        }
      }
    },
    "path": ["lib", "noDepEntry"]
  },
  {
    "aliases": [
      ["lib", "nixType"],
      ["lib", "misc", "nixType"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 156
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 13,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 282
        }
      }
    },
    "path": ["lib", "nixType"]
  },
  {
    "aliases": [
      ["lib", "naturalSort"],
      ["lib", "lists", "naturalSort"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 92
        }
      },
      "lambdaDocs": {
        "content": "Sort list using \"Natural sorting\".\nNumeric portions of strings are sorted in numeric order.\n\n# Example\n\n```nix\nnaturalSort [\"disk11\" \"disk8\" \"disk100\" \"disk9\"]\n=> [\"disk8\" \"disk9\" \"disk11\" \"disk100\"]\nnaturalSort [\"10.46.133.149\" \"10.5.16.62\" \"10.54.16.25\"]\n=> [\"10.5.16.62\" \"10.46.133.149\" \"10.54.16.25\"]\nnaturalSort [\"v0.2\" \"v0.15\" \"v0.0.9\"]\n=> [ \"v0.0.9\" \"v0.2\" \"v0.15\" ]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 814
        }
      }
    },
    "path": ["lib", "naturalSort"]
  },
  {
    "aliases": [
      ["lib", "nameValuePair"],
      ["lib", "attrsets", "nameValuePair"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "Utility function that creates a `{name, value}` pair as expected by `builtins.listToAttrs`.\n\n# Example\n\n```nix\nnameValuePair \"some\" 6\n=> { name = \"some\"; value = 6; }\n```\n\n# Type\n\n```\nnameValuePair :: String -> Any -> { name :: String; value :: Any; }\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 603
        }
      }
    },
    "path": ["lib", "nameValuePair"]
  },
  {
    "aliases": [
      ["lib", "strings", "nameFromURL"],
      ["lib", "nameFromURL"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1045
        }
      }
    },
    "path": ["lib", "nameFromURL"]
  },
  {
    "aliases": [
      ["lib", "mutuallyExclusive"],
      ["lib", "lists", "mutuallyExclusive"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 92
        }
      },
      "lambdaDocs": {
        "content": "Test if two lists have no common element.\nIt should be slightly more efficient than (intersectLists a b == [])",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 1091
        }
      }
    },
    "path": ["lib", "mutuallyExclusive"]
  },
  {
    "aliases": [
      ["lib", "unifyModuleSyntax"],
      ["lib", "modules", "unifyModuleSyntax"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Massage a module into canonical form, that is, a set consisting\nof ‘options’, ‘config’ and ‘imports’ attributes.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 458
        }
      }
    },
    "path": ["lib", "modules", "unifyModuleSyntax"]
  },
  {
    "aliases": [
      ["lib", "sortProperties"],
      ["lib", "modules", "sortProperties"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1353
        }
      },
      "lambdaDocs": {
        "content": "Sort a list of properties.  The sort priority of a property is\ndefaultOrderPriority by default, but can be overridden by wrapping the property\nusing mkOrder.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 20,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 951
        }
      }
    },
    "path": ["lib", "modules", "sortProperties"]
  },
  {
    "aliases": [
      ["lib", "setDefaultModuleLocation"],
      ["lib", "modules", "setDefaultModuleLocation"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1353
        }
      },
      "lambdaDocs": {
        "content": "Wrap a module with a default location for reporting errors.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 30,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 451
        }
      }
    },
    "path": ["lib", "modules", "setDefaultModuleLocation"]
  },
  {
    "aliases": [
      ["lib", "pushDownProperties"],
      ["lib", "modules", "pushDownProperties"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Given a config set, expand mkMerge properties, and push down the\nother properties into the children.  The result is a list of\nconfig sets that do not have properties at top-level.  For\nexample,\n\nmkMerge [ { boot = set1; } (mkIf cond { boot = set2; services = set3; }) ]\n\nis transformed into\n\n[ { boot = set1; } { boot = mkIf cond set2; services = mkIf cond set3; } ].\n\nThis transform is the critical step that allows mkIf conditions\nto refer to the full configuration without creating an infinite\nrecursion.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 879
        }
      }
    },
    "path": ["lib", "modules", "pushDownProperties"]
  },
  {
    "aliases": [
      ["lib", "modules", "mkVMOverride"],
      ["lib", "modules", "mkOptionDefault"],
      ["lib", "modules", "mkImageMediaOverride"],
      ["lib", "modules", "mkForce"],
      ["lib", "modules", "mkDefault"],
      ["lib", "mkVMOverride"],
      ["lib", "mkOptionDefault"],
      ["lib", "mkImageMediaOverride"],
      ["lib", "mkForce"],
      ["lib", "mkDefault"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1353
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 26,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1026
        }
      }
    },
    "path": ["lib", "modules", "mkVMOverride"]
  },
  {
    "aliases": [
      ["lib", "modules", "mkRenamedOptionModuleWith"],
      ["lib", "mkRenamedOptionModuleWith"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1353
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 31,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1143
        }
      }
    },
    "path": ["lib", "modules", "mkRenamedOptionModuleWith"]
  },
  {
    "aliases": [
      ["lib", "modules", "mkRenamedOptionModule"],
      ["lib", "mkRenamedOptionModule"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1353
        }
      },
      "lambdaDocs": {
        "content": "Return a module that causes a warning to be shown if the\nspecified \"from\" option is defined; the defined value is however\nforwarded to the \"to\" option. This can be used to rename options\nwhile providing backward compatibility. For example,\n\nmkRenamedOptionModule [ \"boot\" \"copyKernels\" ] [ \"boot\" \"loader\" \"grub\" \"copyKernels\" ]\n\nforwards any definitions of boot.copyKernels to\nboot.loader.grub.copyKernels while printing a warning.\n\nThis also copies over the priority from the aliased option to the\nnon-aliased option.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1136
        }
      }
    },
    "path": ["lib", "modules", "mkRenamedOptionModule"]
  },
  {
    "aliases": [
      ["lib", "modules", "mkRemovedOptionModule"],
      ["lib", "mkRemovedOptionModule"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1353
        }
      },
      "lambdaDocs": {
        "content": "Return a module that causes a warning to be shown if the\nspecified option is defined. For example,\n\nmkRemovedOptionModule [ \"boot\" \"loader\" \"grub\" \"bootDevice\" ] \"<replacement instructions>\"\n\ncauses a assertion if the user defines boot.loader.grub.bootDevice.\n\nreplacementInstructions is a string that provides instructions on\nhow to achieve the same functionality without the removed option,\nor alternatively a reasoning why the functionality is not needed.\nreplacementInstructions SHOULD be provided!",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1106
        }
      }
    },
    "path": ["lib", "modules", "mkRemovedOptionModule"]
  },
  {
    "aliases": [
      ["lib", "modules", "mkOverride"],
      ["lib", "mkOverride"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1353
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 16,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1026
        }
      }
    },
    "path": ["lib", "modules", "mkOverride"]
  },
  {
    "aliases": [
      ["lib", "modules", "mkOrder"],
      ["lib", "mkOrder"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1353
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 13,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1042
        }
      }
    },
    "path": ["lib", "modules", "mkOrder"]
  },
  {
    "aliases": [
      ["lib", "modules", "mkVMOverride"],
      ["lib", "modules", "mkOptionDefault"],
      ["lib", "modules", "mkImageMediaOverride"],
      ["lib", "modules", "mkForce"],
      ["lib", "modules", "mkDefault"],
      ["lib", "mkVMOverride"],
      ["lib", "mkOptionDefault"],
      ["lib", "mkImageMediaOverride"],
      ["lib", "mkForce"],
      ["lib", "mkDefault"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1353
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 26,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1026
        }
      }
    },
    "path": ["lib", "modules", "mkOptionDefault"]
  },
  {
    "aliases": [
      ["lib", "modules", "mkMergedOptionModule"],
      ["lib", "mkMergedOptionModule"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1353
        }
      },
      "lambdaDocs": {
        "content": "Return a module that causes a warning to be shown if any of the \"from\"\noption is defined; the defined values can be used in the \"mergeFn\" to set\nthe \"to\" value.\nThis function can be used to merge multiple options into one that has a\ndifferent type.\n\n\"mergeFn\" takes the module \"config\" as a parameter and must return a value\nof \"to\" option type.\n\nmkMergedOptionModule\n[ [ \"a\" \"b\" \"c\" ]\n[ \"d\" \"e\" \"f\" ] ]\n[ \"x\" \"y\" \"z\" ]\n(config:\nlet value = p: getAttrFromPath p config;\nin\nif      (value [ \"a\" \"b\" \"c\" ]) == true then \"foo\"\nelse if (value [ \"d\" \"e\" \"f\" ]) == true then \"bar\"\nelse \"baz\")\n\n- options.a.b.c is a removed boolean option\n- options.d.e.f is a removed boolean option\n- options.x.y.z is a new str option that combines a.b.c and d.e.f\nfunctionality\n\nThis show a warning if any a.b.c or d.e.f is set, and set the value of\nx.y.z to the result of the merge function",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 26,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1196
        }
      }
    },
    "path": ["lib", "modules", "mkMergedOptionModule"]
  },
  {
    "aliases": [
      ["lib", "modules", "mkMerge"],
      ["lib", "mkMerge"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1353
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 13,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1021
        }
      }
    },
    "path": ["lib", "modules", "mkMerge"]
  },
  {
    "aliases": [
      ["lib", "modules", "mkVMOverride"],
      ["lib", "modules", "mkOptionDefault"],
      ["lib", "modules", "mkImageMediaOverride"],
      ["lib", "modules", "mkForce"],
      ["lib", "modules", "mkDefault"],
      ["lib", "mkVMOverride"],
      ["lib", "mkOptionDefault"],
      ["lib", "mkImageMediaOverride"],
      ["lib", "mkForce"],
      ["lib", "mkDefault"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1353
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 26,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1026
        }
      }
    },
    "path": ["lib", "modules", "mkImageMediaOverride"]
  },
  {
    "aliases": [
      ["lib", "modules", "mkIf"],
      ["lib", "mkIf"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1353
        }
      },
      "lambdaDocs": {
        "content": "Properties.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1011
        }
      }
    },
    "path": ["lib", "modules", "mkIf"]
  },
  {
    "aliases": [
      ["lib", "modules", "mkVMOverride"],
      ["lib", "modules", "mkOptionDefault"],
      ["lib", "modules", "mkImageMediaOverride"],
      ["lib", "modules", "mkForce"],
      ["lib", "modules", "mkDefault"],
      ["lib", "mkVMOverride"],
      ["lib", "mkOptionDefault"],
      ["lib", "mkImageMediaOverride"],
      ["lib", "mkForce"],
      ["lib", "mkDefault"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1353
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 26,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1026
        }
      }
    },
    "path": ["lib", "modules", "mkForce"]
  },
  {
    "aliases": [
      ["lib", "trivial", "id"],
      ["lib", "options", "mdDoc"],
      ["lib", "modules", "mkFixStrictness"],
      ["lib", "mkFixStrictness"],
      ["lib", "mdDoc"],
      ["lib", "id"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1353
        }
      },
      "lambdaDocs": {
        "content": "The identity function\nFor when you need a function that does “nothing”.\n\n# Type\n\n```\nid :: a -> a\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 19
        }
      }
    },
    "path": ["lib", "modules", "mkFixStrictness"]
  },
  {
    "aliases": [
      ["lib", "modules", "mkDerivedConfig"],
      ["lib", "mkDerivedConfig"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1353
        }
      },
      "lambdaDocs": {
        "content": "mkDerivedConfig : Option a -> (a -> Definition b) -> Definition b\n\nCreate config definitions with the same priority as the definition of another option.\nThis should be used for option definitions where one option sets the value of another as a convenience.\nFor instance a config file could be set with a `text` or `source` option, where text translates to a `source`\nvalue using `mkDerivedConfig options.text (pkgs.writeText \"filename.conf\")`.\n\nIt takes care of setting the right priority using `mkOverride`.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1280
        }
      }
    },
    "path": ["lib", "modules", "mkDerivedConfig"]
  },
  {
    "aliases": [
      ["lib", "modules", "mkVMOverride"],
      ["lib", "modules", "mkOptionDefault"],
      ["lib", "modules", "mkImageMediaOverride"],
      ["lib", "modules", "mkForce"],
      ["lib", "modules", "mkDefault"],
      ["lib", "mkVMOverride"],
      ["lib", "mkOptionDefault"],
      ["lib", "mkImageMediaOverride"],
      ["lib", "mkForce"],
      ["lib", "mkDefault"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1353
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 26,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1026
        }
      }
    },
    "path": ["lib", "modules", "mkDefault"]
  },
  {
    "aliases": [
      ["lib", "modules", "mkChangedOptionModule"],
      ["lib", "mkChangedOptionModule"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1353
        }
      },
      "lambdaDocs": {
        "content": "Single \"from\" version of mkMergedOptionModule.\nReturn a module that causes a warning to be shown if the \"from\" option is\ndefined; the defined value can be used in the \"mergeFn\" to set the \"to\"\nvalue.\nThis function can be used to change an option into another that has a\ndifferent type.\n\n\"mergeFn\" takes the module \"config\" as a parameter and must return a value of\n\"to\" option type.\n\nmkChangedOptionModule [ \"a\" \"b\" \"c\" ] [ \"x\" \"y\" \"z\" ]\n(config:\nlet value = getAttrFromPath [ \"a\" \"b\" \"c\" ] config;\nin\nif   value > 100 then \"high\"\nelse \"normal\")\n\n- options.a.b.c is a removed int option\n- options.x.y.z is a new str option that supersedes a.b.c\n\nThis show a warning if a.b.c is set, and set the value of x.y.z to the\nresult of the change function",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1244
        }
      }
    },
    "path": ["lib", "modules", "mkChangedOptionModule"]
  },
  {
    "aliases": [
      ["lib", "modules", "mkBefore"],
      ["lib", "modules", "mkAfter"],
      ["lib", "mkBefore"],
      ["lib", "mkAfter"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1353
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1042
        }
      }
    },
    "path": ["lib", "modules", "mkBefore"]
  },
  {
    "aliases": [
      ["lib", "modules", "mkAssert"],
      ["lib", "mkAssert"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1353
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1016
        }
      }
    },
    "path": ["lib", "modules", "mkAssert"]
  },
  {
    "aliases": [
      ["lib", "modules", "mkAliasOptionModuleMD"],
      ["lib", "modules", "mkAliasOptionModule"],
      ["lib", "mkAliasOptionModuleMD"],
      ["lib", "mkAliasOptionModule"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1353
        }
      },
      "lambdaDocs": {
        "content": "Like ‘mkRenamedOptionModule’, but doesn't show a warning.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1250
        }
      }
    },
    "path": ["lib", "modules", "mkAliasOptionModuleMD"]
  },
  {
    "aliases": [
      ["lib", "modules", "mkAliasOptionModuleMD"],
      ["lib", "modules", "mkAliasOptionModule"],
      ["lib", "mkAliasOptionModuleMD"],
      ["lib", "mkAliasOptionModule"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1353
        }
      },
      "lambdaDocs": {
        "content": "Like ‘mkRenamedOptionModule’, but doesn't show a warning.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1250
        }
      }
    },
    "path": ["lib", "modules", "mkAliasOptionModule"]
  },
  {
    "aliases": [["lib", "modules", "mkAliasIfDef"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1353
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 18,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1084
        }
      }
    },
    "path": ["lib", "modules", "mkAliasIfDef"]
  },
  {
    "aliases": [
      ["lib", "modules", "mkAliasDefinitions"],
      ["lib", "mkAliasDefinitions"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1353
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 37,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1071
        }
      }
    },
    "path": ["lib", "modules", "mkAliasDefinitions"]
  },
  {
    "aliases": [["lib", "modules", "mkAliasAndWrapDefsWithPriority"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1353
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 36,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1078
        }
      }
    },
    "path": ["lib", "modules", "mkAliasAndWrapDefsWithPriority"]
  },
  {
    "aliases": [
      ["lib", "modules", "mkAliasAndWrapDefinitions"],
      ["lib", "mkAliasAndWrapDefinitions"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1353
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 31,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1071
        }
      }
    },
    "path": ["lib", "modules", "mkAliasAndWrapDefinitions"]
  },
  {
    "aliases": [
      ["lib", "modules", "mkBefore"],
      ["lib", "modules", "mkAfter"],
      ["lib", "mkBefore"],
      ["lib", "mkAfter"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1353
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1042
        }
      }
    },
    "path": ["lib", "modules", "mkAfter"]
  },
  {
    "aliases": [
      ["lib", "modules", "mergeOptionDecls"],
      ["lib", "mergeOptionDecls"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1353
        }
      },
      "lambdaDocs": {
        "content": "Merge multiple option declarations into a single declaration.  In\ngeneral, there should be only one declaration of each option.\nThe exception is the ‘options’ attribute, which specifies\nsub-options.  These can be specified multiple times to allow one\nmodule to add sub-options to an option declared somewhere else\n(e.g. multiple modules define sub-options for ‘fileSystems’).\n\n'loc' is the list of attribute names where the option is located.\n\n'opts' is a list of modules.  Each module has an options attribute which\ncorrespond to the definition of 'loc' in 'opt.file'.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 4,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 748
        }
      }
    },
    "path": ["lib", "modules", "mergeOptionDecls"]
  },
  {
    "aliases": [
      ["lib", "modules", "mergeModules'"],
      ["lib", "mergeModules'"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 19,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 547
        }
      }
    },
    "path": ["lib", "modules", "mergeModules'"]
  },
  {
    "aliases": [
      ["lib", "modules", "mergeModules"],
      ["lib", "mergeModules"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Merge a list of modules.  This will recurse over the option\ndeclarations in all modules, combining them into a single set.\nAt the same time, for each option declaration, it will merge the\ncorresponding option definitions in all machines, returning them\nin the ‘value’ attribute of each option.\n\nThis returns a set like\n{\n# A recursive set of options along with their final values\nmatchedOptions = {\nfoo = { _type = \"option\"; value = \"option value of foo\"; ... };\nbar.baz = { _type = \"option\"; value = \"option value of bar.baz\"; ... };\n...\n};\n# A list of definitions that weren't matched by any option\nunmatchedDefns = [\n{ file = \"file.nix\"; prefix = [ \"qux\" ]; value = \"qux\"; }\n...\n];\n}",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 18,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 543
        }
      }
    },
    "path": ["lib", "modules", "mergeModules"]
  },
  {
    "aliases": [
      ["lib", "modules", "mergeDefinitions"],
      ["lib", "mergeDefinitions"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1353
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 22,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 822
        }
      }
    },
    "path": ["lib", "modules", "mergeDefinitions"]
  },
  {
    "aliases": [["lib", "modules", "mergeAttrDefinitionsWithPrio"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1353
        }
      },
      "lambdaDocs": {
        "content": "Merge an option's definitions in a way that preserves the priority of the\nindividual attributes in the option value.\n\nThis does not account for all option semantics, such as readOnly.\n\n# Type\n\n```\noption -> attrsOf { highestPrio, value }\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 34,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 982
        }
      }
    },
    "path": ["lib", "modules", "mergeAttrDefinitionsWithPrio"]
  },
  {
    "aliases": [["lib", "modules", "importTOML"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1353
        }
      },
      "lambdaDocs": {
        "content": "Use this function to import a TOML file as NixOS configuration.\n\nmodules.importTOML :: path -> attrs",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 16,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1327
        }
      }
    },
    "path": ["lib", "modules", "importTOML"]
  },
  {
    "aliases": [["lib", "modules", "importJSON"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1353
        }
      },
      "lambdaDocs": {
        "content": "Use this function to import a JSON file as NixOS configuration.\n\nmodules.importJSON :: path -> attrs",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 16,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1317
        }
      }
    },
    "path": ["lib", "modules", "importJSON"]
  },
  {
    "aliases": [
      ["lib", "modules", "fixupOptionType"],
      ["lib", "fixupOptionType"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1353
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 964
        }
      }
    },
    "path": ["lib", "modules", "fixupOptionType"]
  },
  {
    "aliases": [
      ["lib", "modules", "fixMergeModules"],
      ["lib", "fixMergeModules"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1353
        }
      },
      "lambdaDocs": {
        "content": "Compatibility.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1090
        }
      }
    },
    "path": ["lib", "modules", "fixMergeModules"]
  },
  {
    "aliases": [["lib", "modules", "filterOverrides'"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1353
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 22,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 936
        }
      }
    },
    "path": ["lib", "modules", "filterOverrides'"]
  },
  {
    "aliases": [
      ["lib", "modules", "filterOverrides"],
      ["lib", "filterOverrides"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1353
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 934
        }
      }
    },
    "path": ["lib", "modules", "filterOverrides"]
  },
  {
    "aliases": [
      ["lib", "modules", "evalOptionValue"],
      ["lib", "evalOptionValue"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Merge all the definitions of an option to produce the final\nconfig value.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 782
        }
      }
    },
    "path": ["lib", "modules", "evalOptionValue"]
  },
  {
    "aliases": [
      ["lib", "modules", "evalModules"],
      ["lib", "evalModules"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1353
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 75
        }
      }
    },
    "path": ["lib", "modules", "evalModules"]
  },
  {
    "aliases": [
      ["lib", "modules", "doRename"],
      ["lib", "doRename"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1353
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1285
        }
      }
    },
    "path": ["lib", "modules", "doRename"]
  },
  {
    "aliases": [
      ["lib", "modules", "dischargeProperties"],
      ["lib", "dischargeProperties"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Given a config value, expand mkMerge properties, and discharge\nany mkIf conditions.  That is, this is the place where mkIf\nconditions are actually evaluated.  The result is a list of\nconfig values.  For example, ‘mkIf false x’ yields ‘[]’,\n‘mkIf true x’ yields ‘[x]’, and\n\nmkMerge [ 1 (mkIf true 2) (mkIf true (mkIf false 3)) ]\n\nyields ‘[ 1 2 ]’.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 900
        }
      }
    },
    "path": ["lib", "modules", "dischargeProperties"]
  },
  {
    "aliases": [["lib", "modules", "collectModules"]],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 8,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 445
        }
      }
    },
    "path": ["lib", "modules", "collectModules"]
  },
  {
    "aliases": [
      ["lib", "modules", "applyModuleArgsIfFunction"],
      ["lib", "applyModuleArgsIfFunction"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 31,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 492
        }
      }
    },
    "path": ["lib", "modules", "applyModuleArgsIfFunction"]
  },
  {
    "aliases": [
      ["lib", "modifySumArgs"],
      ["lib", "misc", "modifySumArgs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 156
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 19,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 140
        }
      }
    },
    "path": ["lib", "modifySumArgs"]
  },
  {
    "aliases": [
      ["lib", "trivial", "mod"],
      ["lib", "mod"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 73
        }
      },
      "lambdaDocs": {
        "content": "Integer modulus\n\n# Example\n\n```nix\nmod 11 10\n=> 1\nmod 1 10\n=> 1\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 9,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 355
        }
      }
    },
    "path": ["lib", "mod"]
  },
  {
    "aliases": [
      ["lib", "modules", "mkVMOverride"],
      ["lib", "modules", "mkOptionDefault"],
      ["lib", "modules", "mkImageMediaOverride"],
      ["lib", "modules", "mkForce"],
      ["lib", "modules", "mkDefault"],
      ["lib", "mkVMOverride"],
      ["lib", "mkOptionDefault"],
      ["lib", "mkImageMediaOverride"],
      ["lib", "mkForce"],
      ["lib", "mkDefault"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 128
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 26,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1026
        }
      }
    },
    "path": ["lib", "mkVMOverride"]
  },
  {
    "aliases": [
      ["lib", "options", "mkSinkUndeclaredOptions"],
      ["lib", "mkSinkUndeclaredOptions"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 140
        }
      },
      "lambdaDocs": {
        "content": "This option accepts anything, but it does not produce any result.\n\nThis is useful for sharing a module across different module sets\nwithout having to implement similar features as long as the\nvalues of the options are not accessed.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 29,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 221
        }
      }
    },
    "path": ["lib", "mkSinkUndeclaredOptions"]
  },
  {
    "aliases": [
      ["lib", "modules", "mkRenamedOptionModuleWith"],
      ["lib", "mkRenamedOptionModuleWith"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 128
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 31,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1143
        }
      }
    },
    "path": ["lib", "mkRenamedOptionModuleWith"]
  },
  {
    "aliases": [
      ["lib", "modules", "mkRenamedOptionModule"],
      ["lib", "mkRenamedOptionModule"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 128
        }
      },
      "lambdaDocs": {
        "content": "Return a module that causes a warning to be shown if the\nspecified \"from\" option is defined; the defined value is however\nforwarded to the \"to\" option. This can be used to rename options\nwhile providing backward compatibility. For example,\n\nmkRenamedOptionModule [ \"boot\" \"copyKernels\" ] [ \"boot\" \"loader\" \"grub\" \"copyKernels\" ]\n\nforwards any definitions of boot.copyKernels to\nboot.loader.grub.copyKernels while printing a warning.\n\nThis also copies over the priority from the aliased option to the\nnon-aliased option.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1136
        }
      }
    },
    "path": ["lib", "mkRenamedOptionModule"]
  },
  {
    "aliases": [
      ["lib", "modules", "mkRemovedOptionModule"],
      ["lib", "mkRemovedOptionModule"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 128
        }
      },
      "lambdaDocs": {
        "content": "Return a module that causes a warning to be shown if the\nspecified option is defined. For example,\n\nmkRemovedOptionModule [ \"boot\" \"loader\" \"grub\" \"bootDevice\" ] \"<replacement instructions>\"\n\ncauses a assertion if the user defines boot.loader.grub.bootDevice.\n\nreplacementInstructions is a string that provides instructions on\nhow to achieve the same functionality without the removed option,\nor alternatively a reasoning why the functionality is not needed.\nreplacementInstructions SHOULD be provided!",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1106
        }
      }
    },
    "path": ["lib", "mkRemovedOptionModule"]
  },
  {
    "aliases": [
      ["lib", "options", "mkPackageOptionMD"],
      ["lib", "options", "mkPackageOption"],
      ["lib", "mkPackageOptionMD"],
      ["lib", "mkPackageOption"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 140
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 174
        }
      }
    },
    "path": ["lib", "mkPackageOptionMD"]
  },
  {
    "aliases": [
      ["lib", "options", "mkPackageOptionMD"],
      ["lib", "options", "mkPackageOption"],
      ["lib", "mkPackageOptionMD"],
      ["lib", "mkPackageOption"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 140
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 174
        }
      }
    },
    "path": ["lib", "mkPackageOption"]
  },
  {
    "aliases": [
      ["lib", "modules", "mkOverride"],
      ["lib", "mkOverride"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 128
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 16,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1026
        }
      }
    },
    "path": ["lib", "mkOverride"]
  },
  {
    "aliases": [
      ["lib", "modules", "mkOrder"],
      ["lib", "mkOrder"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 128
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 13,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1042
        }
      }
    },
    "path": ["lib", "mkOrder"]
  },
  {
    "aliases": [
      ["lib", "types", "mkOptionType"],
      ["lib", "mkOptionType"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 148
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 109
        }
      }
    },
    "path": ["lib", "mkOptionType"]
  },
  {
    "aliases": [
      ["lib", "modules", "mkVMOverride"],
      ["lib", "modules", "mkOptionDefault"],
      ["lib", "modules", "mkImageMediaOverride"],
      ["lib", "modules", "mkForce"],
      ["lib", "modules", "mkDefault"],
      ["lib", "mkVMOverride"],
      ["lib", "mkOptionDefault"],
      ["lib", "mkImageMediaOverride"],
      ["lib", "mkForce"],
      ["lib", "mkDefault"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 128
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 26,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1026
        }
      }
    },
    "path": ["lib", "mkOptionDefault"]
  },
  {
    "aliases": [
      ["lib", "options", "mkOption"],
      ["lib", "mkOption"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 140
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 79
        }
      }
    },
    "path": ["lib", "mkOption"]
  },
  {
    "aliases": [
      ["lib", "modules", "mkMergedOptionModule"],
      ["lib", "mkMergedOptionModule"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 128
        }
      },
      "lambdaDocs": {
        "content": "Return a module that causes a warning to be shown if any of the \"from\"\noption is defined; the defined values can be used in the \"mergeFn\" to set\nthe \"to\" value.\nThis function can be used to merge multiple options into one that has a\ndifferent type.\n\n\"mergeFn\" takes the module \"config\" as a parameter and must return a value\nof \"to\" option type.\n\nmkMergedOptionModule\n[ [ \"a\" \"b\" \"c\" ]\n[ \"d\" \"e\" \"f\" ] ]\n[ \"x\" \"y\" \"z\" ]\n(config:\nlet value = p: getAttrFromPath p config;\nin\nif      (value [ \"a\" \"b\" \"c\" ]) == true then \"foo\"\nelse if (value [ \"d\" \"e\" \"f\" ]) == true then \"bar\"\nelse \"baz\")\n\n- options.a.b.c is a removed boolean option\n- options.d.e.f is a removed boolean option\n- options.x.y.z is a new str option that combines a.b.c and d.e.f\nfunctionality\n\nThis show a warning if any a.b.c or d.e.f is set, and set the value of\nx.y.z to the result of the merge function",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 26,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1196
        }
      }
    },
    "path": ["lib", "mkMergedOptionModule"]
  },
  {
    "aliases": [
      ["lib", "modules", "mkMerge"],
      ["lib", "mkMerge"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 128
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 13,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1021
        }
      }
    },
    "path": ["lib", "mkMerge"]
  },
  {
    "aliases": [
      ["lib", "modules", "mkVMOverride"],
      ["lib", "modules", "mkOptionDefault"],
      ["lib", "modules", "mkImageMediaOverride"],
      ["lib", "modules", "mkForce"],
      ["lib", "modules", "mkDefault"],
      ["lib", "mkVMOverride"],
      ["lib", "mkOptionDefault"],
      ["lib", "mkImageMediaOverride"],
      ["lib", "mkForce"],
      ["lib", "mkDefault"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 128
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 26,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1026
        }
      }
    },
    "path": ["lib", "mkImageMediaOverride"]
  },
  {
    "aliases": [
      ["lib", "modules", "mkIf"],
      ["lib", "mkIf"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 128
        }
      },
      "lambdaDocs": {
        "content": "Properties.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1011
        }
      }
    },
    "path": ["lib", "mkIf"]
  },
  {
    "aliases": [
      ["lib", "modules", "mkVMOverride"],
      ["lib", "modules", "mkOptionDefault"],
      ["lib", "modules", "mkImageMediaOverride"],
      ["lib", "modules", "mkForce"],
      ["lib", "modules", "mkDefault"],
      ["lib", "mkVMOverride"],
      ["lib", "mkOptionDefault"],
      ["lib", "mkImageMediaOverride"],
      ["lib", "mkForce"],
      ["lib", "mkDefault"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 128
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 26,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1026
        }
      }
    },
    "path": ["lib", "mkForce"]
  },
  {
    "aliases": [
      ["lib", "trivial", "id"],
      ["lib", "options", "mdDoc"],
      ["lib", "modules", "mkFixStrictness"],
      ["lib", "mkFixStrictness"],
      ["lib", "mdDoc"],
      ["lib", "id"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 128
        }
      },
      "lambdaDocs": {
        "content": "The identity function\nFor when you need a function that does “nothing”.\n\n# Type\n\n```\nid :: a -> a\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 19
        }
      }
    },
    "path": ["lib", "mkFixStrictness"]
  },
  {
    "aliases": [
      ["lib", "options", "mkEnableOption"],
      ["lib", "mkEnableOption"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 140
        }
      },
      "lambdaDocs": {
        "content": "Creates an Option attribute set for a boolean value option i.e an\noption to be toggled on or off:\n\n# Example\n\n```nix\nmkEnableOption \"foo\"\n=> { _type = \"option\"; default = false; description = \"Whether to enable foo.\"; example = true; type = { ... }; }\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 116
        }
      }
    },
    "path": ["lib", "mkEnableOption"]
  },
  {
    "aliases": [
      ["lib", "modules", "mkDerivedConfig"],
      ["lib", "mkDerivedConfig"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 128
        }
      },
      "lambdaDocs": {
        "content": "mkDerivedConfig : Option a -> (a -> Definition b) -> Definition b\n\nCreate config definitions with the same priority as the definition of another option.\nThis should be used for option definitions where one option sets the value of another as a convenience.\nFor instance a config file could be set with a `text` or `source` option, where text translates to a `source`\nvalue using `mkDerivedConfig options.text (pkgs.writeText \"filename.conf\")`.\n\nIt takes care of setting the right priority using `mkOverride`.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1280
        }
      }
    },
    "path": ["lib", "mkDerivedConfig"]
  },
  {
    "aliases": [
      ["lib", "modules", "mkVMOverride"],
      ["lib", "modules", "mkOptionDefault"],
      ["lib", "modules", "mkImageMediaOverride"],
      ["lib", "modules", "mkForce"],
      ["lib", "modules", "mkDefault"],
      ["lib", "mkVMOverride"],
      ["lib", "mkOptionDefault"],
      ["lib", "mkImageMediaOverride"],
      ["lib", "mkForce"],
      ["lib", "mkDefault"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 128
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 26,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1026
        }
      }
    },
    "path": ["lib", "mkDefault"]
  },
  {
    "aliases": [
      ["lib", "modules", "mkChangedOptionModule"],
      ["lib", "mkChangedOptionModule"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 128
        }
      },
      "lambdaDocs": {
        "content": "Single \"from\" version of mkMergedOptionModule.\nReturn a module that causes a warning to be shown if the \"from\" option is\ndefined; the defined value can be used in the \"mergeFn\" to set the \"to\"\nvalue.\nThis function can be used to change an option into another that has a\ndifferent type.\n\n\"mergeFn\" takes the module \"config\" as a parameter and must return a value of\n\"to\" option type.\n\nmkChangedOptionModule [ \"a\" \"b\" \"c\" ] [ \"x\" \"y\" \"z\" ]\n(config:\nlet value = getAttrFromPath [ \"a\" \"b\" \"c\" ] config;\nin\nif   value > 100 then \"high\"\nelse \"normal\")\n\n- options.a.b.c is a removed int option\n- options.x.y.z is a new str option that supersedes a.b.c\n\nThis show a warning if a.b.c is set, and set the value of x.y.z to the\nresult of the change function",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1244
        }
      }
    },
    "path": ["lib", "mkChangedOptionModule"]
  },
  {
    "aliases": [
      ["lib", "modules", "mkBefore"],
      ["lib", "modules", "mkAfter"],
      ["lib", "mkBefore"],
      ["lib", "mkAfter"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 128
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1042
        }
      }
    },
    "path": ["lib", "mkBefore"]
  },
  {
    "aliases": [
      ["lib", "modules", "mkAssert"],
      ["lib", "mkAssert"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 128
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1016
        }
      }
    },
    "path": ["lib", "mkAssert"]
  },
  {
    "aliases": [
      ["lib", "modules", "mkAliasOptionModuleMD"],
      ["lib", "modules", "mkAliasOptionModule"],
      ["lib", "mkAliasOptionModuleMD"],
      ["lib", "mkAliasOptionModule"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 128
        }
      },
      "lambdaDocs": {
        "content": "Like ‘mkRenamedOptionModule’, but doesn't show a warning.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1250
        }
      }
    },
    "path": ["lib", "mkAliasOptionModuleMD"]
  },
  {
    "aliases": [
      ["lib", "modules", "mkAliasOptionModuleMD"],
      ["lib", "modules", "mkAliasOptionModule"],
      ["lib", "mkAliasOptionModuleMD"],
      ["lib", "mkAliasOptionModule"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 128
        }
      },
      "lambdaDocs": {
        "content": "Like ‘mkRenamedOptionModule’, but doesn't show a warning.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1250
        }
      }
    },
    "path": ["lib", "mkAliasOptionModule"]
  },
  {
    "aliases": [
      ["lib", "modules", "mkAliasDefinitions"],
      ["lib", "mkAliasDefinitions"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 128
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 37,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1071
        }
      }
    },
    "path": ["lib", "mkAliasDefinitions"]
  },
  {
    "aliases": [
      ["lib", "modules", "mkAliasAndWrapDefinitions"],
      ["lib", "mkAliasAndWrapDefinitions"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 128
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 31,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1071
        }
      }
    },
    "path": ["lib", "mkAliasAndWrapDefinitions"]
  },
  {
    "aliases": [
      ["lib", "modules", "mkBefore"],
      ["lib", "modules", "mkAfter"],
      ["lib", "mkBefore"],
      ["lib", "mkAfter"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 128
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1042
        }
      }
    },
    "path": ["lib", "mkAfter"]
  },
  {
    "aliases": [
      ["lib", "uniqListExt"],
      ["lib", "misc", "uniqListExt"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 100
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 100
        }
      }
    },
    "path": ["lib", "misc", "uniqListExt"]
  },
  {
    "aliases": [
      ["lib", "uniqList"],
      ["lib", "misc", "uniqList"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 91
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 91
        }
      }
    },
    "path": ["lib", "misc", "uniqList"]
  },
  {
    "aliases": [
      ["lib", "setAttrMerge"],
      ["lib", "misc", "setAttrMerge"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 202
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 18,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 202
        }
      }
    },
    "path": ["lib", "misc", "setAttrMerge"]
  },
  {
    "aliases": [
      ["lib", "setAttr"],
      ["lib", "misc", "setAttr"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 197
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 13,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 197
        }
      }
    },
    "path": ["lib", "misc", "setAttr"]
  },
  {
    "aliases": [
      ["lib", "nvs"],
      ["lib", "misc", "nvs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 195
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 9,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 195
        }
      }
    },
    "path": ["lib", "misc", "nvs"]
  },
  {
    "aliases": [
      ["lib", "nixType"],
      ["lib", "misc", "nixType"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 282
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 13,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 282
        }
      }
    },
    "path": ["lib", "misc", "nixType"]
  },
  {
    "aliases": [
      ["lib", "modifySumArgs"],
      ["lib", "misc", "modifySumArgs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 140
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 19,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 140
        }
      }
    },
    "path": ["lib", "misc", "modifySumArgs"]
  },
  {
    "aliases": [
      ["lib", "misc", "mergeAttrsWithFunc"],
      ["lib", "mergeAttrsWithFunc"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 208
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 208
        }
      }
    },
    "path": ["lib", "misc", "mergeAttrsWithFunc"]
  },
  {
    "aliases": [
      ["lib", "misc", "mergeAttrsNoOverride"],
      ["lib", "mergeAttrsNoOverride"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 225
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 26,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 225
        }
      }
    },
    "path": ["lib", "misc", "mergeAttrsNoOverride"]
  },
  {
    "aliases": [
      ["lib", "misc", "mergeAttrsConcatenateValues"],
      ["lib", "mergeAttrsConcatenateValues"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 216
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 208
        }
      }
    },
    "path": ["lib", "misc", "mergeAttrsConcatenateValues"]
  },
  {
    "aliases": [
      ["lib", "misc", "mergeAttrsByFuncDefaultsClean"],
      ["lib", "mergeAttrsByFuncDefaultsClean"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 272
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 35,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 272
        }
      }
    },
    "path": ["lib", "misc", "mergeAttrsByFuncDefaultsClean"]
  },
  {
    "aliases": [
      ["lib", "misc", "mergeAttrsByFuncDefaults"],
      ["lib", "mergeAttrsByFuncDefaults"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 271
        }
      },
      "lambdaDocs": {
        "content": "“left fold”, like `foldr`, but from the left:\n`foldl op nul [x_1 x_2 ... x_n] == op (... (op (op nul x_1) x_2) ... x_n)`.\n\n# Example\n\n```nix\nlconcat = foldl (a: b: a + b) \"z\"\nlconcat [ \"a\" \"b\" \"c\" ]\n=> \"zabc\"\n# different types\nlstrange = foldl (str: int: str + toString (int + 1)) \"a\"\nlstrange [ 1 2 3 4 ]\n=> \"a2345\"\n```\n\n# Type\n\n```\nfoldl :: (b -> a -> b) -> b -> [a] -> b\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 20,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 115
        }
      }
    },
    "path": ["lib", "misc", "mergeAttrsByFuncDefaults"]
  },
  {
    "aliases": [
      ["lib", "misc", "mergeAttrByFunc"],
      ["lib", "mergeAttrByFunc"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 251
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 251
        }
      }
    },
    "path": ["lib", "misc", "mergeAttrByFunc"]
  },
  {
    "aliases": [
      ["lib", "misc", "maybeEnv"],
      ["lib", "maybeEnv"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 14
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 14
        }
      }
    },
    "path": ["lib", "misc", "maybeEnv"]
  },
  {
    "aliases": [
      ["lib", "misc", "maybeAttrNullable"],
      ["lib", "misc", "maybeAttr"],
      ["lib", "maybeAttrNullable"],
      ["lib", "maybeAttr"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 39
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 15,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 42
        }
      }
    },
    "path": ["lib", "misc", "maybeAttrNullable"]
  },
  {
    "aliases": [
      ["lib", "misc", "maybeAttrNullable"],
      ["lib", "misc", "maybeAttr"],
      ["lib", "maybeAttrNullable"],
      ["lib", "maybeAttr"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 42
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 15,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 42
        }
      }
    },
    "path": ["lib", "misc", "maybeAttr"]
  },
  {
    "aliases": [
      ["lib", "misc", "mapAttrsFlatten"],
      ["lib", "mapAttrsFlatten"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 192
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 192
        }
      }
    },
    "path": ["lib", "misc", "mapAttrsFlatten"]
  },
  {
    "aliases": [
      ["lib", "misc", "lazyGenericClosure"],
      ["lib", "lazyGenericClosure"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 124
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 124
        }
      }
    },
    "path": ["lib", "misc", "lazyGenericClosure"]
  },
  {
    "aliases": [
      ["lib", "misc", "innerModifySumArgs"],
      ["lib", "innerModifySumArgs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 138
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 138
        }
      }
    },
    "path": ["lib", "misc", "innerModifySumArgs"]
  },
  {
    "aliases": [
      ["lib", "misc", "innerClosePropagation"],
      ["lib", "innerClosePropagation"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 143
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 143
        }
      }
    },
    "path": ["lib", "misc", "innerClosePropagation"]
  },
  {
    "aliases": [
      ["lib", "misc", "imap"],
      ["lib", "lists", "imap1"],
      ["lib", "imap1"],
      ["lib", "imap"]
    ],
    "docs": {
      "attrDocs": {
        "content": "deprecated:\n\nFor historical reasons, imap has an index starting at 1.\n\nBut for consistency with the rest of the library we want an index\nstarting at zero.",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 302
        }
      },
      "lambdaDocs": {
        "content": "Map with index starting from 1\n\n# Example\n\n```nix\nimap1 (i: v: \"${v}-${toString i}\") [\"a\" \"b\"]\n=> [ \"a-1\" \"b-2\" ]\n```\n\n# Type\n\n```\nimap1 :: (int -> a -> b) -> [a] -> [b]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 11,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 172
        }
      }
    },
    "path": ["lib", "misc", "imap"]
  },
  {
    "aliases": [
      ["lib", "misc", "ifEnable"],
      ["lib", "ifEnable"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 47
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 47
        }
      }
    },
    "path": ["lib", "misc", "ifEnable"]
  },
  {
    "aliases": [
      ["lib", "misc", "getValue"],
      ["lib", "getValue"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 66
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 66
        }
      }
    },
    "path": ["lib", "misc", "getValue"]
  },
  {
    "aliases": [
      ["lib", "misc", "foldArgs"],
      ["lib", "foldArgs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 23
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 23
        }
      }
    },
    "path": ["lib", "misc", "foldArgs"]
  },
  {
    "aliases": [
      ["lib", "misc", "defaultMergeArg"],
      ["lib", "defaultMergeArg"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 18
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 18
        }
      }
    },
    "path": ["lib", "misc", "defaultMergeArg"]
  },
  {
    "aliases": [
      ["lib", "misc", "defaultMerge"],
      ["lib", "defaultMerge"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 22
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 18,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 22
        }
      }
    },
    "path": ["lib", "misc", "defaultMerge"]
  },
  {
    "aliases": [
      ["lib", "misc", "condConcat"],
      ["lib", "condConcat"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 114
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 16,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 114
        }
      }
    },
    "path": ["lib", "misc", "condConcat"]
  },
  {
    "aliases": [["lib", "misc", "closePropagationSlow"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 160
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 26,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 160
        }
      }
    },
    "path": ["lib", "misc", "closePropagationSlow"]
  },
  {
    "aliases": [
      ["lib", "misc", "closePropagationFast"],
      ["lib", "misc", "closePropagation"],
      ["lib", "closePropagation"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 168
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 26,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 168
        }
      }
    },
    "path": ["lib", "misc", "closePropagationFast"]
  },
  {
    "aliases": [
      ["lib", "misc", "closePropagationFast"],
      ["lib", "misc", "closePropagation"],
      ["lib", "closePropagation"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 187
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 26,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 168
        }
      }
    },
    "path": ["lib", "misc", "closePropagation"]
  },
  {
    "aliases": [
      ["lib", "misc", "checkReqs"],
      ["lib", "checkReqs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 78
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 15,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 78
        }
      }
    },
    "path": ["lib", "misc", "checkReqs"]
  },
  {
    "aliases": [
      ["lib", "misc", "checkFlag"],
      ["lib", "checkFlag"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 57
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 15,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 57
        }
      }
    },
    "path": ["lib", "misc", "checkFlag"]
  },
  {
    "aliases": [
      ["lib", "trivial", "min"],
      ["lib", "min"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 73
        }
      },
      "lambdaDocs": {
        "content": "Return minimum of two numbers.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 9,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 336
        }
      }
    },
    "path": ["lib", "min"]
  },
  {
    "aliases": [
      ["lib", "updateName"],
      ["lib", "meta", "updateName"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Like `setName`, but takes the previous name as an argument.\n\n# Example\n\n```nix\nupdateName (oldName: oldName + \"-experimental\") somePkg\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 47
        }
      },
      "lambdaDocs": {
        "content": "Like `setName`, but takes the previous name as an argument.\n\n# Example\n\n```nix\nupdateName (oldName: oldName + \"-experimental\") somePkg\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 16,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 47
        }
      }
    },
    "path": ["lib", "meta", "updateName"]
  },
  {
    "aliases": [
      ["lib", "setPrio"],
      ["lib", "meta", "setPrio"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Set the nix-env priority of the package.",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 66
        }
      },
      "lambdaDocs": {
        "content": "Set the nix-env priority of the package.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 13,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 66
        }
      }
    },
    "path": ["lib", "meta", "setPrio"]
  },
  {
    "aliases": [
      ["lib", "setName"],
      ["lib", "meta", "setName"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Change the symbolic name of a package for presentation purposes\n(i.e., so that nix-env users can tell them apart).",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 35
        }
      },
      "lambdaDocs": {
        "content": "Change the symbolic name of a package for presentation purposes\n(i.e., so that nix-env users can tell them apart).",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 13,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 35
        }
      }
    },
    "path": ["lib", "meta", "setName"]
  },
  {
    "aliases": [["lib", "meta", "platformMatch"]],
    "docs": {
      "attrDocs": {
        "content": "Check to see if a platform is matched by the given `meta.platforms`\nelement.\n\nA `meta.platform` pattern is either\n\n1. (legacy) a system string.\n\n2. (modern) a pattern for the entire platform structure (see `lib.systems.inspect.platformPatterns`).\n\n3. (modern) a pattern for the platform `parsed` field (see `lib.systems.inspect.patterns`).\n\nWe can inject these into a pattern for the whole of a structured platform,\nand then match that.",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 107
        }
      },
      "lambdaDocs": {
        "content": "Check to see if a platform is matched by the given `meta.platforms`\nelement.\n\nA `meta.platform` pattern is either\n\n1. (legacy) a system string.\n\n2. (modern) a pattern for the entire platform structure (see `lib.systems.inspect.platformPatterns`).\n\n3. (modern) a pattern for the platform `parsed` field (see `lib.systems.inspect.patterns`).\n\nWe can inject these into a pattern for the whole of a structured platform,\nand then match that.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 19,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 107
        }
      }
    },
    "path": ["lib", "meta", "platformMatch"]
  },
  {
    "aliases": [
      ["lib", "meta", "mapDerivationAttrset"],
      ["lib", "mapDerivationAttrset"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Apply a function to each derivation and only to derivations in an attrset.",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 61
        }
      },
      "lambdaDocs": {
        "content": "Apply a function to each derivation and only to derivations in an attrset.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 26,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 61
        }
      }
    },
    "path": ["lib", "meta", "mapDerivationAttrset"]
  },
  {
    "aliases": [
      ["lib", "meta", "lowPrioSet"],
      ["lib", "lowPrioSet"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Apply lowPrio to an attrset with derivations",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 77
        }
      },
      "lambdaDocs": {
        "content": "Apply lowPrio to an attrset with derivations",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 16,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 77
        }
      }
    },
    "path": ["lib", "meta", "lowPrioSet"]
  },
  {
    "aliases": [
      ["lib", "meta", "lowPrio"],
      ["lib", "meta", "hiPrio"],
      ["lib", "lowPrio"],
      ["lib", "hiPrio"],
      ["pkgs", "lowPrio"],
      ["pkgs", "hiPrio"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 72
        }
      },
      "lambdaDocs": {
        "content": "Add to or override the meta attributes of the given\nderivation.\n\n# Example\n\n```nix\naddMetaAttrs {description = \"Bla blah\";} somePkg\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 21
        }
      }
    },
    "path": ["lib", "meta", "lowPrio"]
  },
  {
    "aliases": [
      ["lib", "meta", "hiPrioSet"],
      ["lib", "hiPrioSet"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Apply hiPrio to an attrset with derivations",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 89
        }
      },
      "lambdaDocs": {
        "content": "Apply hiPrio to an attrset with derivations",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 15,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 89
        }
      }
    },
    "path": ["lib", "meta", "hiPrioSet"]
  },
  {
    "aliases": [
      ["lib", "meta", "lowPrio"],
      ["lib", "meta", "hiPrio"],
      ["lib", "lowPrio"],
      ["lib", "hiPrio"],
      ["pkgs", "lowPrio"],
      ["pkgs", "hiPrio"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 84
        }
      },
      "lambdaDocs": {
        "content": "Add to or override the meta attributes of the given\nderivation.\n\n# Example\n\n```nix\naddMetaAttrs {description = \"Bla blah\";} somePkg\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 21
        }
      }
    },
    "path": ["lib", "meta", "hiPrio"]
  },
  {
    "aliases": [
      ["lib", "meta", "getLicenseFromSpdxId"],
      ["lib", "getLicenseFromSpdxId"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 154
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 8,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 158
        }
      }
    },
    "path": ["lib", "meta", "getLicenseFromSpdxId"]
  },
  {
    "aliases": [
      ["lib", "meta", "getExe'"],
      ["lib", "getExe'"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 211
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 13,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 211
        }
      }
    },
    "path": ["lib", "meta", "getExe'"]
  },
  {
    "aliases": [
      ["lib", "meta", "getExe"],
      ["lib", "getExe"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 182
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 12,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 182
        }
      }
    },
    "path": ["lib", "meta", "getExe"]
  },
  {
    "aliases": [
      ["lib", "meta", "dontDistribute"],
      ["lib", "dontDistribute"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Disable Hydra builds of given derivation.",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 28
        }
      },
      "lambdaDocs": {
        "content": "Disable Hydra builds of given derivation.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 20,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 28
        }
      }
    },
    "path": ["lib", "meta", "dontDistribute"]
  },
  {
    "aliases": [["lib", "meta", "availableOn"]],
    "docs": {
      "attrDocs": {
        "content": "Check if a package is available on a given platform.\n\nA package is available on a platform if both\n\n1. One of `meta.platforms` pattern matches the given\nplatform, or `meta.platforms` is not present.\n\n2. None of `meta.badPlatforms` pattern matches the given platform.",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 126
        }
      },
      "lambdaDocs": {
        "content": "Check if a package is available on a given platform.\n\nA package is available on a platform if both\n\n1. One of `meta.platforms` pattern matches the given\nplatform, or `meta.platforms` is not present.\n\n2. None of `meta.badPlatforms` pattern matches the given platform.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 126
        }
      }
    },
    "path": ["lib", "meta", "availableOn"]
  },
  {
    "aliases": [
      ["lib", "meta", "appendToName"],
      ["lib", "appendToName"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Append a suffix to the name of a package (before the version\npart).",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 54
        }
      },
      "lambdaDocs": {
        "content": "Append a suffix to the name of a package (before the version\npart).",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 18,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 54
        }
      }
    },
    "path": ["lib", "meta", "appendToName"]
  },
  {
    "aliases": [
      ["lib", "meta", "addMetaAttrs"],
      ["lib", "addMetaAttrs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Add to or override the meta attributes of the given\nderivation.\n\n# Example\n\n```nix\naddMetaAttrs {description = \"Bla blah\";} somePkg\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 21
        }
      },
      "lambdaDocs": {
        "content": "Add to or override the meta attributes of the given\nderivation.\n\n# Example\n\n```nix\naddMetaAttrs {description = \"Bla blah\";} somePkg\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 18,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 21
        }
      }
    },
    "path": ["lib", "meta", "addMetaAttrs"]
  },
  {
    "aliases": [
      ["lib", "strings", "mesonOption"],
      ["lib", "mesonOption"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "Create a -D<feature>=<value> string that can be passed to typical Meson\ninvocations.\n\n# Example\n\n```nix\nmesonOption \"engine\" \"opengl\"\n=> \"-Dengine=opengl\"\n```\n\n# Type\n\n```\nmesonOption :: string -> string -> string\n\n@param feature The feature to be set\n@param value The desired value\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1072
        }
      }
    },
    "path": ["lib", "mesonOption"]
  },
  {
    "aliases": [
      ["lib", "strings", "mesonEnable"],
      ["lib", "mesonEnable"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "Create a -D<feature>={enabled,disabled} string that can be passed to\ntypical Meson invocations.\n\n# Example\n\n```nix\nmesonEnable \"docs\" true\n=> \"-Ddocs=enabled\"\nmesonEnable \"savage\" false\n=> \"-Dsavage=disabled\"\n```\n\n# Type\n\n```\nmesonEnable :: string -> bool -> string\n\n@param feature The feature to be enabled or disabled\n@param flag The controlling flag\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1126
        }
      }
    },
    "path": ["lib", "mesonEnable"]
  },
  {
    "aliases": [
      ["lib", "strings", "mesonBool"],
      ["lib", "mesonBool"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "Create a -D<condition>={true,false} string that can be passed to typical\nMeson invocations.\n\n# Example\n\n```nix\nmesonBool \"hardened\" true\n=> \"-Dhardened=true\"\nmesonBool \"static\" false\n=> \"-Dstatic=false\"\n```\n\n# Type\n\n```\nmesonBool :: string -> bool -> string\n\n@param condition The condition to be made true or false\n@param flag The controlling flag of the condition\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 15,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1099
        }
      }
    },
    "path": ["lib", "mesonBool"]
  },
  {
    "aliases": [
      ["lib", "options", "mergeUniqueOption"],
      ["lib", "mergeUniqueOption"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 140
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 247
        }
      }
    },
    "path": ["lib", "mergeUniqueOption"]
  },
  {
    "aliases": [
      ["lib", "modules", "mergeOptionDecls"],
      ["lib", "mergeOptionDecls"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 128
        }
      },
      "lambdaDocs": {
        "content": "Merge multiple option declarations into a single declaration.  In\ngeneral, there should be only one declaration of each option.\nThe exception is the ‘options’ attribute, which specifies\nsub-options.  These can be specified multiple times to allow one\nmodule to add sub-options to an option declared somewhere else\n(e.g. multiple modules define sub-options for ‘fileSystems’).\n\n'loc' is the list of attribute names where the option is located.\n\n'opts' is a list of modules.  Each module has an options attribute which\ncorrespond to the definition of 'loc' in 'opt.file'.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 4,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 748
        }
      }
    },
    "path": ["lib", "mergeOptionDecls"]
  },
  {
    "aliases": [
      ["lib", "options", "mergeOneOption"],
      ["lib", "mergeOneOption"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 140
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 36,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 247
        }
      }
    },
    "path": ["lib", "mergeOneOption"]
  },
  {
    "aliases": [
      ["lib", "modules", "mergeModules'"],
      ["lib", "mergeModules'"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 128
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 19,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 547
        }
      }
    },
    "path": ["lib", "mergeModules'"]
  },
  {
    "aliases": [
      ["lib", "modules", "mergeModules"],
      ["lib", "mergeModules"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 128
        }
      },
      "lambdaDocs": {
        "content": "Merge a list of modules.  This will recurse over the option\ndeclarations in all modules, combining them into a single set.\nAt the same time, for each option declaration, it will merge the\ncorresponding option definitions in all machines, returning them\nin the ‘value’ attribute of each option.\n\nThis returns a set like\n{\n# A recursive set of options along with their final values\nmatchedOptions = {\nfoo = { _type = \"option\"; value = \"option value of foo\"; ... };\nbar.baz = { _type = \"option\"; value = \"option value of bar.baz\"; ... };\n...\n};\n# A list of definitions that weren't matched by any option\nunmatchedDefns = [\n{ file = \"file.nix\"; prefix = [ \"qux\" ]; value = \"qux\"; }\n...\n];\n}",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 18,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 543
        }
      }
    },
    "path": ["lib", "mergeModules"]
  },
  {
    "aliases": [
      ["lib", "options", "mergeEqualOption"],
      ["lib", "mergeEqualOption"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 140
        }
      },
      "lambdaDocs": {
        "content": "\"Merge\" option definitions by checking that they all have the same value.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 22,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 256
        }
      }
    },
    "path": ["lib", "mergeEqualOption"]
  },
  {
    "aliases": [
      ["lib", "modules", "mergeDefinitions"],
      ["lib", "mergeDefinitions"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 128
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 22,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 822
        }
      }
    },
    "path": ["lib", "mergeDefinitions"]
  },
  {
    "aliases": [
      ["lib", "options", "mergeDefaultOption"],
      ["lib", "mergeDefaultOption"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 140
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 234
        }
      }
    },
    "path": ["lib", "mergeDefaultOption"]
  },
  {
    "aliases": [
      ["lib", "misc", "mergeAttrsWithFunc"],
      ["lib", "mergeAttrsWithFunc"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 156
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 208
        }
      }
    },
    "path": ["lib", "mergeAttrsWithFunc"]
  },
  {
    "aliases": [
      ["lib", "misc", "mergeAttrsNoOverride"],
      ["lib", "mergeAttrsNoOverride"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 156
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 26,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 225
        }
      }
    },
    "path": ["lib", "mergeAttrsNoOverride"]
  },
  {
    "aliases": [
      ["lib", "misc", "mergeAttrsConcatenateValues"],
      ["lib", "mergeAttrsConcatenateValues"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 156
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 208
        }
      }
    },
    "path": ["lib", "mergeAttrsConcatenateValues"]
  },
  {
    "aliases": [
      ["lib", "misc", "mergeAttrsByFuncDefaultsClean"],
      ["lib", "mergeAttrsByFuncDefaultsClean"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 156
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 35,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 272
        }
      }
    },
    "path": ["lib", "mergeAttrsByFuncDefaultsClean"]
  },
  {
    "aliases": [
      ["lib", "misc", "mergeAttrsByFuncDefaults"],
      ["lib", "mergeAttrsByFuncDefaults"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 156
        }
      },
      "lambdaDocs": {
        "content": "“left fold”, like `foldr`, but from the left:\n`foldl op nul [x_1 x_2 ... x_n] == op (... (op (op nul x_1) x_2) ... x_n)`.\n\n# Example\n\n```nix\nlconcat = foldl (a: b: a + b) \"z\"\nlconcat [ \"a\" \"b\" \"c\" ]\n=> \"zabc\"\n# different types\nlstrange = foldl (str: int: str + toString (int + 1)) \"a\"\nlstrange [ 1 2 3 4 ]\n=> \"a2345\"\n```\n\n# Type\n\n```\nfoldl :: (b -> a -> b) -> b -> [a] -> b\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 20,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 115
        }
      }
    },
    "path": ["lib", "mergeAttrsByFuncDefaults"]
  },
  {
    "aliases": [
      ["lib", "trivial", "mergeAttrs"],
      ["lib", "mergeAttrs"],
      ["lib", "mergeAttrBy", "meta"],
      ["lib", "mergeAttrBy", "flags"],
      ["lib", "mergeAttrBy", "cfg"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 73
        }
      },
      "lambdaDocs": {
        "content": "Merge two attribute sets shallowly, right side trumps left\n\nmergeAttrs :: attrs -> attrs -> attrs\n\n# Example\n\n```nix\nmergeAttrs { a = 1; b = 2; } { b = 3; c = 4; }\n=> { a = 1; b = 3; c = 4; }\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 178
        }
      }
    },
    "path": ["lib", "mergeAttrs"]
  },
  {
    "aliases": [
      ["lib", "misc", "mergeAttrByFunc"],
      ["lib", "mergeAttrByFunc"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 156
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 251
        }
      }
    },
    "path": ["lib", "mergeAttrByFunc"]
  },
  {
    "aliases": [
      ["lib", "trivial", "concat"],
      ["lib", "mergeAttrBy", "propagatedBuildInputs"],
      ["lib", "mergeAttrBy", "prePhases"],
      ["lib", "mergeAttrBy", "postAll"],
      ["lib", "mergeAttrBy", "patches"],
      ["lib", "mergeAttrBy", "nativeBuildInputs"],
      ["lib", "mergeAttrBy", "configureFlags"],
      ["lib", "mergeAttrBy", "buildInputs"],
      ["lib", "concat"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "Concatenate two lists\n\n# Example\n\n```nix\nconcat [ 1 2 ] [ 3 4 ]\n=> [ 1 2 3 4 ]\n```\n\n# Type\n\n```\nconcat :: [a] -> [a] -> [a]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 12,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 111
        }
      }
    },
    "path": ["lib", "mergeAttrBy", "propagatedBuildInputs"]
  },
  {
    "aliases": [
      ["lib", "trivial", "concat"],
      ["lib", "mergeAttrBy", "propagatedBuildInputs"],
      ["lib", "mergeAttrBy", "prePhases"],
      ["lib", "mergeAttrBy", "postAll"],
      ["lib", "mergeAttrBy", "patches"],
      ["lib", "mergeAttrBy", "nativeBuildInputs"],
      ["lib", "mergeAttrBy", "configureFlags"],
      ["lib", "mergeAttrBy", "buildInputs"],
      ["lib", "concat"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "Concatenate two lists\n\n# Example\n\n```nix\nconcat [ 1 2 ] [ 3 4 ]\n=> [ 1 2 3 4 ]\n```\n\n# Type\n\n```\nconcat :: [a] -> [a] -> [a]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 12,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 111
        }
      }
    },
    "path": ["lib", "mergeAttrBy", "prePhases"]
  },
  {
    "aliases": [
      ["lib", "mergeAttrBy", "preConfigure"],
      ["lib", "mergeAttrBy", "postInstall"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 46,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 279
        }
      }
    },
    "path": ["lib", "mergeAttrBy", "preConfigure"]
  },
  {
    "aliases": [
      ["lib", "mergeAttrBy", "preConfigure"],
      ["lib", "mergeAttrBy", "postInstall"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 46,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 279
        }
      }
    },
    "path": ["lib", "mergeAttrBy", "postInstall"]
  },
  {
    "aliases": [
      ["lib", "trivial", "concat"],
      ["lib", "mergeAttrBy", "propagatedBuildInputs"],
      ["lib", "mergeAttrBy", "prePhases"],
      ["lib", "mergeAttrBy", "postAll"],
      ["lib", "mergeAttrBy", "patches"],
      ["lib", "mergeAttrBy", "nativeBuildInputs"],
      ["lib", "mergeAttrBy", "configureFlags"],
      ["lib", "mergeAttrBy", "buildInputs"],
      ["lib", "concat"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "Concatenate two lists\n\n# Example\n\n```nix\nconcat [ 1 2 ] [ 3 4 ]\n=> [ 1 2 3 4 ]\n```\n\n# Type\n\n```\nconcat :: [a] -> [a] -> [a]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 12,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 111
        }
      }
    },
    "path": ["lib", "mergeAttrBy", "postAll"]
  },
  {
    "aliases": [
      ["lib", "trivial", "concat"],
      ["lib", "mergeAttrBy", "propagatedBuildInputs"],
      ["lib", "mergeAttrBy", "prePhases"],
      ["lib", "mergeAttrBy", "postAll"],
      ["lib", "mergeAttrBy", "patches"],
      ["lib", "mergeAttrBy", "nativeBuildInputs"],
      ["lib", "mergeAttrBy", "configureFlags"],
      ["lib", "mergeAttrBy", "buildInputs"],
      ["lib", "concat"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "Concatenate two lists\n\n# Example\n\n```nix\nconcat [ 1 2 ] [ 3 4 ]\n=> [ 1 2 3 4 ]\n```\n\n# Type\n\n```\nconcat :: [a] -> [a] -> [a]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 12,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 111
        }
      }
    },
    "path": ["lib", "mergeAttrBy", "patches"]
  },
  {
    "aliases": [
      ["lib", "trivial", "concat"],
      ["lib", "mergeAttrBy", "propagatedBuildInputs"],
      ["lib", "mergeAttrBy", "prePhases"],
      ["lib", "mergeAttrBy", "postAll"],
      ["lib", "mergeAttrBy", "patches"],
      ["lib", "mergeAttrBy", "nativeBuildInputs"],
      ["lib", "mergeAttrBy", "configureFlags"],
      ["lib", "mergeAttrBy", "buildInputs"],
      ["lib", "concat"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "Concatenate two lists\n\n# Example\n\n```nix\nconcat [ 1 2 ] [ 3 4 ]\n=> [ 1 2 3 4 ]\n```\n\n# Type\n\n```\nconcat :: [a] -> [a] -> [a]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 12,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 111
        }
      }
    },
    "path": ["lib", "mergeAttrBy", "nativeBuildInputs"]
  },
  {
    "aliases": [
      ["lib", "trivial", "mergeAttrs"],
      ["lib", "mergeAttrs"],
      ["lib", "mergeAttrBy", "meta"],
      ["lib", "mergeAttrBy", "flags"],
      ["lib", "mergeAttrBy", "cfg"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "Merge two attribute sets shallowly, right side trumps left\n\nmergeAttrs :: attrs -> attrs -> attrs\n\n# Example\n\n```nix\nmergeAttrs { a = 1; b = 2; } { b = 3; c = 4; }\n=> { a = 1; b = 3; c = 4; }\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 178
        }
      }
    },
    "path": ["lib", "mergeAttrBy", "meta"]
  },
  {
    "aliases": [
      ["lib", "trivial", "mergeAttrs"],
      ["lib", "mergeAttrs"],
      ["lib", "mergeAttrBy", "meta"],
      ["lib", "mergeAttrBy", "flags"],
      ["lib", "mergeAttrBy", "cfg"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "Merge two attribute sets shallowly, right side trumps left\n\nmergeAttrs :: attrs -> attrs -> attrs\n\n# Example\n\n```nix\nmergeAttrs { a = 1; b = 2; } { b = 3; c = 4; }\n=> { a = 1; b = 3; c = 4; }\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 178
        }
      }
    },
    "path": ["lib", "mergeAttrBy", "flags"]
  },
  {
    "aliases": [
      ["lib", "trivial", "concat"],
      ["lib", "mergeAttrBy", "propagatedBuildInputs"],
      ["lib", "mergeAttrBy", "prePhases"],
      ["lib", "mergeAttrBy", "postAll"],
      ["lib", "mergeAttrBy", "patches"],
      ["lib", "mergeAttrBy", "nativeBuildInputs"],
      ["lib", "mergeAttrBy", "configureFlags"],
      ["lib", "mergeAttrBy", "buildInputs"],
      ["lib", "concat"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "Concatenate two lists\n\n# Example\n\n```nix\nconcat [ 1 2 ] [ 3 4 ]\n=> [ 1 2 3 4 ]\n```\n\n# Type\n\n```\nconcat :: [a] -> [a] -> [a]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 12,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 111
        }
      }
    },
    "path": ["lib", "mergeAttrBy", "configureFlags"]
  },
  {
    "aliases": [
      ["lib", "trivial", "mergeAttrs"],
      ["lib", "mergeAttrs"],
      ["lib", "mergeAttrBy", "meta"],
      ["lib", "mergeAttrBy", "flags"],
      ["lib", "mergeAttrBy", "cfg"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "Merge two attribute sets shallowly, right side trumps left\n\nmergeAttrs :: attrs -> attrs -> attrs\n\n# Example\n\n```nix\nmergeAttrs { a = 1; b = 2; } { b = 3; c = 4; }\n=> { a = 1; b = 3; c = 4; }\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 178
        }
      }
    },
    "path": ["lib", "mergeAttrBy", "cfg"]
  },
  {
    "aliases": [
      ["lib", "trivial", "concat"],
      ["lib", "mergeAttrBy", "propagatedBuildInputs"],
      ["lib", "mergeAttrBy", "prePhases"],
      ["lib", "mergeAttrBy", "postAll"],
      ["lib", "mergeAttrBy", "patches"],
      ["lib", "mergeAttrBy", "nativeBuildInputs"],
      ["lib", "mergeAttrBy", "configureFlags"],
      ["lib", "mergeAttrBy", "buildInputs"],
      ["lib", "concat"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "Concatenate two lists\n\n# Example\n\n```nix\nconcat [ 1 2 ] [ 3 4 ]\n=> [ 1 2 3 4 ]\n```\n\n# Type\n\n```\nconcat :: [a] -> [a] -> [a]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 12,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 111
        }
      }
    },
    "path": ["lib", "mergeAttrBy", "buildInputs"]
  },
  {
    "aliases": [
      ["lib", "trivial", "id"],
      ["lib", "options", "mdDoc"],
      ["lib", "modules", "mkFixStrictness"],
      ["lib", "mkFixStrictness"],
      ["lib", "mdDoc"],
      ["lib", "id"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 140
        }
      },
      "lambdaDocs": {
        "content": "The identity function\nFor when you need a function that does “nothing”.\n\n# Type\n\n```\nid :: a -> a\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 19
        }
      }
    },
    "path": ["lib", "mdDoc"]
  },
  {
    "aliases": [
      ["lib", "misc", "maybeEnv"],
      ["lib", "maybeEnv"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 156
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 14
        }
      }
    },
    "path": ["lib", "maybeEnv"]
  },
  {
    "aliases": [
      ["lib", "misc", "maybeAttrNullable"],
      ["lib", "misc", "maybeAttr"],
      ["lib", "maybeAttrNullable"],
      ["lib", "maybeAttr"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 156
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 15,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 42
        }
      }
    },
    "path": ["lib", "maybeAttrNullable"]
  },
  {
    "aliases": [
      ["lib", "misc", "maybeAttrNullable"],
      ["lib", "misc", "maybeAttr"],
      ["lib", "maybeAttrNullable"],
      ["lib", "maybeAttr"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 156
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 15,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 42
        }
      }
    },
    "path": ["lib", "maybeAttr"]
  },
  {
    "aliases": [
      ["lib", "trivial", "max"],
      ["lib", "max"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 73
        }
      },
      "lambdaDocs": {
        "content": "Return maximum of two numbers.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 9,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 341
        }
      }
    },
    "path": ["lib", "max"]
  },
  {
    "aliases": [
      ["lib", "matchAttrs"],
      ["lib", "attrsets", "matchAttrs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "Returns true if the pattern is contained in the set. False otherwise.\n\n# Example\n\n```nix\nmatchAttrs { cpu = {}; } { cpu = { bits = 64; }; }\n=> true\n```\n\n# Type\n\n```\nmatchAttrs :: AttrSet -> AttrSet -> Bool\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1092
        }
      }
    },
    "path": ["lib", "matchAttrs"]
  },
  {
    "aliases": [
      ["lib", "trivial", "mapNullable"],
      ["lib", "mapNullable"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 73
        }
      },
      "lambdaDocs": {
        "content": "Apply function if the supplied argument is non-null.\n\n# Example\n\n```nix\nmapNullable (x: x+1) null\n=> null\nmapNullable (x: x+1) 22\n=> 23\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 214
        }
      }
    },
    "path": ["lib", "mapNullable"]
  },
  {
    "aliases": [
      ["lib", "meta", "mapDerivationAttrset"],
      ["lib", "mapDerivationAttrset"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 120
        }
      },
      "lambdaDocs": {
        "content": "Apply a function to each derivation and only to derivations in an attrset.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 26,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 61
        }
      }
    },
    "path": ["lib", "mapDerivationAttrset"]
  },
  {
    "aliases": [
      ["lib", "mapAttrsToList"],
      ["lib", "attrsets", "mapAttrsToList"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "Call a function for each attribute in the given set and return\nthe result in a list.\n\n# Example\n\n```nix\nmapAttrsToList (name: value: name + value)\n   { x = \"a\"; y = \"b\"; }\n=> [ \"xa\" \"yb\" ]\n```\n\n# Type\n\n```\nmapAttrsToList :: (String -> a -> b) -> AttrSet -> [b]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 678
        }
      }
    },
    "path": ["lib", "mapAttrsToList"]
  },
  {
    "aliases": [
      ["lib", "mapAttrsRecursiveCond"],
      ["lib", "attrsets", "mapAttrsRecursiveCond"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "Like `mapAttrsRecursive`, but it takes an additional predicate\nfunction that tells it whether to recurse into an attribute\nset.  If it returns false, `mapAttrsRecursiveCond` does not\nrecurse, but does apply the map function.  If it returns true, it\ndoes recurse, and does not apply the map function.\n\n# Example\n\n```nix\n# To prevent recursing into derivations (which are attribute\n# sets with the attribute \"type\" equal to \"derivation\"):\nmapAttrsRecursiveCond\n  (as: !(as ? \"type\" && as.type == \"derivation\"))\n  (x: ... do something ...)\n  attrs\n```\n\n# Type\n\n```\nmapAttrsRecursiveCond :: (AttrSet -> Bool) -> ([String] -> a -> b) -> AttrSet -> AttrSet\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 742
        }
      }
    },
    "path": ["lib", "mapAttrsRecursiveCond"]
  },
  {
    "aliases": [
      ["lib", "mapAttrsRecursive"],
      ["lib", "attrsets", "mapAttrsRecursive"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 710
        }
      }
    },
    "path": ["lib", "mapAttrsRecursive"]
  },
  {
    "aliases": [
      ["lib", "misc", "mapAttrsFlatten"],
      ["lib", "mapAttrsFlatten"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 156
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 192
        }
      }
    },
    "path": ["lib", "mapAttrsFlatten"]
  },
  {
    "aliases": [
      ["lib", "mapAttrs'"],
      ["lib", "attrsets", "mapAttrs'"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "Like `mapAttrs`, but allows the name of each attribute to be\nchanged in addition to the value.  The applied function should\nreturn both the new name and value as a `nameValuePair`.\n\n# Example\n\n```nix\nmapAttrs' (name: value: nameValuePair (\"foo_\" + name) (\"bar-\" + value))\n   { x = \"a\"; y = \"b\"; }\n=> { foo_x = \"bar-a\"; foo_y = \"bar-b\"; }\n```\n\n# Type\n\n```\nmapAttrs' :: (String -> Any -> { name :: String; value :: Any; }) -> AttrSet -> AttrSet\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 652
        }
      }
    },
    "path": ["lib", "mapAttrs'"]
  },
  {
    "aliases": [
      ["lib", "mapAttrs"],
      ["lib", "attrsets", "mapAttrs"],
      ["builtins", "mapAttrs"],
      ["builtins", "mapAttrs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "Apply function *f* to every element of *attrset*. For example,\n\n```nix\nbuiltins.mapAttrs (name: value: value * 10) { a = 1; b = 2; }\n```\n\nevaluates to `{ a = 10; b = 20; }`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "mapAttrs"]
  },
  {
    "aliases": [
      ["lib", "strings", "makeSearchPathOutput"],
      ["lib", "makeSearchPathOutput"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 260
        }
      }
    },
    "path": ["lib", "makeSearchPathOutput"]
  },
  {
    "aliases": [
      ["lib", "strings", "makeSearchPath"],
      ["lib", "makeSearchPath"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 234
        }
      }
    },
    "path": ["lib", "makeSearchPath"]
  },
  {
    "aliases": [
      ["lib", "makeScopeWithSplicing'"],
      ["lib", "customisation", "makeScopeWithSplicing'"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 33,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 116
        }
      },
      "lambdaDocs": {
        "content": "Like makeScope, but aims to support cross compilation. It's still ugly, but\nhopefully it helps a little bit.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/customisation.nix",
          "line": 306
        }
      }
    },
    "path": ["lib", "makeScopeWithSplicing'"]
  },
  {
    "aliases": [
      ["lib", "makeScopeWithSplicing"],
      ["lib", "customisation", "makeScopeWithSplicing"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 33,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 116
        }
      },
      "lambdaDocs": {
        "content": "backward compatibility with old uncurried form; deprecated",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/customisation.nix",
          "line": 296
        }
      }
    },
    "path": ["lib", "makeScopeWithSplicing"]
  },
  {
    "aliases": [
      ["lib", "makeScope"],
      ["lib", "customisation", "makeScope"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 33,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 116
        }
      },
      "lambdaDocs": {
        "content": "Make a set of packages with a common scope. All packages called\nwith the provided `callPackage` will be evaluated with the same\narguments. Any package in the set may depend on any other. The\n`overrideScope'` function allows subsequent modification of the package\nset in a consistent way, i.e. all packages in the set will be\ncalled with the overridden packages. The package sets may be\nhierarchical: the packages in the set are called with the scope\nprovided by `newScope` and the set provides a `newScope` attribute\nwhich can form the parent scope for later package sets.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 15,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/customisation.nix",
          "line": 279
        }
      }
    },
    "path": ["lib", "makeScope"]
  },
  {
    "aliases": [
      ["lib", "makeOverridable"],
      ["lib", "customisation", "makeOverridable"],
      ["pkgs", "makeOverridable"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 33,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 116
        }
      },
      "lambdaDocs": {
        "content": "`makeOverridable` takes a function from attribute set to attribute set and\ninjects `override` attribute which can be used to override arguments of\nthe function.\n\nnix-repl> x = {a, b}: { result = a + b; }\n\nnix-repl> y = lib.makeOverridable x { a = 1; b = 2; }\n\nnix-repl> y\n{ override = «lambda»; overrideDerivation = «lambda»; result = 3; }\n\nnix-repl> y.override { a = 10; }\n{ override = «lambda»; overrideDerivation = «lambda»; result = 12; }\n\nPlease refer to \"Nixpkgs Contributors Guide\" section\n\"<pkg>.overrideDerivation\" to learn about `overrideDerivation` and caveats\nrelated to its use.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/customisation.nix",
          "line": 74
        }
      }
    },
    "path": ["lib", "makeOverridable"]
  },
  {
    "aliases": [
      ["lib", "strings", "makeLibraryPath"],
      ["lib", "strings", "makeBinPath"],
      ["lib", "makeLibraryPath"],
      ["lib", "makeBinPath"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 264
        }
      }
    },
    "path": ["lib", "makeLibraryPath"]
  },
  {
    "aliases": [
      ["lib", "makeExtensibleWithCustomName"],
      ["lib", "fixedPoints", "makeExtensibleWithCustomName"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 31,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 80
        }
      },
      "lambdaDocs": {
        "content": "Same as `makeExtensible` but the name of the extending attribute is\ncustomized.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 34,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/fixed-points.nix",
          "line": 151
        }
      }
    },
    "path": ["lib", "makeExtensibleWithCustomName"]
  },
  {
    "aliases": [
      ["lib", "makeExtensible"],
      ["lib", "fixedPoints", "makeExtensible"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 31,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 80
        }
      },
      "lambdaDocs": {
        "content": "Same as `makeExtensible` but the name of the extending attribute is\ncustomized.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 48,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/fixed-points.nix",
          "line": 151
        }
      }
    },
    "path": ["lib", "makeExtensible"]
  },
  {
    "aliases": [
      ["lib", "strings", "makeLibraryPath"],
      ["lib", "strings", "makeBinPath"],
      ["lib", "makeLibraryPath"],
      ["lib", "makeBinPath"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 264
        }
      }
    },
    "path": ["lib", "makeBinPath"]
  },
  {
    "aliases": [
      ["lib", "meta", "lowPrioSet"],
      ["lib", "lowPrioSet"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 120
        }
      },
      "lambdaDocs": {
        "content": "Apply lowPrio to an attrset with derivations",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 16,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 77
        }
      }
    },
    "path": ["lib", "lowPrioSet"]
  },
  {
    "aliases": [
      ["lib", "meta", "lowPrio"],
      ["lib", "meta", "hiPrio"],
      ["lib", "lowPrio"],
      ["lib", "hiPrio"],
      ["pkgs", "lowPrio"],
      ["pkgs", "hiPrio"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 120
        }
      },
      "lambdaDocs": {
        "content": "Add to or override the meta attributes of the given\nderivation.\n\n# Example\n\n```nix\naddMetaAttrs {description = \"Bla blah\";} somePkg\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 21
        }
      }
    },
    "path": ["lib", "lowPrio"]
  },
  {
    "aliases": [
      ["lib", "options", "literalMD"],
      ["lib", "literalMD"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 140
        }
      },
      "lambdaDocs": {
        "content": "For use in the `defaultText` and `example` option attributes. Causes the\ngiven MD text to be inserted verbatim in the documentation, for when\na `literalExpression` would be too hard to read.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 15,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 404
        }
      }
    },
    "path": ["lib", "literalMD"]
  },
  {
    "aliases": [
      ["lib", "options", "literalExpression"],
      ["lib", "options", "literalExample"],
      ["lib", "literalExpression"],
      ["lib", "literalExample"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 140
        }
      },
      "lambdaDocs": {
        "content": "For use in the `defaultText` and `example` option attributes. Causes the\ngiven string to be rendered verbatim in the documentation as Nix code. This\nis necessary for complex values, e.g. functions, or values that depend on\nother values or packages.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 387
        }
      }
    },
    "path": ["lib", "literalExpression"]
  },
  {
    "aliases": [
      ["lib", "options", "literalExpression"],
      ["lib", "options", "literalExample"],
      ["lib", "literalExpression"],
      ["lib", "literalExample"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 140
        }
      },
      "lambdaDocs": {
        "content": "For use in the `defaultText` and `example` option attributes. Causes the\ngiven string to be rendered verbatim in the documentation as Nix code. This\nis necessary for complex values, e.g. functions, or values that depend on\nother values or packages.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/options.nix",
          "line": 387
        }
      }
    },
    "path": ["lib", "literalExample"]
  },
  {
    "aliases": [
      ["lib", "zipListsWith"],
      ["lib", "lists", "zipListsWith"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Merges two lists of the same size together. If the sizes aren't the same\nthe merging stops at the shortest. How both lists are merged is defined\nby the first argument.\n\n# Example\n\n```nix\nzipListsWith (a: b: a + b) [\"h\" \"l\"] [\"e\" \"o\"]\n=> [\"he\" \"lo\"]\n```\n\n# Type\n\n```\nzipListsWith :: (a -> b -> c) -> [a] -> [b] -> [c]\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 611
        }
      },
      "lambdaDocs": {
        "content": "Merges two lists of the same size together. If the sizes aren't the same\nthe merging stops at the shortest. How both lists are merged is defined\nby the first argument.\n\n# Example\n\n```nix\nzipListsWith (a: b: a + b) [\"h\" \"l\"] [\"e\" \"o\"]\n=> [\"he\" \"lo\"]\n```\n\n# Type\n\n```\nzipListsWith :: (a -> b -> c) -> [a] -> [b] -> [c]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 613
        }
      }
    },
    "path": ["lib", "lists", "zipListsWith"]
  },
  {
    "aliases": [
      ["lib", "zipLists"],
      ["lib", "lists", "zipLists"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Merges two lists of the same size together. If the sizes aren't the same\nthe merging stops at the shortest.\n\n# Example\n\n```nix\nzipLists [ 1 2 ] [ \"a\" \"b\" ]\n=> [ { fst = 1; snd = \"a\"; } { fst = 2; snd = \"b\"; } ]\n```\n\n# Type\n\n```\nzipLists :: [a] -> [b] -> [{ fst :: a; snd :: b; }]\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 638
        }
      },
      "lambdaDocs": {
        "content": "Merges two lists of the same size together. If the sizes aren't the same\nthe merging stops at the shortest. How both lists are merged is defined\nby the first argument.\n\n# Example\n\n```nix\nzipListsWith (a: b: a + b) [\"h\" \"l\"] [\"e\" \"o\"]\n=> [\"he\" \"lo\"]\n```\n\n# Type\n\n```\nzipListsWith :: (a -> b -> c) -> [a] -> [b] -> [c]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 615
        }
      }
    },
    "path": ["lib", "lists", "zipLists"]
  },
  {
    "aliases": [
      ["lib", "unique"],
      ["lib", "lists", "unique"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Remove duplicate elements from the list. O(n^2) complexity.\n\n# Example\n\n```nix\nunique [ 3 2 3 4 ]\n=> [ 3 2 4 ]\n```\n\n# Type\n\n```\nunique :: [a] -> [a]\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 1061
        }
      },
      "lambdaDocs": {
        "content": "Reduce a list by applying a binary operator, from left to right,\ne.g. `foldl' op nul [x0 x1 x2 ...] = op (op (op nul x0) x1) x2)\n...`. For example, `foldl' (x: y: x + y) 0 [1 2 3]` evaluates to 6.\nThe return value of each application of `op` is evaluated immediately,\neven for intermediate values.",
        "countApplied": 2,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "lists", "unique"]
  },
  {
    "aliases": [
      ["lib", "toposort"],
      ["lib", "lists", "toposort"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 722
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 722
        }
      }
    },
    "path": ["lib", "lists", "toposort"]
  },
  {
    "aliases": [
      ["lib", "toList"],
      ["lib", "lists", "toList"]
    ],
    "docs": {
      "attrDocs": {
        "content": "If argument is a list, return it; else, wrap it in a singleton\nlist.  If you're using this, you should almost certainly\nreconsider if there isn't a more \"well-typed\" approach.\n\n# Example\n\n```nix\ntoList [ 1 2 ]\n=> [ 1 2 ]\ntoList \"hi\"\n=> [ \"hi \"]\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 483
        }
      },
      "lambdaDocs": {
        "content": "If argument is a list, return it; else, wrap it in a singleton\nlist.  If you're using this, you should almost certainly\nreconsider if there isn't a more \"well-typed\" approach.\n\n# Example\n\n```nix\ntoList [ 1 2 ]\n=> [ 1 2 ]\ntoList \"hi\"\n=> [ \"hi \"]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 12,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 483
        }
      }
    },
    "path": ["lib", "lists", "toList"]
  },
  {
    "aliases": [
      ["lib", "take"],
      ["lib", "lists", "take"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Return the first (at most) N elements of a list.\n\n# Example\n\n```nix\ntake 2 [ \"a\" \"b\" \"c\" \"d\" ]\n=> [ \"a\" \"b\" ]\ntake 2 [ ]\n=> [ ]\n```\n\n# Type\n\n```\ntake :: int -> [a] -> [a]\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 840
        }
      },
      "lambdaDocs": {
        "content": "Return the first (at most) N elements of a list.\n\n# Example\n\n```nix\ntake 2 [ \"a\" \"b\" \"c\" \"d\" ]\n=> [ \"a\" \"b\" ]\ntake 2 [ ]\n=> [ ]\n```\n\n# Type\n\n```\ntake :: int -> [a] -> [a]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 842
        }
      }
    },
    "path": ["lib", "lists", "take"]
  },
  {
    "aliases": [
      ["lib", "tail"],
      ["lib", "strings", "tail"],
      ["lib", "lists", "tail"],
      ["builtins", "tail"],
      ["builtins", "tail"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 11
        }
      },
      "lambdaDocs": {
        "content": "Return the second to last elements of a list; abort evaluation if\nthe argument isn’t a list or is an empty list.\n\n> **Warning**\n>\n> This function should generally be avoided since it's inefficient:\n> unlike Haskell's `tail`, it takes O(n) time, so recursing over a\n> list by repeatedly calling `tail` takes O(n^2) time.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "lists", "tail"]
  },
  {
    "aliases": [
      ["lib", "subtractLists"],
      ["lib", "lists", "subtractLists"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Subtracts list 'e' from another list. O(nm) complexity.\n\n# Example\n\n```nix\nsubtractLists [ 3 2 ] [ 1 2 3 4 5 3 ]\n=> [ 1 4 5 ]\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 1085
        }
      },
      "lambdaDocs": {
        "content": "Subtracts list 'e' from another list. O(nm) complexity.\n\n# Example\n\n```nix\nsubtractLists [ 3 2 ] [ 1 2 3 4 5 3 ]\n=> [ 1 4 5 ]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 19,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 1085
        }
      }
    },
    "path": ["lib", "lists", "subtractLists"]
  },
  {
    "aliases": [
      ["lib", "sublist"],
      ["lib", "lists", "sublist"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Return a list consisting of at most `count` elements of `list`,\nstarting at index `start`.\n\n# Example\n\n```nix\nsublist 1 3 [ \"a\" \"b\" \"c\" \"d\" \"e\" ]\n=> [ \"b\" \"c\" \"d\" ]\nsublist 1 3 [ ]\n=> [ ]\n```\n\n# Type\n\n```\nsublist :: int -> int -> [a] -> [a]\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 937
        }
      },
      "lambdaDocs": {
        "content": "Return a list consisting of at most `count` elements of `list`,\nstarting at index `start`.\n\n# Example\n\n```nix\nsublist 1 3 [ \"a\" \"b\" \"c\" \"d\" \"e\" ]\n=> [ \"b\" \"c\" \"d\" ]\nsublist 1 3 [ ]\n=> [ ]\n```\n\n# Type\n\n```\nsublist :: int -> int -> [a] -> [a]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 939
        }
      }
    },
    "path": ["lib", "lists", "sublist"]
  },
  {
    "aliases": [
      ["lib", "sort"],
      ["lib", "lists", "sort"],
      ["builtins", "sort"],
      ["builtins", "sort"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Sort a list based on a comparator function which compares two\nelements and returns true if the first argument is strictly below\nthe second argument.  The returned list is sorted in an increasing\norder.  The implementation does a quick-sort.\n\n# Example\n\n```nix\nsort (a: b: a < b) [ 5 3 7 ]\n=> [ 3 5 7 ]\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 754
        }
      },
      "lambdaDocs": {
        "content": "Return *list* in sorted order. It repeatedly calls the function\n*comparator* with two elements. The comparator should return `true`\nif the first element is less than the second, and `false` otherwise.\nFor example,\n\n```nix\nbuiltins.sort builtins.lessThan [ 483 249 526 147 42 77 ]\n```\n\nproduces the list `[ 42 77 147 249 483 526 ]`.\n\nThis is a stable sort: it preserves the relative order of elements\ndeemed equal by the comparator.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "lists", "sort"]
  },
  {
    "aliases": [
      ["lib", "singleton"],
      ["lib", "lists", "singleton"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Create a list consisting of a single element.  `singleton x` is\nsometimes more convenient with respect to indentation than `[x]`\nwhen x spans multiple lines.\n\n# Example\n\n```nix\nsingleton \"foo\"\n=> [ \"foo\" ]\n```\n\n# Type\n\n```\nsingleton :: a -> [a]\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 31
        }
      },
      "lambdaDocs": {
        "content": "Create a list consisting of a single element.  `singleton x` is\nsometimes more convenient with respect to indentation than `[x]`\nwhen x spans multiple lines.\n\n# Example\n\n```nix\nsingleton \"foo\"\n=> [ \"foo\" ]\n```\n\n# Type\n\n```\nsingleton :: a -> [a]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 15,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 31
        }
      }
    },
    "path": ["lib", "lists", "singleton"]
  },
  {
    "aliases": [
      ["lib", "reverseList"],
      ["lib", "lists", "reverseList"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Reverse the order of the elements of a list.\n\n# Example\n\n```nix\nreverseList [ \"b\" \"o\" \"j\" ]\n=> [ \"j\" \"o\" \"b\" ]\n```\n\n# Type\n\n```\nreverseList :: [a] -> [a]\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 656
        }
      },
      "lambdaDocs": {
        "content": "Reverse the order of the elements of a list.\n\n# Example\n\n```nix\nreverseList [ \"b\" \"o\" \"j\" ]\n=> [ \"j\" \"o\" \"b\" ]\n```\n\n# Type\n\n```\nreverseList :: [a] -> [a]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 656
        }
      }
    },
    "path": ["lib", "lists", "reverseList"]
  },
  {
    "aliases": [
      ["lib", "replicate"],
      ["lib", "lists", "replicate"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Return a list with `n` copies of an element.\n\n# Example\n\n```nix\nreplicate 3 \"a\"\n=> [ \"a\" \"a\" \"a\" ]\nreplicate 2 true\n=> [ true true ]\n```\n\n# Type\n\n```\nreplicate :: int -> a -> [a]\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 531
        }
      },
      "lambdaDocs": {
        "content": "Return a list with `n` copies of an element.\n\n# Example\n\n```nix\nreplicate 3 \"a\"\n=> [ \"a\" \"a\" \"a\" ]\nreplicate 2 true\n=> [ true true ]\n```\n\n# Type\n\n```\nreplicate :: int -> a -> [a]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 15,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 531
        }
      }
    },
    "path": ["lib", "lists", "replicate"]
  },
  {
    "aliases": [["lib", "lists", "removePrefix"]],
    "docs": {
      "attrDocs": {
        "content": "Remove the first list as a prefix from the second list.\nError if the first list isn't a prefix of the second list.\n\n# Example\n\n```nix\nremovePrefix [ 1 2 ] [ 1 2 3 4 ]\n=> [ 3 4 ]\nremovePrefix [ 0 1 ] [ 1 2 3 4 ]\n=> <error>\n```\n\n# Type\n\n```\nremovePrefix :: [a] -> [a] -> [a]\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 910
        }
      },
      "lambdaDocs": {
        "content": "Remove the first list as a prefix from the second list.\nError if the first list isn't a prefix of the second list.\n\n# Example\n\n```nix\nremovePrefix [ 1 2 ] [ 1 2 3 4 ]\n=> [ 3 4 ]\nremovePrefix [ 0 1 ] [ 1 2 3 4 ]\n=> <error>\n```\n\n# Type\n\n```\nremovePrefix :: [a] -> [a] -> [a]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 911
        }
      }
    },
    "path": ["lib", "lists", "removePrefix"]
  },
  {
    "aliases": [
      ["lib", "remove"],
      ["lib", "lists", "remove"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Remove elements equal to 'e' from a list.  Useful for buildInputs.\n\n# Example\n\n```nix\nremove 3 [ 1 3 4 3 ]\n=> [ 1 4 ]\n```\n\n# Type\n\n```\nremove :: a -> [a] -> [a]\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 226
        }
      },
      "lambdaDocs": {
        "content": "Remove elements equal to 'e' from a list.  Useful for buildInputs.\n\n# Example\n\n```nix\nremove 3 [ 1 3 4 3 ]\n=> [ 1 4 ]\n```\n\n# Type\n\n```\nremove :: a -> [a] -> [a]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 228
        }
      }
    },
    "path": ["lib", "lists", "remove"]
  },
  {
    "aliases": [
      ["lib", "range"],
      ["lib", "lists", "range"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Return a list of integers from `first` up to and including `last`.\n\n# Example\n\n```nix\nrange 2 4\n=> [ 2 3 4 ]\nrange 3 2\n=> [ ]\n```\n\n# Type\n\n```\nrange :: int -> int -> [int]\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 503
        }
      },
      "lambdaDocs": {
        "content": "Return a list of integers from `first` up to and including `last`.\n\n# Example\n\n```nix\nrange 2 4\n=> [ 2 3 4 ]\nrange 3 2\n=> [ ]\n```\n\n# Type\n\n```\nrange :: int -> int -> [int]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 505
        }
      }
    },
    "path": ["lib", "lists", "range"]
  },
  {
    "aliases": [
      ["lib", "partition"],
      ["lib", "lists", "partition"],
      ["builtins", "partition"],
      ["builtins", "partition"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Splits the elements of a list in two lists, `right` and\n`wrong`, depending on the evaluation of a predicate.\n\n# Example\n\n```nix\npartition (x: x > 2) [ 5 1 2 3 4 ]\n=> { right = [ 5 3 4 ]; wrong = [ 1 2 ]; }\n```\n\n# Type\n\n```\n(a -> bool) -> [a] -> { right :: [a]; wrong :: [a]; }\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 550
        }
      },
      "lambdaDocs": {
        "content": "Given a predicate function *pred*, this function returns an\nattrset containing a list named `right`, containing the elements\nin *list* for which *pred* returned `true`, and a list named\n`wrong`, containing the elements for which it returned\n`false`. For example,\n\n```nix\nbuiltins.partition (x: x > 10) [1 23 9 3 42]\n```\n\nevaluates to\n\n```nix\n{ right = [ 23 42 ]; wrong = [ 1 9 3 ]; }\n```",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "lists", "partition"]
  },
  {
    "aliases": [
      ["lib", "optionals"],
      ["lib", "lists", "optionals"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Return a list or an empty list, depending on a boolean value.\n\n# Example\n\n```nix\noptionals true [ 2 3 ]\n=> [ 2 3 ]\noptionals false [ 2 3 ]\n=> [ ]\n```\n\n# Type\n\n```\noptionals :: bool -> [a] -> [a]\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 462
        }
      },
      "lambdaDocs": {
        "content": "Return a list or an empty list, depending on a boolean value.\n\n# Example\n\n```nix\noptionals true [ 2 3 ]\n=> [ 2 3 ]\noptionals false [ 2 3 ]\n=> [ ]\n```\n\n# Type\n\n```\noptionals :: bool -> [a] -> [a]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 464
        }
      }
    },
    "path": ["lib", "lists", "optionals"]
  },
  {
    "aliases": [
      ["lib", "optional"],
      ["lib", "lists", "optional"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Return a singleton list or an empty list, depending on a boolean\nvalue.  Useful when building lists with optional elements\n(e.g. `++ optional (system == \"i686-linux\") firefox`).\n\n# Example\n\n```nix\noptional true \"foo\"\n=> [ \"foo\" ]\noptional false \"foo\"\n=> [ ]\n```\n\n# Type\n\n```\noptional :: bool -> a -> [a]\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 442
        }
      },
      "lambdaDocs": {
        "content": "Return a singleton list or an empty list, depending on a boolean\nvalue.  Useful when building lists with optional elements\n(e.g. `++ optional (system == \"i686-linux\") firefox`).\n\n# Example\n\n```nix\noptional true \"foo\"\n=> [ \"foo\" ]\noptional false \"foo\"\n=> [ ]\n```\n\n# Type\n\n```\noptional :: bool -> a -> [a]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 442
        }
      }
    },
    "path": ["lib", "lists", "optional"]
  },
  {
    "aliases": [
      ["lib", "naturalSort"],
      ["lib", "lists", "naturalSort"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Sort list using \"Natural sorting\".\nNumeric portions of strings are sorted in numeric order.\n\n# Example\n\n```nix\nnaturalSort [\"disk11\" \"disk8\" \"disk100\" \"disk9\"]\n=> [\"disk8\" \"disk9\" \"disk11\" \"disk100\"]\nnaturalSort [\"10.46.133.149\" \"10.5.16.62\" \"10.54.16.25\"]\n=> [\"10.5.16.62\" \"10.46.133.149\" \"10.54.16.25\"]\nnaturalSort [\"v0.2\" \"v0.15\" \"v0.0.9\"]\n=> [ \"v0.0.9\" \"v0.2\" \"v0.15\" ]\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 814
        }
      },
      "lambdaDocs": {
        "content": "Sort list using \"Natural sorting\".\nNumeric portions of strings are sorted in numeric order.\n\n# Example\n\n```nix\nnaturalSort [\"disk11\" \"disk8\" \"disk100\" \"disk9\"]\n=> [\"disk8\" \"disk9\" \"disk11\" \"disk100\"]\nnaturalSort [\"10.46.133.149\" \"10.5.16.62\" \"10.54.16.25\"]\n=> [\"10.5.16.62\" \"10.46.133.149\" \"10.54.16.25\"]\nnaturalSort [\"v0.2\" \"v0.15\" \"v0.0.9\"]\n=> [ \"v0.0.9\" \"v0.2\" \"v0.15\" ]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 814
        }
      }
    },
    "path": ["lib", "lists", "naturalSort"]
  },
  {
    "aliases": [
      ["lib", "mutuallyExclusive"],
      ["lib", "lists", "mutuallyExclusive"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Test if two lists have no common element.\nIt should be slightly more efficient than (intersectLists a b == [])",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 1091
        }
      },
      "lambdaDocs": {
        "content": "Test if two lists have no common element.\nIt should be slightly more efficient than (intersectLists a b == [])",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 1091
        }
      }
    },
    "path": ["lib", "lists", "mutuallyExclusive"]
  },
  {
    "aliases": [
      ["lib", "lists", "map"],
      ["builtins", "map"],
      ["builtins", "map"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 11
        }
      },
      "lambdaDocs": {
        "content": "Apply the function *f* to each element in the list *list*. For\nexample,\n\n```nix\nmap (x: \"foo\" + x) [ \"bar\" \"bla\" \"abc\" ]\n```\n\nevaluates to `[ \"foobar\" \"foobla\" \"fooabc\" ]`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "lists", "map"]
  },
  {
    "aliases": [
      ["lib", "lists", "listDfs"],
      ["lib", "listDfs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 681
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 13,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 681
        }
      }
    },
    "path": ["lib", "lists", "listDfs"]
  },
  {
    "aliases": [
      ["lib", "lists", "length"],
      ["lib", "length"],
      ["builtins", "length"],
      ["builtins", "length"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 11
        }
      },
      "lambdaDocs": {
        "content": "Return the length of the list *e*.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "lists", "length"]
  },
  {
    "aliases": [
      ["lib", "lists", "last"],
      ["lib", "last"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Return the last element of a list.\n\nThis function throws an error if the list is empty.\n\n# Example\n\n```nix\nlast [ 1 2 3 ]\n=> 3\n```\n\n# Type\n\n```\nlast :: [a] -> a\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 1003
        }
      },
      "lambdaDocs": {
        "content": "Return the last element of a list.\n\nThis function throws an error if the list is empty.\n\n# Example\n\n```nix\nlast [ 1 2 3 ]\n=> 3\n```\n\n# Type\n\n```\nlast :: [a] -> a\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 1003
        }
      }
    },
    "path": ["lib", "lists", "last"]
  },
  {
    "aliases": [
      ["lib", "strings", "isList"],
      ["lib", "lists", "isList"],
      ["lib", "isList"],
      ["builtins", "isList"],
      ["builtins", "isList"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 11
        }
      },
      "lambdaDocs": {
        "content": "Return `true` if *e* evaluates to a list, and `false` otherwise.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "lists", "isList"]
  },
  {
    "aliases": [
      ["lib", "lists", "intersectLists"],
      ["lib", "intersectLists"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Intersects list 'e' and another list. O(nm) complexity.\n\n# Example\n\n```nix\nintersectLists [ 1 2 3 ] [ 6 3 2 ]\n=> [ 3 2 ]\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 1073
        }
      },
      "lambdaDocs": {
        "content": "Intersects list 'e' and another list. O(nm) complexity.\n\n# Example\n\n```nix\nintersectLists [ 1 2 3 ] [ 6 3 2 ]\n=> [ 3 2 ]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 20,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 1073
        }
      }
    },
    "path": ["lib", "lists", "intersectLists"]
  },
  {
    "aliases": [
      ["lib", "lists", "init"],
      ["lib", "init"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Return all elements but the last.\n\nThis function throws an error if the list is empty.\n\n# Example\n\n```nix\ninit [ 1 2 3 ]\n=> [ 1 2 ]\n```\n\n# Type\n\n```\ninit :: [a] -> [a]\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 1025
        }
      },
      "lambdaDocs": {
        "content": "Return all elements but the last.\n\nThis function throws an error if the list is empty.\n\n# Example\n\n```nix\ninit [ 1 2 3 ]\n=> [ 1 2 ]\n```\n\n# Type\n\n```\ninit :: [a] -> [a]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 1025
        }
      }
    },
    "path": ["lib", "lists", "init"]
  },
  {
    "aliases": [
      ["lib", "misc", "imap"],
      ["lib", "lists", "imap1"],
      ["lib", "imap1"],
      ["lib", "imap"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Map with index starting from 1\n\n# Example\n\n```nix\nimap1 (i: v: \"${v}-${toString i}\") [\"a\" \"b\"]\n=> [ \"a-1\" \"b-2\" ]\n```\n\n# Type\n\n```\nimap1 :: (int -> a -> b) -> [a] -> [b]\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 172
        }
      },
      "lambdaDocs": {
        "content": "Map with index starting from 1\n\n# Example\n\n```nix\nimap1 (i: v: \"${v}-${toString i}\") [\"a\" \"b\"]\n=> [ \"a-1\" \"b-2\" ]\n```\n\n# Type\n\n```\nimap1 :: (int -> a -> b) -> [a] -> [b]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 11,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 172
        }
      }
    },
    "path": ["lib", "lists", "imap1"]
  },
  {
    "aliases": [
      ["lib", "lists", "imap0"],
      ["lib", "imap0"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Map with index starting from 0\n\n# Example\n\n```nix\nimap0 (i: v: \"${v}-${toString i}\") [\"a\" \"b\"]\n=> [ \"a-0\" \"b-1\" ]\n```\n\n# Type\n\n```\nimap0 :: (int -> a -> b) -> [a] -> [b]\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 154
        }
      },
      "lambdaDocs": {
        "content": "Map with index starting from 0\n\n# Example\n\n```nix\nimap0 (i: v: \"${v}-${toString i}\") [\"a\" \"b\"]\n=> [ \"a-0\" \"b-1\" ]\n```\n\n# Type\n\n```\nimap0 :: (int -> a -> b) -> [a] -> [b]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 11,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 154
        }
      }
    },
    "path": ["lib", "lists", "imap0"]
  },
  {
    "aliases": [
      ["lib", "strings", "head"],
      ["lib", "lists", "head"],
      ["lib", "head"],
      ["builtins", "head"],
      ["builtins", "head"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 11
        }
      },
      "lambdaDocs": {
        "content": "Return the first element of a list; abort evaluation if the argument\nisn’t a list or is an empty list. You can test whether a list is\nempty by comparing it with `[]`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "lists", "head"]
  },
  {
    "aliases": [["lib", "lists", "hasPrefix"]],
    "docs": {
      "attrDocs": {
        "content": "Whether the first list is a prefix of the second list.\n\n# Example\n\n```nix\nhasPrefix [ 1 2 ] [ 1 2 3 4 ]\n=> true\nhasPrefix [ 0 1 ] [ 1 2 3 4 ]\n=> false\n```\n\n# Type\n\n```\nhasPrefix :: [a] -> [a] -> bool\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 886
        }
      },
      "lambdaDocs": {
        "content": "Whether the first list is a prefix of the second list.\n\n# Example\n\n```nix\nhasPrefix [ 1 2 ] [ 1 2 3 4 ]\n=> true\nhasPrefix [ 0 1 ] [ 1 2 3 4 ]\n=> false\n```\n\n# Type\n\n```\nhasPrefix :: [a] -> [a] -> bool\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 887
        }
      }
    },
    "path": ["lib", "lists", "hasPrefix"]
  },
  {
    "aliases": [
      ["lib", "lists", "groupBy'"],
      ["lib", "groupBy'"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Splits the elements of a list into many lists, using the return value of a predicate.\nPredicate should return a string which becomes keys of attrset `groupBy` returns.\n\n`groupBy'` allows to customise the combining function and initial value\n\n# Example\n\n```nix\ngroupBy (x: boolToString (x > 2)) [ 5 1 2 3 4 ]\n           => { true = [ 5 3 4 ]; false = [ 1 2 ]; }\n           groupBy (x: x.name) [ {name = \"icewm\"; script = \"icewm &\";}\n                                 {name = \"xfce\";  script = \"xfce4-session &\";}\n                                 {name = \"icewm\"; script = \"icewmbg &\";}\n                                 {name = \"mate\";  script = \"gnome-session &\";}\n                               ]\n           => { icewm = [ { name = \"icewm\"; script = \"icewm &\"; }\n                          { name = \"icewm\"; script = \"icewmbg &\"; } ];\n                mate  = [ { name = \"mate\";  script = \"gnome-session &\"; } ];\n                xfce  = [ { name = \"xfce\";  script = \"xfce4-session &\"; } ];\n              }\n\n           groupBy' builtins.add 0 (x: boolToString (x > 2)) [ 5 1 2 3 4 ]\n           => { true = 12; false = 3; }\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 583
        }
      },
      "lambdaDocs": {
        "content": "Splits the elements of a list into many lists, using the return value of a predicate.\nPredicate should return a string which becomes keys of attrset `groupBy` returns.\n\n`groupBy'` allows to customise the combining function and initial value\n\n# Example\n\n```nix\ngroupBy (x: boolToString (x > 2)) [ 5 1 2 3 4 ]\n           => { true = [ 5 3 4 ]; false = [ 1 2 ]; }\n           groupBy (x: x.name) [ {name = \"icewm\"; script = \"icewm &\";}\n                                 {name = \"xfce\";  script = \"xfce4-session &\";}\n                                 {name = \"icewm\"; script = \"icewmbg &\";}\n                                 {name = \"mate\";  script = \"gnome-session &\";}\n                               ]\n           => { icewm = [ { name = \"icewm\"; script = \"icewm &\"; }\n                          { name = \"icewm\"; script = \"icewmbg &\"; } ];\n                mate  = [ { name = \"mate\";  script = \"gnome-session &\"; } ];\n                xfce  = [ { name = \"xfce\";  script = \"xfce4-session &\"; } ];\n              }\n\n           groupBy' builtins.add 0 (x: boolToString (x > 2)) [ 5 1 2 3 4 ]\n           => { true = 12; false = 3; }\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 583
        }
      }
    },
    "path": ["lib", "lists", "groupBy'"]
  },
  {
    "aliases": [
      ["lib", "lists", "groupBy"],
      ["lib", "groupBy"],
      ["builtins", "groupBy"],
      ["builtins", "groupBy"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 585
        }
      },
      "lambdaDocs": {
        "content": "Groups elements of *list* together by the string returned from the\nfunction *f* called on each element. It returns an attribute set\nwhere each attribute value contains the elements of *list* that are\nmapped to the same corresponding attribute name returned by *f*.\n\nFor example,\n\n```nix\nbuiltins.groupBy (builtins.substring 0 1) [\"foo\" \"bar\" \"baz\"]\n```\n\nevaluates to\n\n```nix\n{ b = [ \"bar\" \"baz\" ]; f = [ \"foo\" ]; }\n```",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "lists", "groupBy"]
  },
  {
    "aliases": [
      ["lib", "strings", "genList"],
      ["lib", "lists", "genList"],
      ["lib", "genList"],
      ["builtins", "genList"],
      ["builtins", "genList"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 11
        }
      },
      "lambdaDocs": {
        "content": "Generate list of size *length*, with each element *i* equal to the\nvalue returned by *generator* `i`. For example,\n\n```nix\nbuiltins.genList (x: x * x) 5\n```\n\nreturns the list `[ 0 1 4 9 16 ]`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "lists", "genList"]
  },
  {
    "aliases": [
      ["lib", "lists", "forEach"],
      ["lib", "forEach"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Apply the function to each element in the list. Same as `map`, but arguments\nflipped.\n\n# Example\n\n```nix\nforEach [ 1 2 ] (x:\n  toString x\n)\n=> [ \"1\" \"2\" ]\n```\n\n# Type\n\n```\nforEach :: [a] -> (a -> b) -> [b]\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 52
        }
      },
      "lambdaDocs": {
        "content": "Apply the function to each element in the list. Same as `map`, but arguments\nflipped.\n\n# Example\n\n```nix\nforEach [ 1 2 ] (x:\n  toString x\n)\n=> [ \"1\" \"2\" ]\n```\n\n# Type\n\n```\nforEach :: [a] -> (a -> b) -> [b]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 13,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 52
        }
      }
    },
    "path": ["lib", "lists", "forEach"]
  },
  {
    "aliases": [
      ["lib", "lists", "foldr"],
      ["lib", "lists", "fold"],
      ["lib", "foldr"],
      ["lib", "fold"]
    ],
    "docs": {
      "attrDocs": {
        "content": "“right fold” a binary function `op` between successive elements of\n`list` with `nul` as the starting value, i.e.,\n`foldr op nul [x_1 x_2 ... x_n] == op x_1 (op x_2 ... (op x_n nul))`.\n\n# Example\n\n```nix\nconcat = foldr (a: b: a + b) \"z\"\nconcat [ \"a\" \"b\" \"c\" ]\n=> \"abcz\"\n# different types\nstrange = foldr (int: str: toString (int + 1) + str) \"a\"\nstrange [ 1 2 3 4 ]\n=> \"2345a\"\n```\n\n# Type\n\n```\nfoldr :: (a -> b -> b) -> b -> [a] -> b\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 77
        }
      },
      "lambdaDocs": {
        "content": "“right fold” a binary function `op` between successive elements of\n`list` with `nul` as the starting value, i.e.,\n`foldr op nul [x_1 x_2 ... x_n] == op x_1 (op x_2 ... (op x_n nul))`.\n\n# Example\n\n```nix\nconcat = foldr (a: b: a + b) \"z\"\nconcat [ \"a\" \"b\" \"c\" ]\n=> \"abcz\"\n# different types\nstrange = foldr (int: str: toString (int + 1) + str) \"a\"\nstrange [ 1 2 3 4 ]\n=> \"2345a\"\n```\n\n# Type\n\n```\nfoldr :: (a -> b -> b) -> b -> [a] -> b\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 11,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 77
        }
      }
    },
    "path": ["lib", "lists", "foldr"]
  },
  {
    "aliases": [
      ["lib", "lists", "foldl'"],
      ["lib", "foldl'"],
      ["builtins", "foldl'"],
      ["builtins", "foldl'"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Strict version of `foldl`.\n\nThe difference is that evaluation is forced upon access. Usually used\nwith small whole results (in contrast with lazily-generated list or large\nlists where only a part is consumed.)\n\n# Type\n\n```\nfoldl' :: (b -> a -> b) -> b -> [a] -> b\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 136
        }
      },
      "lambdaDocs": {
        "content": "Reduce a list by applying a binary operator, from left to right,\ne.g. `foldl' op nul [x0 x1 x2 ...] = op (op (op nul x0) x1) x2)\n...`. For example, `foldl' (x: y: x + y) 0 [1 2 3]` evaluates to 6.\nThe return value of each application of `op` is evaluated immediately,\neven for intermediate values.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "lists", "foldl'"]
  },
  {
    "aliases": [
      ["lib", "lists", "foldl"],
      ["lib", "foldl"]
    ],
    "docs": {
      "attrDocs": {
        "content": "“left fold”, like `foldr`, but from the left:\n`foldl op nul [x_1 x_2 ... x_n] == op (... (op (op nul x_1) x_2) ... x_n)`.\n\n# Example\n\n```nix\nlconcat = foldl (a: b: a + b) \"z\"\nlconcat [ \"a\" \"b\" \"c\" ]\n=> \"zabc\"\n# different types\nlstrange = foldl (str: int: str + toString (int + 1)) \"a\"\nlstrange [ 1 2 3 4 ]\n=> \"a2345\"\n```\n\n# Type\n\n```\nfoldl :: (b -> a -> b) -> b -> [a] -> b\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 115
        }
      },
      "lambdaDocs": {
        "content": "“left fold”, like `foldr`, but from the left:\n`foldl op nul [x_1 x_2 ... x_n] == op (... (op (op nul x_1) x_2) ... x_n)`.\n\n# Example\n\n```nix\nlconcat = foldl (a: b: a + b) \"z\"\nlconcat [ \"a\" \"b\" \"c\" ]\n=> \"zabc\"\n# different types\nlstrange = foldl (str: int: str + toString (int + 1)) \"a\"\nlstrange [ 1 2 3 4 ]\n=> \"a2345\"\n```\n\n# Type\n\n```\nfoldl :: (b -> a -> b) -> b -> [a] -> b\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 11,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 115
        }
      }
    },
    "path": ["lib", "lists", "foldl"]
  },
  {
    "aliases": [
      ["lib", "lists", "foldr"],
      ["lib", "lists", "fold"],
      ["lib", "foldr"],
      ["lib", "fold"]
    ],
    "docs": {
      "attrDocs": {
        "content": "`fold` is an alias of `foldr` for historic reasons",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 90
        }
      },
      "lambdaDocs": {
        "content": "“right fold” a binary function `op` between successive elements of\n`list` with `nul` as the starting value, i.e.,\n`foldr op nul [x_1 x_2 ... x_n] == op x_1 (op x_2 ... (op x_n nul))`.\n\n# Example\n\n```nix\nconcat = foldr (a: b: a + b) \"z\"\nconcat [ \"a\" \"b\" \"c\" ]\n=> \"abcz\"\n# different types\nstrange = foldr (int: str: toString (int + 1) + str) \"a\"\nstrange [ 1 2 3 4 ]\n=> \"2345a\"\n```\n\n# Type\n\n```\nfoldr :: (a -> b -> b) -> b -> [a] -> b\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 11,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 77
        }
      }
    },
    "path": ["lib", "lists", "fold"]
  },
  {
    "aliases": [
      ["lib", "lists", "flatten"],
      ["lib", "flatten"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Flatten the argument into a single list; that is, nested lists are\nspliced into the top-level lists.\n\n# Example\n\n```nix\nflatten [1 [2 [3] 4] 5]\n=> [1 2 3 4 5]\nflatten 1\n=> [1]\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 205
        }
      },
      "lambdaDocs": {
        "content": "Flatten the argument into a single list; that is, nested lists are\nspliced into the top-level lists.\n\n# Example\n\n```nix\nflatten [1 [2 [3] 4] 5]\n=> [1 2 3 4 5]\nflatten 1\n=> [1]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 13,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 205
        }
      }
    },
    "path": ["lib", "lists", "flatten"]
  },
  {
    "aliases": [
      ["lib", "lists", "findSingle"],
      ["lib", "findSingle"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Find the sole element in the list matching the specified\npredicate, returns `default` if no such element exists, or\n`multiple` if there are multiple matching elements.\n\n# Example\n\n```nix\nfindSingle (x: x == 3) \"none\" \"multiple\" [ 1 3 3 ]\n=> \"multiple\"\nfindSingle (x: x == 3) \"none\" \"multiple\" [ 1 3 ]\n=> 3\nfindSingle (x: x == 3) \"none\" \"multiple\" [ 1 9 ]\n=> \"none\"\n```\n\n# Type\n\n```\nfindSingle :: (a -> bool) -> a -> a -> [a] -> a\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 252
        }
      },
      "lambdaDocs": {
        "content": "Find the sole element in the list matching the specified\npredicate, returns `default` if no such element exists, or\n`multiple` if there are multiple matching elements.\n\n# Example\n\n```nix\nfindSingle (x: x == 3) \"none\" \"multiple\" [ 1 3 3 ]\n=> \"multiple\"\nfindSingle (x: x == 3) \"none\" \"multiple\" [ 1 3 ]\n=> 3\nfindSingle (x: x == 3) \"none\" \"multiple\" [ 1 9 ]\n=> \"none\"\n```\n\n# Type\n\n```\nfindSingle :: (a -> bool) -> a -> a -> [a] -> a\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 254
        }
      }
    },
    "path": ["lib", "lists", "findSingle"]
  },
  {
    "aliases": [["lib", "lists", "findFirstIndex"]],
    "docs": {
      "attrDocs": {
        "content": "Find the first index in the list matching the specified\npredicate or return `default` if no such element exists.\n\n# Example\n\n```nix\nfindFirstIndex (x: x > 3) null [ 0 6 4 ]\n=> 1\nfindFirstIndex (x: x > 9) null [ 0 6 4 ]\n=> null\n```\n\n# Type\n\n```\nfindFirstIndex :: (a -> Bool) -> b -> [a] -> (Int | b)\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 285
        }
      },
      "lambdaDocs": {
        "content": "Find the first index in the list matching the specified\npredicate or return `default` if no such element exists.\n\n# Example\n\n```nix\nfindFirstIndex (x: x > 3) null [ 0 6 4 ]\n=> 1\nfindFirstIndex (x: x > 9) null [ 0 6 4 ]\n=> null\n```\n\n# Type\n\n```\nfindFirstIndex :: (a -> Bool) -> b -> [a] -> (Int | b)\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 287
        }
      }
    },
    "path": ["lib", "lists", "findFirstIndex"]
  },
  {
    "aliases": [
      ["lib", "lists", "findFirst"],
      ["lib", "findFirst"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Find the first element in the list matching the specified\npredicate or return `default` if no such element exists.\n\n# Example\n\n```nix\nfindFirst (x: x > 3) 7 [ 1 6 4 ]\n=> 6\nfindFirst (x: x > 9) 7 [ 1 6 4 ]\n=> 7\n```\n\n# Type\n\n```\nfindFirst :: (a -> bool) -> a -> [a] -> a\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 344
        }
      },
      "lambdaDocs": {
        "content": "Find the first element in the list matching the specified\npredicate or return `default` if no such element exists.\n\n# Example\n\n```nix\nfindFirst (x: x > 3) 7 [ 1 6 4 ]\n=> 6\nfindFirst (x: x > 9) 7 [ 1 6 4 ]\n=> 7\n```\n\n# Type\n\n```\nfindFirst :: (a -> bool) -> a -> [a] -> a\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 346
        }
      }
    },
    "path": ["lib", "lists", "findFirst"]
  },
  {
    "aliases": [
      ["lib", "strings", "filter"],
      ["lib", "lists", "filter"],
      ["lib", "filter"],
      ["builtins", "filter"],
      ["builtins", "filter"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 11
        }
      },
      "lambdaDocs": {
        "content": "Return a list consisting of the elements of *list* for which the\nfunction *f* returns `true`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "lists", "filter"]
  },
  {
    "aliases": [
      ["lib", "strings", "elemAt"],
      ["lib", "lists", "elemAt"],
      ["lib", "elemAt"],
      ["builtins", "elemAt"],
      ["builtins", "elemAt"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 11
        }
      },
      "lambdaDocs": {
        "content": "Return element *n* from the list *xs*. Elements are counted starting\nfrom 0. A fatal error occurs if the index is out of bounds.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "lists", "elemAt"]
  },
  {
    "aliases": [
      ["lib", "strings", "elem"],
      ["lib", "lists", "elem"],
      ["lib", "elem"],
      ["builtins", "elem"],
      ["builtins", "elem"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 11
        }
      },
      "lambdaDocs": {
        "content": "Return `true` if a value equal to *x* occurs in the list *xs*, and\n`false` otherwise.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "lists", "elem"]
  },
  {
    "aliases": [
      ["lib", "lists", "drop"],
      ["lib", "drop"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Remove the first (at most) N elements of a list.\n\n# Example\n\n```nix\ndrop 2 [ \"a\" \"b\" \"c\" \"d\" ]\n=> [ \"c\" \"d\" ]\ndrop 2 [ ]\n=> [ ]\n```\n\n# Type\n\n```\ndrop :: int -> [a] -> [a]\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 862
        }
      },
      "lambdaDocs": {
        "content": "Remove the first (at most) N elements of a list.\n\n# Example\n\n```nix\ndrop 2 [ \"a\" \"b\" \"c\" \"d\" ]\n=> [ \"c\" \"d\" ]\ndrop 2 [ ]\n=> [ ]\n```\n\n# Type\n\n```\ndrop :: int -> [a] -> [a]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 864
        }
      }
    },
    "path": ["lib", "lists", "drop"]
  },
  {
    "aliases": [
      ["lib", "lists", "crossLists"],
      ["lib", "crossLists"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Return the image of the cross product of some lists by a function.\n\n# Example\n\n```nix\ncrossLists (x:y: \"${toString x}${toString y}\") [[1 2] [3 4]]\n=> [ \"13\" \"14\" \"23\" \"24\" ]\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 1040
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 6,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 1042
        }
      }
    },
    "path": ["lib", "lists", "crossLists"]
  },
  {
    "aliases": [
      ["lib", "lists", "count"],
      ["lib", "count"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Count how many elements of `list` match the supplied predicate\nfunction.\n\n# Example\n\n```nix\ncount (x: x == 3) [ 3 2 3 4 6 ]\n=> 2\n```\n\n# Type\n\n```\ncount :: (a -> bool) -> [a] -> int\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 418
        }
      },
      "lambdaDocs": {
        "content": "Count how many elements of `list` match the supplied predicate\nfunction.\n\n# Example\n\n```nix\ncount (x: x == 3) [ 3 2 3 4 6 ]\n=> 2\n```\n\n# Type\n\n```\ncount :: (a -> bool) -> [a] -> int\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 420
        }
      }
    },
    "path": ["lib", "lists", "count"]
  },
  {
    "aliases": [
      ["lib", "lists", "concatMap"],
      ["lib", "concatMap"],
      ["builtins", "concatMap"],
      ["builtins", "concatMap"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Map and concatenate the result.\n\n# Example\n\n```nix\nconcatMap (x: [x] ++ [\"z\"]) [\"a\" \"b\"]\n=> [ \"a\" \"z\" \"b\" \"z\" ]\n```\n\n# Type\n\n```\nconcatMap :: (a -> [b]) -> [a] -> [b]\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 190
        }
      },
      "lambdaDocs": {
        "content": "This function is equivalent to `builtins.concatLists (map f list)`\nbut is more efficient.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "lists", "concatMap"]
  },
  {
    "aliases": [
      ["lib", "lists", "concatLists"],
      ["lib", "concatLists"],
      ["builtins", "concatLists"],
      ["builtins", "concatLists"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 11
        }
      },
      "lambdaDocs": {
        "content": "Concatenate a list of lists into a single list.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "lists", "concatLists"]
  },
  {
    "aliases": [
      ["lib", "lists", "compareLists"],
      ["lib", "compareLists"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Compare two lists element-by-element.\n\n# Example\n\n```nix\ncompareLists compare [] []\n=> 0\ncompareLists compare [] [ \"a\" ]\n=> -1\ncompareLists compare [ \"a\" ] []\n=> 1\ncompareLists compare [ \"a\" \"b\" ] [ \"a\" \"c\" ]\n=> -1\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 787
        }
      },
      "lambdaDocs": {
        "content": "Compare two lists element-by-element.\n\n# Example\n\n```nix\ncompareLists compare [] []\n=> 0\ncompareLists compare [] [ \"a\" ]\n=> -1\ncompareLists compare [ \"a\" ] []\n=> 1\ncompareLists compare [ \"a\" \"b\" ] [ \"a\" \"c\" ]\n=> -1\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 18,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 787
        }
      }
    },
    "path": ["lib", "lists", "compareLists"]
  },
  {
    "aliases": [["lib", "lists", "commonPrefix"]],
    "docs": {
      "attrDocs": {
        "content": "The common prefix of two lists.\n\n# Example\n\n```nix\ncommonPrefix [ 1 2 3 4 5 6 ] [ 1 2 4 8 ]\n=> [ 1 2 ]\ncommonPrefix [ 1 2 3 ] [ 1 2 3 4 5 ]\n=> [ 1 2 3 ]\ncommonPrefix [ 1 2 3 ] [ 4 5 6 ]\n=> [ ]\n```\n\n# Type\n\n```\ncommonPrefix :: [a] -> [a] -> [a]\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 971
        }
      },
      "lambdaDocs": {
        "content": "The common prefix of two lists.\n\n# Example\n\n```nix\ncommonPrefix [ 1 2 3 4 5 6 ] [ 1 2 4 8 ]\n=> [ 1 2 ]\ncommonPrefix [ 1 2 3 ] [ 1 2 3 4 5 ]\n=> [ 1 2 3 ]\ncommonPrefix [ 1 2 3 ] [ 4 5 6 ]\n=> [ ]\n```\n\n# Type\n\n```\ncommonPrefix :: [a] -> [a] -> [a]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 972
        }
      }
    },
    "path": ["lib", "lists", "commonPrefix"]
  },
  {
    "aliases": [
      ["lib", "lists", "any"],
      ["lib", "any"],
      ["builtins", "any"],
      ["builtins", "any"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Return true if function `pred` returns true for at least one\nelement of `list`.\n\n# Example\n\n```nix\nany isString [ 1 \"a\" { } ]\n=> true\nany isString [ 1 { } ]\n=> false\n```\n\n# Type\n\n```\nany :: (a -> bool) -> [a] -> bool\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 378
        }
      },
      "lambdaDocs": {
        "content": "Return `true` if the function *pred* returns `true` for at least one\nelement of *list*, and `false` otherwise.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "lists", "any"]
  },
  {
    "aliases": [
      ["lib", "lists", "all"],
      ["lib", "all"],
      ["builtins", "all"],
      ["builtins", "all"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Return true if function `pred` returns true for all elements of\n`list`.\n\n# Example\n\n```nix\nall (x: x < 3) [ 1 2 ]\n=> true\nall (x: x < 3) [ 1 2 3 ]\n=> false\n```\n\n# Type\n\n```\nall :: (a -> bool) -> [a] -> bool\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 399
        }
      },
      "lambdaDocs": {
        "content": "Return `true` if the function *pred* returns `true` for all elements\nof *list*, and `false` otherwise.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "lists", "all"]
  },
  {
    "aliases": [
      ["lib", "listToAttrs"],
      ["lib", "attrsets", "listToAttrs"],
      ["builtins", "listToAttrs"],
      ["builtins", "listToAttrs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 68
        }
      },
      "lambdaDocs": {
        "content": "Construct a set from a list specifying the names and values of each\nattribute. Each element of the list should be a set consisting of a\nstring-valued attribute `name` specifying the name of the attribute,\nand an attribute `value` specifying its value.\n\nIn case of duplicate occurrences of the same name, the first\ntakes precedence.\n\nExample:\n\n```nix\nbuiltins.listToAttrs\n  [ { name = \"foo\"; value = 123; }\n    { name = \"bar\"; value = 456; }\n    { name = \"bar\"; value = 420; }\n  ]\n```\n\nevaluates to\n\n```nix\n{ foo = 123; bar = 456; }\n```",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "listToAttrs"]
  },
  {
    "aliases": [
      ["lib", "lists", "listDfs"],
      ["lib", "listDfs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 92
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 13,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 681
        }
      }
    },
    "path": ["lib", "listDfs"]
  },
  {
    "aliases": [
      ["lib", "trivial", "lessThan"],
      ["lib", "lessThan"],
      ["builtins", "lessThan"],
      ["builtins", "lessThan"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 68
        }
      },
      "lambdaDocs": {
        "content": "Return `true` if the number *e1* is less than the number *e2*, and\n`false` otherwise. Evaluation aborts if either *e1* or *e2* does not\nevaluate to a number.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "lessThan"]
  },
  {
    "aliases": [
      ["lib", "lists", "length"],
      ["lib", "length"],
      ["builtins", "length"],
      ["builtins", "length"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 68
        }
      },
      "lambdaDocs": {
        "content": "Return the length of the list *e*.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "length"]
  },
  {
    "aliases": [
      ["lib", "misc", "lazyGenericClosure"],
      ["lib", "lazyGenericClosure"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 156
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 124
        }
      }
    },
    "path": ["lib", "lazyGenericClosure"]
  },
  {
    "aliases": [
      ["lib", "lazyDerivation"],
      ["lib", "derivations", "lazyDerivation"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 31,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 119
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/derivations.nix",
          "line": 53
        }
      }
    },
    "path": ["lib", "lazyDerivation"]
  },
  {
    "aliases": [
      ["lib", "lists", "last"],
      ["lib", "last"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 92
        }
      },
      "lambdaDocs": {
        "content": "Return the last element of a list.\n\nThis function throws an error if the list is empty.\n\n# Example\n\n```nix\nlast [ 1 2 3 ]\n=> 3\n```\n\n# Type\n\n```\nlast :: [a] -> a\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 1003
        }
      }
    },
    "path": ["lib", "last"]
  },
  {
    "aliases": [["lib", "kernel", "whenHelpers"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/kernel.nix",
          "line": 20
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/kernel.nix",
          "line": 20
        }
      }
    },
    "path": ["lib", "kernel", "whenHelpers"]
  },
  {
    "aliases": [["lib", "kernel", "option"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/kernel.nix",
          "line": 8
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 12,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/kernel.nix",
          "line": 8
        }
      }
    },
    "path": ["lib", "kernel", "option"]
  },
  {
    "aliases": [["lib", "kernel", "freeform"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/kernel.nix",
          "line": 15
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/kernel.nix",
          "line": 15
        }
      }
    },
    "path": ["lib", "kernel", "freeform"]
  },
  {
    "aliases": [
      ["lib", "strings", "isValidPosixName"],
      ["lib", "isValidPosixName"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "Test whether the given name is a valid POSIX shell variable name.\n\n# Example\n\n```nix\nisValidPosixName \"foo_bar000\"\n=> true\nisValidPosixName \"0-bad.jpg\"\n=> false\n```\n\n# Type\n\n```\nstring -> bool\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 22,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 651
        }
      }
    },
    "path": ["lib", "isValidPosixName"]
  },
  {
    "aliases": [
      ["lib", "types", "isType"],
      ["lib", "isType"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 148
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 12,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 70
        }
      }
    },
    "path": ["lib", "isType"]
  },
  {
    "aliases": [
      ["lib", "strings", "isStringLike"],
      ["lib", "isStringLike"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "Check whether a value can be coerced to a string.\nThe value must be a string, path, or attribute set.\n\nString-like values can be used without explicit conversion in\nstring interpolations and in most functions that expect a string.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 18,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1284
        }
      }
    },
    "path": ["lib", "isStringLike"]
  },
  {
    "aliases": [
      ["lib", "strings", "isString"],
      ["lib", "isString"],
      ["builtins", "isString"],
      ["builtins", "isString"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 68
        }
      },
      "lambdaDocs": {
        "content": "Return `true` if *e* evaluates to a string, and `false` otherwise.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "isString"]
  },
  {
    "aliases": [
      ["lib", "strings", "isStorePath"],
      ["lib", "isStorePath"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1306
        }
      }
    },
    "path": ["lib", "isStorePath"]
  },
  {
    "aliases": [
      ["lib", "strings", "isPath"],
      ["lib", "isPath"],
      ["builtins", "isPath"],
      ["builtins", "isPath"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 68
        }
      },
      "lambdaDocs": {
        "content": "Return `true` if *e* evaluates to a path, and `false` otherwise.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "isPath"]
  },
  {
    "aliases": [
      ["lib", "types", "isOptionType"],
      ["lib", "options", "isOption"],
      ["lib", "isOptionType"],
      ["lib", "isOption"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 148
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 18,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 70
        }
      }
    },
    "path": ["lib", "isOptionType"]
  },
  {
    "aliases": [
      ["lib", "types", "isOptionType"],
      ["lib", "options", "isOption"],
      ["lib", "isOptionType"],
      ["lib", "isOption"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 140
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 18,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 70
        }
      }
    },
    "path": ["lib", "isOption"]
  },
  {
    "aliases": [
      ["lib", "strings", "isList"],
      ["lib", "lists", "isList"],
      ["lib", "isList"],
      ["builtins", "isList"],
      ["builtins", "isList"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 68
        }
      },
      "lambdaDocs": {
        "content": "Return `true` if *e* evaluates to a list, and `false` otherwise.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "isList"]
  },
  {
    "aliases": [
      ["lib", "trivial", "isInt"],
      ["lib", "strings", "isInt"],
      ["lib", "isInt"],
      ["builtins", "isInt"],
      ["builtins", "isInt"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 68
        }
      },
      "lambdaDocs": {
        "content": "Return `true` if *e* evaluates to an integer, and `false` otherwise.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "isInt"]
  },
  {
    "aliases": [
      ["lib", "trivial", "isInOldestRelease"],
      ["lib", "isInOldestRelease"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 73
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 263
        }
      }
    },
    "path": ["lib", "isInOldestRelease"]
  },
  {
    "aliases": [
      ["lib", "trivial", "isFunction"],
      ["lib", "isFunction"],
      ["builtins", "isFunction"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 73
        }
      },
      "lambdaDocs": {
        "content": "Check whether something is a function or something\nannotated with function args.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 16,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 598
        }
      }
    },
    "path": ["lib", "isFunction"]
  },
  {
    "aliases": [
      ["lib", "trivial", "isFloat"],
      ["lib", "isFloat"],
      ["builtins", "isFloat"],
      ["builtins", "isFloat"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 73
        }
      },
      "lambdaDocs": {
        "content": "Return `true` if *e* evaluates to a float, and `false` otherwise.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "isFloat"]
  },
  {
    "aliases": [
      ["lib", "isDerivation"],
      ["lib", "attrsets", "isDerivation"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "Check whether the argument is a derivation. Any set with\n`{ type = \"derivation\"; }` counts as a derivation.\n\n# Example\n\n```nix\nnixpkgs = import <nixpkgs> {}\nisDerivation nixpkgs.ruby\n=> true\nisDerivation \"foobar\"\n=> false\n```\n\n# Type\n\n```\nisDerivation :: Any -> Bool\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 806
        }
      }
    },
    "path": ["lib", "isDerivation"]
  },
  {
    "aliases": [
      ["lib", "trivial", "isBool"],
      ["lib", "isBool"],
      ["builtins", "isBool"],
      ["builtins", "isBool"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 68
        }
      },
      "lambdaDocs": {
        "content": "Return `true` if *e* evaluates to a bool, and `false` otherwise.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "isBool"]
  },
  {
    "aliases": [
      ["lib", "strings", "isAttrs"],
      ["lib", "isAttrs"],
      ["lib", "attrsets", "isAttrs"],
      ["builtins", "isAttrs"],
      ["builtins", "isAttrs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 68
        }
      },
      "lambdaDocs": {
        "content": "Return `true` if *e* evaluates to a set, and `false` otherwise.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "isAttrs"]
  },
  {
    "aliases": [
      ["lib", "strings", "intersperse"],
      ["lib", "intersperse"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 117
        }
      }
    },
    "path": ["lib", "intersperse"]
  },
  {
    "aliases": [
      ["lib", "lists", "intersectLists"],
      ["lib", "intersectLists"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 92
        }
      },
      "lambdaDocs": {
        "content": "Intersects list 'e' and another list. O(nm) complexity.\n\n# Example\n\n```nix\nintersectLists [ 1 2 3 ] [ 6 3 2 ]\n=> [ 3 2 ]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 20,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 1073
        }
      }
    },
    "path": ["lib", "intersectLists"]
  },
  {
    "aliases": [
      ["lib", "misc", "innerModifySumArgs"],
      ["lib", "innerModifySumArgs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 156
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 138
        }
      }
    },
    "path": ["lib", "innerModifySumArgs"]
  },
  {
    "aliases": [
      ["lib", "misc", "innerClosePropagation"],
      ["lib", "innerClosePropagation"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 156
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 143
        }
      }
    },
    "path": ["lib", "innerClosePropagation"]
  },
  {
    "aliases": [
      ["lib", "lists", "init"],
      ["lib", "init"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 92
        }
      },
      "lambdaDocs": {
        "content": "Return all elements but the last.\n\nThis function throws an error if the list is empty.\n\n# Example\n\n```nix\ninit [ 1 2 3 ]\n=> [ 1 2 ]\n```\n\n# Type\n\n```\ninit :: [a] -> [a]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 1025
        }
      }
    },
    "path": ["lib", "init"]
  },
  {
    "aliases": [
      ["lib", "trivial", "info"],
      ["lib", "info"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 73
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 559
        }
      }
    },
    "path": ["lib", "info"]
  },
  {
    "aliases": [
      ["lib", "trivial", "importTOML"],
      ["lib", "importTOML"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 73
        }
      },
      "lambdaDocs": {
        "content": "Reads a TOML file.\n\n# Type\n\n```\nimportTOML :: path -> any\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 16,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 437
        }
      }
    },
    "path": ["lib", "importTOML"]
  },
  {
    "aliases": [
      ["lib", "trivial", "importJSON"],
      ["lib", "importJSON"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 73
        }
      },
      "lambdaDocs": {
        "content": "Reads a JSON file.\n\n# Type\n\n```\nimportJSON :: path -> any\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 16,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 425
        }
      }
    },
    "path": ["lib", "importJSON"]
  },
  {
    "aliases": [
      ["lib", "misc", "imap"],
      ["lib", "lists", "imap1"],
      ["lib", "imap1"],
      ["lib", "imap"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 92
        }
      },
      "lambdaDocs": {
        "content": "Map with index starting from 1\n\n# Example\n\n```nix\nimap1 (i: v: \"${v}-${toString i}\") [\"a\" \"b\"]\n=> [ \"a-1\" \"b-2\" ]\n```\n\n# Type\n\n```\nimap1 :: (int -> a -> b) -> [a] -> [b]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 11,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 172
        }
      }
    },
    "path": ["lib", "imap1"]
  },
  {
    "aliases": [
      ["lib", "lists", "imap0"],
      ["lib", "imap0"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 92
        }
      },
      "lambdaDocs": {
        "content": "Map with index starting from 0\n\n# Example\n\n```nix\nimap0 (i: v: \"${v}-${toString i}\") [\"a\" \"b\"]\n=> [ \"a-0\" \"b-1\" ]\n```\n\n# Type\n\n```\nimap0 :: (int -> a -> b) -> [a] -> [b]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 11,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 154
        }
      }
    },
    "path": ["lib", "imap0"]
  },
  {
    "aliases": [
      ["lib", "misc", "imap"],
      ["lib", "lists", "imap1"],
      ["lib", "imap1"],
      ["lib", "imap"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 156
        }
      },
      "lambdaDocs": {
        "content": "Map with index starting from 1\n\n# Example\n\n```nix\nimap1 (i: v: \"${v}-${toString i}\") [\"a\" \"b\"]\n=> [ \"a-1\" \"b-2\" ]\n```\n\n# Type\n\n```\nimap1 :: (int -> a -> b) -> [a] -> [b]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 11,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 172
        }
      }
    },
    "path": ["lib", "imap"]
  },
  {
    "aliases": [
      ["lib", "misc", "ifEnable"],
      ["lib", "ifEnable"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 156
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 47
        }
      }
    },
    "path": ["lib", "ifEnable"]
  },
  {
    "aliases": [
      ["lib", "trivial", "id"],
      ["lib", "options", "mdDoc"],
      ["lib", "modules", "mkFixStrictness"],
      ["lib", "mkFixStrictness"],
      ["lib", "mdDoc"],
      ["lib", "id"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 73
        }
      },
      "lambdaDocs": {
        "content": "The identity function\nFor when you need a function that does “nothing”.\n\n# Type\n\n```\nid :: a -> a\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 19
        }
      }
    },
    "path": ["lib", "id"]
  },
  {
    "aliases": [
      ["lib", "hydraJob"],
      ["lib", "customisation", "hydraJob"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 33,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 116
        }
      },
      "lambdaDocs": {
        "content": "Strip a derivation of all non-essential attributes, returning\nonly those needed by hydra-eval-jobs. Also strictly evaluate the\nresult to ensure that there are no thunks kept alive to prevent\ngarbage collection.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/customisation.nix",
          "line": 239
        }
      }
    },
    "path": ["lib", "hydraJob"]
  },
  {
    "aliases": [
      ["lib", "meta", "hiPrioSet"],
      ["lib", "hiPrioSet"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 120
        }
      },
      "lambdaDocs": {
        "content": "Apply hiPrio to an attrset with derivations",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 15,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 89
        }
      }
    },
    "path": ["lib", "hiPrioSet"]
  },
  {
    "aliases": [
      ["lib", "meta", "lowPrio"],
      ["lib", "meta", "hiPrio"],
      ["lib", "lowPrio"],
      ["lib", "hiPrio"],
      ["pkgs", "lowPrio"],
      ["pkgs", "hiPrio"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 120
        }
      },
      "lambdaDocs": {
        "content": "Add to or override the meta attributes of the given\nderivation.\n\n# Example\n\n```nix\naddMetaAttrs {description = \"Bla blah\";} somePkg\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 21
        }
      }
    },
    "path": ["lib", "hiPrio"]
  },
  {
    "aliases": [
      ["lib", "strings", "head"],
      ["lib", "lists", "head"],
      ["lib", "head"],
      ["builtins", "head"],
      ["builtins", "head"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 68
        }
      },
      "lambdaDocs": {
        "content": "Return the first element of a list; abort evaluation if the argument\nisn’t a list or is an empty list. You can test whether a list is\nempty by comparing it with `[]`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "head"]
  },
  {
    "aliases": [
      ["lib", "strings", "hasSuffix"],
      ["lib", "hasSuffix"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "Determine whether a string has given suffix.\n\n# Example\n\n```nix\nhasSuffix \"foo\" \"foobar\"\n=> false\nhasSuffix \"foo\" \"barfoo\"\n=> true\n```\n\n# Type\n\n```\nhasSuffix :: string -> string -> bool\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 406
        }
      }
    },
    "path": ["lib", "hasSuffix"]
  },
  {
    "aliases": [
      ["lib", "strings", "hasPrefix"],
      ["lib", "hasPrefix"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "Determine whether a string has given prefix.\n\n# Example\n\n```nix\nhasPrefix \"foo\" \"foobar\"\n=> true\nhasPrefix \"foo\" \"barfoo\"\n=> false\n```\n\n# Type\n\n```\nhasPrefix :: string -> string -> bool\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 371
        }
      }
    },
    "path": ["lib", "hasPrefix"]
  },
  {
    "aliases": [
      ["lib", "strings", "hasInfix"],
      ["lib", "hasInfix"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "Determine whether a string contains the given infix\n\n# Example\n\n```nix\nhasInfix \"bc\" \"abcd\"\n=> true\nhasInfix \"ab\" \"abcd\"\n=> true\nhasInfix \"cd\" \"abcd\"\n=> true\nhasInfix \"foo\" \"abcd\"\n=> false\n```\n\n# Type\n\n```\nhasInfix :: string -> string -> bool\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 449
        }
      }
    },
    "path": ["lib", "hasInfix"]
  },
  {
    "aliases": [
      ["lib", "hasAttrByPath"],
      ["lib", "attrsets", "hasAttrByPath"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "Return if an attribute from nested attribute set exists.\n\n# Example\n\n```nix\nx = { a = { b = 3; }; }\nhasAttrByPath [\"a\" \"b\"] x\n=> true\nhasAttrByPath [\"z\" \"z\"] x\n=> false\n```\n\n# Type\n\n```\nhasAttrByPath :: [String] -> AttrSet -> Bool\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 71
        }
      }
    },
    "path": ["lib", "hasAttrByPath"]
  },
  {
    "aliases": [
      ["lib", "hasAttr"],
      ["lib", "attrsets", "hasAttr"],
      ["builtins", "hasAttr"],
      ["builtins", "hasAttr"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 68
        }
      },
      "lambdaDocs": {
        "content": "`hasAttr` returns `true` if *set* has an attribute named *s*, and\n`false` otherwise. This is a dynamic version of the `?` operator,\nsince *s* is an expression rather than an identifier.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "hasAttr"]
  },
  {
    "aliases": [["lib", "gvariant", "mkVariant"]],
    "docs": {
      "attrDocs": {
        "content": "Returns the GVariant variant from the given Nix value. Variants are containers\nof different GVariant type.\n\n# Example\n\n```nix\nlib.gvariant.mkArray [\n  (lib.gvariant.mkVariant \"a string\")\n  (lib.gvariant.mkVariant (lib.gvariant.mkInt32 1))\n]\n```\n\n# Type\n\n```\nmkVariant :: Any -> gvariant\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/gvariant.nix",
          "line": 152
        }
      },
      "lambdaDocs": {
        "content": "Returns the GVariant variant from the given Nix value. Variants are containers\nof different GVariant type.\n\n# Example\n\n```nix\nlib.gvariant.mkArray [\n  (lib.gvariant.mkVariant \"a string\")\n  (lib.gvariant.mkVariant (lib.gvariant.mkInt32 1))\n]\n```\n\n# Type\n\n```\nmkVariant :: Any -> gvariant\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 15,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/gvariant.nix",
          "line": 152
        }
      }
    },
    "path": ["lib", "gvariant", "mkVariant"]
  },
  {
    "aliases": [["lib", "gvariant", "mkValue"]],
    "docs": {
      "attrDocs": {
        "content": "Returns the GVariant value that most closely matches the given Nix value.\nIf no GVariant value can be found unambiguously then error is thrown.\n\n# Type\n\n```\nmkValue :: Any -> gvariant\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/gvariant.nix",
          "line": 70
        }
      },
      "lambdaDocs": {
        "content": "Returns the GVariant value that most closely matches the given Nix value.\nIf no GVariant value can be found unambiguously then error is thrown.\n\n# Type\n\n```\nmkValue :: Any -> gvariant\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 13,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/gvariant.nix",
          "line": 70
        }
      }
    },
    "path": ["lib", "gvariant", "mkValue"]
  },
  {
    "aliases": [
      ["lib", "gvariant", "mkUint64"],
      ["lib", "gvariant", "mkUint32"],
      ["lib", "gvariant", "mkUint16"],
      ["lib", "gvariant", "mkUchar"],
      ["lib", "gvariant", "mkInt64"],
      ["lib", "gvariant", "mkInt16"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Returns the GVariant uint64 from the given Nix int value.\n\n# Type\n\n```\nmkUint64 :: Int -> gvariant\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/gvariant.nix",
          "line": 372
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 20,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/gvariant.nix",
          "line": 19
        }
      }
    },
    "path": ["lib", "gvariant", "mkUint64"]
  },
  {
    "aliases": [
      ["lib", "gvariant", "mkUint64"],
      ["lib", "gvariant", "mkUint32"],
      ["lib", "gvariant", "mkUint16"],
      ["lib", "gvariant", "mkUchar"],
      ["lib", "gvariant", "mkInt64"],
      ["lib", "gvariant", "mkInt16"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Returns the GVariant uint32 from the given Nix int value.\n\n# Type\n\n```\nmkUint32 :: Int -> gvariant\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/gvariant.nix",
          "line": 350
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 20,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/gvariant.nix",
          "line": 19
        }
      }
    },
    "path": ["lib", "gvariant", "mkUint32"]
  },
  {
    "aliases": [
      ["lib", "gvariant", "mkUint64"],
      ["lib", "gvariant", "mkUint32"],
      ["lib", "gvariant", "mkUint16"],
      ["lib", "gvariant", "mkUchar"],
      ["lib", "gvariant", "mkInt64"],
      ["lib", "gvariant", "mkInt16"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Returns the GVariant uint16 from the given Nix int value.\n\n# Type\n\n```\nmkUint16 :: Int -> gvariant\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/gvariant.nix",
          "line": 325
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 20,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/gvariant.nix",
          "line": 19
        }
      }
    },
    "path": ["lib", "gvariant", "mkUint16"]
  },
  {
    "aliases": [
      ["lib", "gvariant", "mkUint64"],
      ["lib", "gvariant", "mkUint32"],
      ["lib", "gvariant", "mkUint16"],
      ["lib", "gvariant", "mkUchar"],
      ["lib", "gvariant", "mkInt64"],
      ["lib", "gvariant", "mkInt16"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Returns the GVariant uchar from the given Nix int value.\n\n# Type\n\n```\nmkUchar :: Int -> gvariant\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/gvariant.nix",
          "line": 303
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 20,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/gvariant.nix",
          "line": 19
        }
      }
    },
    "path": ["lib", "gvariant", "mkUchar"]
  },
  {
    "aliases": [["lib", "gvariant", "mkTuple"]],
    "docs": {
      "attrDocs": {
        "content": "Returns the GVariant tuple from the given Nix list.\n\n# Type\n\n```\nmkTuple :: [Any] -> gvariant\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/gvariant.nix",
          "line": 241
        }
      },
      "lambdaDocs": {
        "content": "Returns the GVariant tuple from the given Nix list.\n\n# Type\n\n```\nmkTuple :: [Any] -> gvariant\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 13,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/gvariant.nix",
          "line": 241
        }
      }
    },
    "path": ["lib", "gvariant", "mkTuple"]
  },
  {
    "aliases": [["lib", "gvariant", "mkString"]],
    "docs": {
      "attrDocs": {
        "content": "Returns the GVariant string from the given Nix string value.\n\n# Type\n\n```\nmkString :: String -> gvariant\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/gvariant.nix",
          "line": 274
        }
      },
      "lambdaDocs": {
        "content": "Returns the GVariant string from the given Nix string value.\n\n# Type\n\n```\nmkString :: String -> gvariant\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/gvariant.nix",
          "line": 274
        }
      }
    },
    "path": ["lib", "gvariant", "mkString"]
  },
  {
    "aliases": [["lib", "gvariant", "mkObjectpath"]],
    "docs": {
      "attrDocs": {
        "content": "Returns the GVariant object path from the given Nix string value.\n\n# Type\n\n```\nmkObjectpath :: String -> gvariant\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/gvariant.nix",
          "line": 289
        }
      },
      "lambdaDocs": {
        "content": "Returns the GVariant object path from the given Nix string value.\n\n# Type\n\n```\nmkObjectpath :: String -> gvariant\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 18,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/gvariant.nix",
          "line": 289
        }
      }
    },
    "path": ["lib", "gvariant", "mkObjectpath"]
  },
  {
    "aliases": [["lib", "gvariant", "mkNothing"]],
    "docs": {
      "attrDocs": {
        "content": "Returns the GVariant nothing from the given element type.\n\n# Type\n\n```\nmkNothing :: gvariant.type -> gvariant\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/gvariant.nix",
          "line": 219
        }
      },
      "lambdaDocs": {
        "content": "Returns the GVariant nothing from the given element type.\n\n# Type\n\n```\nmkNothing :: gvariant.type -> gvariant\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 15,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/gvariant.nix",
          "line": 219
        }
      }
    },
    "path": ["lib", "gvariant", "mkNothing"]
  },
  {
    "aliases": [["lib", "gvariant", "mkMaybe"]],
    "docs": {
      "attrDocs": {
        "content": "Returns the GVariant maybe from the given element type.\n\n# Type\n\n```\nmkMaybe :: gvariant.type -> Any -> gvariant\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/gvariant.nix",
          "line": 201
        }
      },
      "lambdaDocs": {
        "content": "Returns the GVariant maybe from the given element type.\n\n# Type\n\n```\nmkMaybe :: gvariant.type -> Any -> gvariant\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 13,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/gvariant.nix",
          "line": 201
        }
      }
    },
    "path": ["lib", "gvariant", "mkMaybe"]
  },
  {
    "aliases": [["lib", "gvariant", "mkJust"]],
    "docs": {
      "attrDocs": {
        "content": "Returns the GVariant just from the given Nix value.\n\n# Type\n\n```\nmkJust :: Any -> gvariant\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/gvariant.nix",
          "line": 230
        }
      },
      "lambdaDocs": {
        "content": "Returns the GVariant just from the given Nix value.\n\n# Type\n\n```\nmkJust :: Any -> gvariant\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 12,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/gvariant.nix",
          "line": 230
        }
      }
    },
    "path": ["lib", "gvariant", "mkJust"]
  },
  {
    "aliases": [
      ["lib", "gvariant", "mkUint64"],
      ["lib", "gvariant", "mkUint32"],
      ["lib", "gvariant", "mkUint16"],
      ["lib", "gvariant", "mkUchar"],
      ["lib", "gvariant", "mkInt64"],
      ["lib", "gvariant", "mkInt16"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Returns the GVariant int64 from the given Nix int value.\n\n# Type\n\n```\nmkInt64 :: Int -> gvariant\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/gvariant.nix",
          "line": 361
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 20,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/gvariant.nix",
          "line": 19
        }
      }
    },
    "path": ["lib", "gvariant", "mkInt64"]
  },
  {
    "aliases": [["lib", "gvariant", "mkInt32"]],
    "docs": {
      "attrDocs": {
        "content": "Returns the GVariant int32 from the given Nix int value.\n\n# Type\n\n```\nmkInt32 :: Int -> gvariant\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/gvariant.nix",
          "line": 336
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 13,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/gvariant.nix",
          "line": 336
        }
      }
    },
    "path": ["lib", "gvariant", "mkInt32"]
  },
  {
    "aliases": [
      ["lib", "gvariant", "mkUint64"],
      ["lib", "gvariant", "mkUint32"],
      ["lib", "gvariant", "mkUint16"],
      ["lib", "gvariant", "mkUchar"],
      ["lib", "gvariant", "mkInt64"],
      ["lib", "gvariant", "mkInt16"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Returns the GVariant int16 from the given Nix int value.\n\n# Type\n\n```\nmkInt16 :: Int -> gvariant\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/gvariant.nix",
          "line": 314
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 20,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/gvariant.nix",
          "line": 19
        }
      }
    },
    "path": ["lib", "gvariant", "mkInt16"]
  },
  {
    "aliases": [["lib", "gvariant", "mkEmptyArray"]],
    "docs": {
      "attrDocs": {
        "content": "Returns the GVariant array from the given empty Nix list.\n\n# Example\n\n```nix\n# Creating an empty string array\nlib.gvariant.mkEmptyArray (lib.gvariant.type.string)\n```\n\n# Type\n\n```\nmkEmptyArray :: gvariant.type -> gvariant\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/gvariant.nix",
          "line": 128
        }
      },
      "lambdaDocs": {
        "content": "Returns the GVariant array from the given empty Nix list.\n\n# Example\n\n```nix\n# Creating an empty string array\nlib.gvariant.mkEmptyArray (lib.gvariant.type.string)\n```\n\n# Type\n\n```\nmkEmptyArray :: gvariant.type -> gvariant\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 18,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/gvariant.nix",
          "line": 128
        }
      }
    },
    "path": ["lib", "gvariant", "mkEmptyArray"]
  },
  {
    "aliases": [["lib", "gvariant", "mkDouble"]],
    "docs": {
      "attrDocs": {
        "content": "Returns the GVariant double from the given Nix float value.\n\n# Type\n\n```\nmkDouble :: Float -> gvariant\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/gvariant.nix",
          "line": 383
        }
      },
      "lambdaDocs": {
        "content": "Returns the GVariant double from the given Nix float value.\n\n# Type\n\n```\nmkDouble :: Float -> gvariant\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/gvariant.nix",
          "line": 383
        }
      }
    },
    "path": ["lib", "gvariant", "mkDouble"]
  },
  {
    "aliases": [["lib", "gvariant", "mkDictionaryEntry"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/gvariant.nix",
          "line": 178
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/gvariant.nix",
          "line": 180
        }
      }
    },
    "path": ["lib", "gvariant", "mkDictionaryEntry"]
  },
  {
    "aliases": [["lib", "gvariant", "mkBoolean"]],
    "docs": {
      "attrDocs": {
        "content": "Returns the GVariant boolean from the given Nix bool value.\n\n# Type\n\n```\nmkBoolean :: Bool -> gvariant\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/gvariant.nix",
          "line": 260
        }
      },
      "lambdaDocs": {
        "content": "Returns the GVariant boolean from the given Nix bool value.\n\n# Type\n\n```\nmkBoolean :: Bool -> gvariant\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 15,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/gvariant.nix",
          "line": 260
        }
      }
    },
    "path": ["lib", "gvariant", "mkBoolean"]
  },
  {
    "aliases": [["lib", "gvariant", "mkArray"]],
    "docs": {
      "attrDocs": {
        "content": "Returns the GVariant array from the given type of the elements and a Nix list.\n\n# Example\n\n```nix\n# Creating a string array\nlib.gvariant.mkArray [ \"a\" \"b\" \"c\" ]\n```\n\n# Type\n\n```\nmkArray :: [Any] -> gvariant\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/gvariant.nix",
          "line": 100
        }
      },
      "lambdaDocs": {
        "content": "Returns the GVariant array from the given type of the elements and a Nix list.\n\n# Example\n\n```nix\n# Creating a string array\nlib.gvariant.mkArray [ \"a\" \"b\" \"c\" ]\n```\n\n# Type\n\n```\nmkArray :: [Any] -> gvariant\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 13,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/gvariant.nix",
          "line": 100
        }
      }
    },
    "path": ["lib", "gvariant", "mkArray"]
  },
  {
    "aliases": [["lib", "gvariant", "isGVariant"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/gvariant.nix",
          "line": 58
        }
      },
      "lambdaDocs": {
        "content": "Check if a value is a GVariant value\n\n# Type\n\n```\nisGVariant :: Any -> Bool\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 16,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/gvariant.nix",
          "line": 53
        }
      }
    },
    "path": ["lib", "gvariant", "isGVariant"]
  },
  {
    "aliases": [
      ["lib", "lists", "groupBy'"],
      ["lib", "groupBy'"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 92
        }
      },
      "lambdaDocs": {
        "content": "Splits the elements of a list into many lists, using the return value of a predicate.\nPredicate should return a string which becomes keys of attrset `groupBy` returns.\n\n`groupBy'` allows to customise the combining function and initial value\n\n# Example\n\n```nix\ngroupBy (x: boolToString (x > 2)) [ 5 1 2 3 4 ]\n           => { true = [ 5 3 4 ]; false = [ 1 2 ]; }\n           groupBy (x: x.name) [ {name = \"icewm\"; script = \"icewm &\";}\n                                 {name = \"xfce\";  script = \"xfce4-session &\";}\n                                 {name = \"icewm\"; script = \"icewmbg &\";}\n                                 {name = \"mate\";  script = \"gnome-session &\";}\n                               ]\n           => { icewm = [ { name = \"icewm\"; script = \"icewm &\"; }\n                          { name = \"icewm\"; script = \"icewmbg &\"; } ];\n                mate  = [ { name = \"mate\";  script = \"gnome-session &\"; } ];\n                xfce  = [ { name = \"xfce\";  script = \"xfce4-session &\"; } ];\n              }\n\n           groupBy' builtins.add 0 (x: boolToString (x > 2)) [ 5 1 2 3 4 ]\n           => { true = 12; false = 3; }\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 583
        }
      }
    },
    "path": ["lib", "groupBy'"]
  },
  {
    "aliases": [
      ["lib", "lists", "groupBy"],
      ["lib", "groupBy"],
      ["builtins", "groupBy"],
      ["builtins", "groupBy"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 92
        }
      },
      "lambdaDocs": {
        "content": "Groups elements of *list* together by the string returned from the\nfunction *f* called on each element. It returns an attribute set\nwhere each attribute value contains the elements of *list* that are\nmapped to the same corresponding attribute name returned by *f*.\n\nFor example,\n\n```nix\nbuiltins.groupBy (builtins.substring 0 1) [\"foo\" \"bar\" \"baz\"]\n```\n\nevaluates to\n\n```nix\n{ b = [ \"bar\" \"baz\" ]; f = [ \"foo\" ]; }\n```",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "groupBy"]
  },
  {
    "aliases": [
      ["lib", "strings", "getVersion"],
      ["lib", "getVersion"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "This function takes an argument that's either a derivation or a\nderivation's \"name\" attribute and extracts the version part from that\nargument.\n\n# Example\n\n```nix\ngetVersion \"youtube-dl-2016.01.01\"\n=> \"2016.01.01\"\ngetVersion pkgs.youtube-dl\n=> \"2016.01.01\"\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 16,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1025
        }
      }
    },
    "path": ["lib", "getVersion"]
  },
  {
    "aliases": [
      ["lib", "options", "getValues"],
      ["lib", "options", "getFiles"],
      ["lib", "getValues"],
      ["lib", "getFiles"],
      ["pkgs", "copyPathsToStore"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 140
        }
      },
      "lambdaDocs": {
        "content": "Apply the function *f* to each element in the list *list*. For\nexample,\n\n```nix\nmap (x: \"foo\" + x) [ \"bar\" \"bla\" \"abc\" ]\n```\n\nevaluates to `[ \"foobar\" \"foobla\" \"fooabc\" ]`.",
        "countApplied": 1,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "getValues"]
  },
  {
    "aliases": [
      ["lib", "misc", "getValue"],
      ["lib", "getValue"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 156
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 66
        }
      }
    },
    "path": ["lib", "getValue"]
  },
  {
    "aliases": [
      ["lib", "getOutput"],
      ["lib", "attrsets", "getOutput"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 15,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1178
        }
      }
    },
    "path": ["lib", "getOutput"]
  },
  {
    "aliases": [
      ["lib", "strings", "getName"],
      ["lib", "getName"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "This function takes an argument that's either a derivation or a\nderivation's \"name\" attribute and extracts the name part from that\nargument.\n\n# Example\n\n```nix\ngetName \"youtube-dl-2016.01.01\"\n=> \"youtube-dl\"\ngetName pkgs.youtube-dl\n=> \"youtube-dl\"\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 13,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1004
        }
      }
    },
    "path": ["lib", "getName"]
  },
  {
    "aliases": [
      ["lib", "getMan"],
      ["lib", "getLib"],
      ["lib", "getDev"],
      ["lib", "getBin"],
      ["lib", "attrsets", "getMan"],
      ["lib", "attrsets", "getLib"],
      ["lib", "attrsets", "getDev"],
      ["lib", "attrsets", "getBin"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1178
        }
      }
    },
    "path": ["lib", "getMan"]
  },
  {
    "aliases": [
      ["lib", "meta", "getLicenseFromSpdxId"],
      ["lib", "getLicenseFromSpdxId"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 120
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 8,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 158
        }
      }
    },
    "path": ["lib", "getLicenseFromSpdxId"]
  },
  {
    "aliases": [
      ["lib", "getMan"],
      ["lib", "getLib"],
      ["lib", "getDev"],
      ["lib", "getBin"],
      ["lib", "attrsets", "getMan"],
      ["lib", "attrsets", "getLib"],
      ["lib", "attrsets", "getDev"],
      ["lib", "attrsets", "getBin"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1178
        }
      }
    },
    "path": ["lib", "getLib"]
  },
  {
    "aliases": [
      ["lib", "options", "getValues"],
      ["lib", "options", "getFiles"],
      ["lib", "getValues"],
      ["lib", "getFiles"],
      ["pkgs", "copyPathsToStore"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 140
        }
      },
      "lambdaDocs": {
        "content": "Apply the function *f* to each element in the list *list*. For\nexample,\n\n```nix\nmap (x: \"foo\" + x) [ \"bar\" \"bla\" \"abc\" ]\n```\n\nevaluates to `[ \"foobar\" \"foobla\" \"fooabc\" ]`.",
        "countApplied": 1,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "getFiles"]
  },
  {
    "aliases": [
      ["lib", "meta", "getExe'"],
      ["lib", "getExe'"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 120
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 13,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 211
        }
      }
    },
    "path": ["lib", "getExe'"]
  },
  {
    "aliases": [
      ["lib", "meta", "getExe"],
      ["lib", "getExe"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 120
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 12,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 182
        }
      }
    },
    "path": ["lib", "getExe"]
  },
  {
    "aliases": [
      ["lib", "getMan"],
      ["lib", "getLib"],
      ["lib", "getDev"],
      ["lib", "getBin"],
      ["lib", "attrsets", "getMan"],
      ["lib", "attrsets", "getLib"],
      ["lib", "attrsets", "getDev"],
      ["lib", "attrsets", "getBin"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1178
        }
      }
    },
    "path": ["lib", "getDev"]
  },
  {
    "aliases": [
      ["lib", "getMan"],
      ["lib", "getLib"],
      ["lib", "getDev"],
      ["lib", "getBin"],
      ["lib", "attrsets", "getMan"],
      ["lib", "attrsets", "getLib"],
      ["lib", "attrsets", "getDev"],
      ["lib", "attrsets", "getBin"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1178
        }
      }
    },
    "path": ["lib", "getBin"]
  },
  {
    "aliases": [
      ["lib", "getAttrs"],
      ["lib", "attrsets", "getAttrs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "Given a set of attribute names, return the set of the corresponding\nattributes from the given set.\n\n# Example\n\n```nix\ngetAttrs [ \"a\" \"b\" ] { a = 1; b = 2; c = 3; }\n=> { a = 1; b = 2; }\n```\n\n# Type\n\n```\ngetAttrs :: [String] -> AttrSet -> AttrSet\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 340
        }
      }
    },
    "path": ["lib", "getAttrs"]
  },
  {
    "aliases": [
      ["lib", "getAttrFromPath"],
      ["lib", "attrsets", "getAttrFromPath"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "Like `attrByPath`, but without a default value. If it doesn't find the\npath it will throw an error.\n\n# Example\n\n```nix\nx = { a = { b = 3; }; }\ngetAttrFromPath [\"a\" \"b\"] x\n=> 3\ngetAttrFromPath [\"z\" \"z\"] x\n=> error: cannot find attribute `z.z'\n```\n\n# Type\n\n```\ngetAttrFromPath :: [String] -> AttrSet -> Any\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 133
        }
      }
    },
    "path": ["lib", "getAttrFromPath"]
  },
  {
    "aliases": [
      ["lib", "getAttr"],
      ["lib", "attrsets", "getAttr"],
      ["builtins", "getAttr"],
      ["builtins", "getAttr"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 68
        }
      },
      "lambdaDocs": {
        "content": "`getAttr` returns the attribute named *s* from *set*. Evaluation\naborts if the attribute doesn’t exist. This is a dynamic version of\nthe `.` operator, since *s* is an expression rather than an\nidentifier.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "getAttr"]
  },
  {
    "aliases": [
      ["lib", "trivial", "genericClosure"],
      ["lib", "genericClosure"],
      ["builtins", "genericClosure"],
      ["builtins", "genericClosure"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 68
        }
      },
      "lambdaDocs": {
        "content": "Take an *attrset* with values named `startSet` and `operator` in order to\nreturn a *list of attrsets* by starting with the `startSet` and recursively\napplying the `operator` function to each `item`. The *attrsets* in the\n`startSet` and the *attrsets* produced by `operator` must contain a value\nnamed `key` which is comparable. The result is produced by calling `operator`\nfor each `item` with a value for `key` that has not been called yet including\nnewly produced `item`s. The function terminates when no new `item`s are\nproduced. The resulting *list of attrsets* contains only *attrsets* with a\nunique key. For example,\n\n```\nbuiltins.genericClosure {\n  startSet = [ {key = 5;} ];\n  operator = item: [{\n    key = if (item.key / 2 ) * 2 == item.key\n         then item.key / 2\n         else 3 * item.key + 1;\n  }];\n}\n```\nevaluates to\n```\n[ { key = 5; } { key = 16; } { key = 8; } { key = 4; } { key = 2; } { key = 1; } ]\n```",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "genericClosure"]
  },
  {
    "aliases": [["lib", "generators", "withRecursion"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/generators.nix",
          "line": 271
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/generators.nix",
          "line": 272
        }
      }
    },
    "path": ["lib", "generators", "withRecursion"]
  },
  {
    "aliases": [
      ["lib", "generators", "toYAML"],
      ["lib", "generators", "toJSON"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/generators.nix",
          "line": 269
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 12,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/generators.nix",
          "line": 260
        }
      }
    },
    "path": ["lib", "generators", "toYAML"]
  },
  {
    "aliases": [["lib", "generators", "toPretty"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/generators.nix",
          "line": 317
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/generators.nix",
          "line": 317
        }
      }
    },
    "path": ["lib", "generators", "toPretty"]
  },
  {
    "aliases": [["lib", "generators", "toPlist"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/generators.nix",
          "line": 393
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 13,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/generators.nix",
          "line": 393
        }
      }
    },
    "path": ["lib", "generators", "toPlist"]
  },
  {
    "aliases": [["lib", "generators", "toLua"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/generators.nix",
          "line": 510
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 11,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/generators.nix",
          "line": 510
        }
      }
    },
    "path": ["lib", "generators", "toLua"]
  },
  {
    "aliases": [["lib", "generators", "toKeyValue"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/generators.nix",
          "line": 86
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 16,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/generators.nix",
          "line": 86
        }
      }
    },
    "path": ["lib", "generators", "toKeyValue"]
  },
  {
    "aliases": [
      ["lib", "generators", "toYAML"],
      ["lib", "generators", "toJSON"],
      ["builtins", "toJSON"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/generators.nix",
          "line": 260
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 12,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/generators.nix",
          "line": 260
        }
      }
    },
    "path": ["lib", "generators", "toJSON"]
  },
  {
    "aliases": [["lib", "generators", "toINIWithGlobalSection"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/generators.nix",
          "line": 171
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/generators.nix",
          "line": 171
        }
      }
    },
    "path": ["lib", "generators", "toINIWithGlobalSection"]
  },
  {
    "aliases": [["lib", "generators", "toINI"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/generators.nix",
          "line": 119
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 11,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/generators.nix",
          "line": 119
        }
      }
    },
    "path": ["lib", "generators", "toINI"]
  },
  {
    "aliases": [["lib", "generators", "toGitINI"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/generators.nix",
          "line": 204
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/generators.nix",
          "line": 204
        }
      }
    },
    "path": ["lib", "generators", "toGitINI"]
  },
  {
    "aliases": [["lib", "generators", "toDhall"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/generators.nix",
          "line": 449
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 13,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/generators.nix",
          "line": 449
        }
      }
    },
    "path": ["lib", "generators", "toDhall"]
  },
  {
    "aliases": [["lib", "generators", "toDconfINI"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/generators.nix",
          "line": 254
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 6,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/generators.nix",
          "line": 126
        }
      }
    },
    "path": ["lib", "generators", "toDconfINI"]
  },
  {
    "aliases": [["lib", "generators", "mkValueStringDefault"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/generators.nix",
          "line": 35
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 26,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/generators.nix",
          "line": 35
        }
      }
    },
    "path": ["lib", "generators", "mkValueStringDefault"]
  },
  {
    "aliases": [["lib", "generators", "mkLuaInline"]],
    "docs": {
      "attrDocs": {
        "content": "Mark string as Lua expression to be inlined when processed by toLua.\n\n# Type\n\n```\nmkLuaInline :: String -> AttrSet\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/generators.nix",
          "line": 578
        }
      },
      "lambdaDocs": {
        "content": "Mark string as Lua expression to be inlined when processed by toLua.\n\n# Type\n\n```\nmkLuaInline :: String -> AttrSet\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/generators.nix",
          "line": 578
        }
      }
    },
    "path": ["lib", "generators", "mkLuaInline"]
  },
  {
    "aliases": [["lib", "generators", "mkKeyValueDefault"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/generators.nix",
          "line": 72
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/generators.nix",
          "line": 72
        }
      }
    },
    "path": ["lib", "generators", "mkKeyValueDefault"]
  },
  {
    "aliases": [["lib", "generators", "mkDconfKeyValue"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/generators.nix",
          "line": 250
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 11,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/generators.nix",
          "line": 74
        }
      }
    },
    "path": ["lib", "generators", "mkDconfKeyValue"]
  },
  {
    "aliases": [
      ["lib", "strings", "genList"],
      ["lib", "lists", "genList"],
      ["lib", "genList"],
      ["builtins", "genList"],
      ["builtins", "genList"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 68
        }
      },
      "lambdaDocs": {
        "content": "Generate list of size *length*, with each element *i* equal to the\nvalue returned by *generator* `i`. For example,\n\n```nix\nbuiltins.genList (x: x * x) 5\n```\n\nreturns the list `[ 0 1 4 9 16 ]`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "genList"]
  },
  {
    "aliases": [
      ["lib", "genAttrs"],
      ["lib", "attrsets", "genAttrs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "Generate an attribute set by mapping a function over a list of\nattribute names.\n\n# Example\n\n```nix\ngenAttrs [ \"foo\" \"bar\" ] (name: \"x_\" + name)\n=> { foo = \"x_foo\"; bar = \"x_bar\"; }\n```\n\n# Type\n\n```\ngenAttrs :: [ String ] -> (String -> Any) -> AttrSet\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 778
        }
      }
    },
    "path": ["lib", "genAttrs"]
  },
  {
    "aliases": [
      ["lib", "trivial", "functionArgs"],
      ["lib", "functionArgs"],
      ["builtins", "functionArgs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 73
        }
      },
      "lambdaDocs": {
        "content": "Extract the expected function arguments from a function.\nThis works both with nix-native { a, b ? foo, ... }: style\nfunctions and functions with args set with 'setFunctionArgs'. It\nhas the same return type and semantics as builtins.functionArgs.\nsetFunctionArgs : (a → b) → Map String Bool.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 18,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 589
        }
      }
    },
    "path": ["lib", "functionArgs"]
  },
  {
    "aliases": [
      ["lib", "stringsWithDeps", "fullDepEntry"],
      ["lib", "fullDepEntry"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 35,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 114
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 18,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings-with-deps.nix",
          "line": 81
        }
      }
    },
    "path": ["lib", "fullDepEntry"]
  },
  {
    "aliases": [
      ["lib", "lists", "forEach"],
      ["lib", "forEach"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 92
        }
      },
      "lambdaDocs": {
        "content": "Apply the function to each element in the list. Same as `map`, but arguments\nflipped.\n\n# Example\n\n```nix\nforEach [ 1 2 ] (x:\n  toString x\n)\n=> [ \"1\" \"2\" ]\n```\n\n# Type\n\n```\nforEach :: [a] -> (a -> b) -> [b]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 13,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 52
        }
      }
    },
    "path": ["lib", "forEach"]
  },
  {
    "aliases": [
      ["lib", "lists", "foldr"],
      ["lib", "lists", "fold"],
      ["lib", "foldr"],
      ["lib", "fold"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 92
        }
      },
      "lambdaDocs": {
        "content": "“right fold” a binary function `op` between successive elements of\n`list` with `nul` as the starting value, i.e.,\n`foldr op nul [x_1 x_2 ... x_n] == op x_1 (op x_2 ... (op x_n nul))`.\n\n# Example\n\n```nix\nconcat = foldr (a: b: a + b) \"z\"\nconcat [ \"a\" \"b\" \"c\" ]\n=> \"abcz\"\n# different types\nstrange = foldr (int: str: toString (int + 1) + str) \"a\"\nstrange [ 1 2 3 4 ]\n=> \"2345a\"\n```\n\n# Type\n\n```\nfoldr :: (a -> b -> b) -> b -> [a] -> b\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 11,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 77
        }
      }
    },
    "path": ["lib", "foldr"]
  },
  {
    "aliases": [
      ["lib", "foldlAttrs"],
      ["lib", "attrsets", "foldlAttrs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 16,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 484
        }
      }
    },
    "path": ["lib", "foldlAttrs"]
  },
  {
    "aliases": [
      ["lib", "lists", "foldl'"],
      ["lib", "foldl'"],
      ["builtins", "foldl'"],
      ["builtins", "foldl'"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 92
        }
      },
      "lambdaDocs": {
        "content": "Reduce a list by applying a binary operator, from left to right,\ne.g. `foldl' op nul [x0 x1 x2 ...] = op (op (op nul x0) x1) x2)\n...`. For example, `foldl' (x: y: x + y) 0 [1 2 3]` evaluates to 6.\nThe return value of each application of `op` is evaluated immediately,\neven for intermediate values.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "foldl'"]
  },
  {
    "aliases": [
      ["lib", "lists", "foldl"],
      ["lib", "foldl"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 92
        }
      },
      "lambdaDocs": {
        "content": "“left fold”, like `foldr`, but from the left:\n`foldl op nul [x_1 x_2 ... x_n] == op (... (op (op nul x_1) x_2) ... x_n)`.\n\n# Example\n\n```nix\nlconcat = foldl (a: b: a + b) \"z\"\nlconcat [ \"a\" \"b\" \"c\" ]\n=> \"zabc\"\n# different types\nlstrange = foldl (str: int: str + toString (int + 1)) \"a\"\nlstrange [ 1 2 3 4 ]\n=> \"a2345\"\n```\n\n# Type\n\n```\nfoldl :: (b -> a -> b) -> b -> [a] -> b\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 11,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 115
        }
      }
    },
    "path": ["lib", "foldl"]
  },
  {
    "aliases": [
      ["lib", "foldAttrs"],
      ["lib", "attrsets", "foldAttrs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "Apply fold functions to values grouped by key.\n\n# Example\n\n```nix\nfoldAttrs (item: acc: [item] ++ acc) [] [{ a = 2; } { a = 3; }]\n=> { a = [ 2 3 ]; }\n```\n\n# Type\n\n```\nfoldAttrs :: (Any -> Any -> Any) -> Any -> [AttrSets] -> Any\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 508
        }
      }
    },
    "path": ["lib", "foldAttrs"]
  },
  {
    "aliases": [
      ["lib", "misc", "foldArgs"],
      ["lib", "foldArgs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 156
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 23
        }
      }
    },
    "path": ["lib", "foldArgs"]
  },
  {
    "aliases": [
      ["lib", "lists", "foldr"],
      ["lib", "lists", "fold"],
      ["lib", "foldr"],
      ["lib", "fold"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 92
        }
      },
      "lambdaDocs": {
        "content": "“right fold” a binary function `op` between successive elements of\n`list` with `nul` as the starting value, i.e.,\n`foldr op nul [x_1 x_2 ... x_n] == op x_1 (op x_2 ... (op x_n nul))`.\n\n# Example\n\n```nix\nconcat = foldr (a: b: a + b) \"z\"\nconcat [ \"a\" \"b\" \"c\" ]\n=> \"abcz\"\n# different types\nstrange = foldr (int: str: toString (int + 1) + str) \"a\"\nstrange [ 1 2 3 4 ]\n=> \"2345a\"\n```\n\n# Type\n\n```\nfoldr :: (a -> b -> b) -> b -> [a] -> b\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 11,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 77
        }
      }
    },
    "path": ["lib", "fold"]
  },
  {
    "aliases": [
      ["lib", "trivial", "flip"],
      ["lib", "flip"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 73
        }
      },
      "lambdaDocs": {
        "content": "Flip the order of the arguments of a binary function.\n\n# Example\n\n```nix\nflip concat [1] [2]\n=> [ 2 1 ]\n```\n\n# Type\n\n```\nflip :: (a -> b -> c) -> (b -> a -> c)\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 198
        }
      }
    },
    "path": ["lib", "flip"]
  },
  {
    "aliases": [
      ["lib", "lists", "flatten"],
      ["lib", "flatten"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 92
        }
      },
      "lambdaDocs": {
        "content": "Flatten the argument into a single list; that is, nested lists are\nspliced into the top-level lists.\n\n# Example\n\n```nix\nflatten [1 [2 [3] 4] 5]\n=> [1 2 3 4 5]\nflatten 1\n=> [1]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 13,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 205
        }
      }
    },
    "path": ["lib", "flatten"]
  },
  {
    "aliases": [
      ["lib", "modules", "fixupOptionType"],
      ["lib", "fixupOptionType"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 128
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 964
        }
      }
    },
    "path": ["lib", "fixupOptionType"]
  },
  {
    "aliases": [
      ["lib", "strings", "fixedWidthString"],
      ["lib", "fixedWidthString"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "Create a fixed width string with additional prefix to match\nrequired width.\n\nThis function will fail if the input string is longer than the\nrequested length.\n\n# Example\n\n```nix\nfixedWidthString 5 \"0\" (toString 15)\n=> \"00015\"\n```\n\n# Type\n\n```\nfixedWidthString :: int -> string -> string -> string\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 22,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1215
        }
      }
    },
    "path": ["lib", "fixedWidthString"]
  },
  {
    "aliases": [
      ["lib", "strings", "fixedWidthNumber"],
      ["lib", "fixedWidthNumber"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "Format a number adding leading zeroes up to fixed width.\n\n# Example\n\n```nix\nfixedWidthNumber 5 15\n=> \"00015\"\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 22,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1236
        }
      }
    },
    "path": ["lib", "fixedWidthNumber"]
  },
  {
    "aliases": [
      ["lib", "makeExtensibleWithCustomName"],
      ["lib", "fixedPoints", "makeExtensibleWithCustomName"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Same as `makeExtensible` but the name of the extending attribute is\ncustomized.",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/fixed-points.nix",
          "line": 151
        }
      },
      "lambdaDocs": {
        "content": "Same as `makeExtensible` but the name of the extending attribute is\ncustomized.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 34,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/fixed-points.nix",
          "line": 151
        }
      }
    },
    "path": ["lib", "fixedPoints", "makeExtensibleWithCustomName"]
  },
  {
    "aliases": [
      ["lib", "makeExtensible"],
      ["lib", "fixedPoints", "makeExtensible"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Create an overridable, recursive attribute set. For example:\n\n```\nnix-repl> obj = makeExtensible (self: { })\n\nnix-repl> obj\n{ __unfix__ = «lambda»; extend = «lambda»; }\n\nnix-repl> obj = obj.extend (self: super: { foo = \"foo\"; })\n\nnix-repl> obj\n{ __unfix__ = «lambda»; extend = «lambda»; foo = \"foo\"; }\n\nnix-repl> obj = obj.extend (self: super: { foo = super.foo + \" + \"; bar = \"bar\"; foobar = self.foo + self.bar; })\n\nnix-repl> obj\n{ __unfix__ = «lambda»; bar = \"bar\"; extend = «lambda»; foo = \"foo + \"; foobar = \"foo + bar\"; }\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/fixed-points.nix",
          "line": 145
        }
      },
      "lambdaDocs": {
        "content": "Same as `makeExtensible` but the name of the extending attribute is\ncustomized.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 48,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/fixed-points.nix",
          "line": 151
        }
      }
    },
    "path": ["lib", "fixedPoints", "makeExtensible"]
  },
  {
    "aliases": [
      ["lib", "fixedPoints", "fix'"],
      ["lib", "fix'"]
    ],
    "docs": {
      "attrDocs": {
        "content": "A variant of `fix` that records the original recursive attribute set in the\nresult, in an attribute named `__unfix__`.\n\nThis is useful in combination with the `extends` function to\nimplement deep overriding.",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/fixed-points.nix",
          "line": 38
        }
      },
      "lambdaDocs": {
        "content": "A variant of `fix` that records the original recursive attribute set in the\nresult, in an attribute named `__unfix__`.\n\nThis is useful in combination with the `extends` function to\nimplement deep overriding.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/fixed-points.nix",
          "line": 38
        }
      }
    },
    "path": ["lib", "fixedPoints", "fix'"]
  },
  {
    "aliases": [
      ["lib", "fixedPoints", "fix"],
      ["lib", "fix"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/fixed-points.nix",
          "line": 29
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 9,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/fixed-points.nix",
          "line": 29
        }
      }
    },
    "path": ["lib", "fixedPoints", "fix"]
  },
  {
    "aliases": [
      ["lib", "fixedPoints", "extends"],
      ["lib", "extends"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/fixed-points.nix",
          "line": 99
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 13,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/fixed-points.nix",
          "line": 99
        }
      }
    },
    "path": ["lib", "fixedPoints", "extends"]
  },
  {
    "aliases": [
      ["lib", "fixedPoints", "converge"],
      ["lib", "converge"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/fixed-points.nix",
          "line": 55
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/fixed-points.nix",
          "line": 55
        }
      }
    },
    "path": ["lib", "fixedPoints", "converge"]
  },
  {
    "aliases": [
      ["lib", "fixedPoints", "composeManyExtensions"],
      ["lib", "composeManyExtensions"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Compose several extending functions of the type expected by 'extends' into\none where changes made in preceding functions are made available to\nsubsequent ones.\n\n```\ncomposeManyExtensions : [packageSet -> packageSet -> packageSet] -> packageSet -> packageSet -> packageSet\n^final        ^prev         ^overrides     ^final        ^prev         ^overrides\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/fixed-points.nix",
          "line": 122
        }
      },
      "lambdaDocs": {
        "content": "“right fold” a binary function `op` between successive elements of\n`list` with `nul` as the starting value, i.e.,\n`foldr op nul [x_1 x_2 ... x_n] == op x_1 (op x_2 ... (op x_n nul))`.\n\n# Example\n\n```nix\nconcat = foldr (a: b: a + b) \"z\"\nconcat [ \"a\" \"b\" \"c\" ]\n=> \"abcz\"\n# different types\nstrange = foldr (int: str: toString (int + 1) + str) \"a\"\nstrange [ 1 2 3 4 ]\n=> \"2345a\"\n```\n\n# Type\n\n```\nfoldr :: (a -> b -> b) -> b -> [a] -> b\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 20,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 77
        }
      }
    },
    "path": ["lib", "fixedPoints", "composeManyExtensions"]
  },
  {
    "aliases": [
      ["lib", "fixedPoints", "composeExtensions"],
      ["lib", "composeExtensions"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Compose two extending functions of the type expected by 'extends'\ninto one where changes made in the first are available in the\n'super' of the second",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/fixed-points.nix",
          "line": 106
        }
      },
      "lambdaDocs": {
        "content": "Compose two extending functions of the type expected by 'extends'\ninto one where changes made in the first are available in the\n'super' of the second",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/fixed-points.nix",
          "line": 107
        }
      }
    },
    "path": ["lib", "fixedPoints", "composeExtensions"]
  },
  {
    "aliases": [
      ["lib", "modules", "fixMergeModules"],
      ["lib", "fixMergeModules"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 128
        }
      },
      "lambdaDocs": {
        "content": "Compatibility.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1090
        }
      }
    },
    "path": ["lib", "fixMergeModules"]
  },
  {
    "aliases": [
      ["lib", "fixedPoints", "fix'"],
      ["lib", "fix'"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 31,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 80
        }
      },
      "lambdaDocs": {
        "content": "A variant of `fix` that records the original recursive attribute set in the\nresult, in an attribute named `__unfix__`.\n\nThis is useful in combination with the `extends` function to\nimplement deep overriding.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 10,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/fixed-points.nix",
          "line": 38
        }
      }
    },
    "path": ["lib", "fix'"]
  },
  {
    "aliases": [
      ["lib", "fixedPoints", "fix"],
      ["lib", "fix"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 31,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 80
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 9,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/fixed-points.nix",
          "line": 29
        }
      }
    },
    "path": ["lib", "fix"]
  },
  {
    "aliases": [
      ["lib", "lists", "findSingle"],
      ["lib", "findSingle"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 92
        }
      },
      "lambdaDocs": {
        "content": "Find the sole element in the list matching the specified\npredicate, returns `default` if no such element exists, or\n`multiple` if there are multiple matching elements.\n\n# Example\n\n```nix\nfindSingle (x: x == 3) \"none\" \"multiple\" [ 1 3 3 ]\n=> \"multiple\"\nfindSingle (x: x == 3) \"none\" \"multiple\" [ 1 3 ]\n=> 3\nfindSingle (x: x == 3) \"none\" \"multiple\" [ 1 9 ]\n=> \"none\"\n```\n\n# Type\n\n```\nfindSingle :: (a -> bool) -> a -> a -> [a] -> a\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 254
        }
      }
    },
    "path": ["lib", "findSingle"]
  },
  {
    "aliases": [
      ["lib", "lists", "findFirst"],
      ["lib", "findFirst"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 92
        }
      },
      "lambdaDocs": {
        "content": "Find the first element in the list matching the specified\npredicate or return `default` if no such element exists.\n\n# Example\n\n```nix\nfindFirst (x: x > 3) 7 [ 1 6 4 ]\n=> 6\nfindFirst (x: x > 9) 7 [ 1 6 4 ]\n=> 7\n```\n\n# Type\n\n```\nfindFirst :: (a -> bool) -> a -> [a] -> a\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 346
        }
      }
    },
    "path": ["lib", "findFirst"]
  },
  {
    "aliases": [
      ["lib", "modules", "filterOverrides"],
      ["lib", "filterOverrides"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 128
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 934
        }
      }
    },
    "path": ["lib", "filterOverrides"]
  },
  {
    "aliases": [
      ["lib", "filterAttrsRecursive"],
      ["lib", "attrsets", "filterAttrsRecursive"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "Filter an attribute set recursively by removing all attributes for\nwhich the given predicate return false.\n\n# Example\n\n```nix\nfilterAttrsRecursive (n: v: v != null) { foo = { bar = null; }; }\n=> { foo = {}; }\n```\n\n# Type\n\n```\nfilterAttrsRecursive :: (String -> Any -> Bool) -> AttrSet -> AttrSet\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 409
        }
      }
    },
    "path": ["lib", "filterAttrsRecursive"]
  },
  {
    "aliases": [
      ["lib", "filterAttrs"],
      ["lib", "attrsets", "filterAttrs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "Filter an attribute set by removing all attributes for which the\ngiven predicate return false.\n\n# Example\n\n```nix\nfilterAttrs (n: v: n == \"foo\") { foo = 1; bar = 2; }\n=> { foo = 1; }\n```\n\n# Type\n\n```\nfilterAttrs :: (String -> Any -> Bool) -> AttrSet -> AttrSet\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 384
        }
      }
    },
    "path": ["lib", "filterAttrs"]
  },
  {
    "aliases": [
      ["lib", "strings", "filter"],
      ["lib", "lists", "filter"],
      ["lib", "filter"],
      ["builtins", "filter"],
      ["builtins", "filter"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 68
        }
      },
      "lambdaDocs": {
        "content": "Return a list consisting of the elements of *list* for which the\nfunction *f* returns `true`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "filter"]
  },
  {
    "aliases": [
      ["lib", "sources", "pathType"],
      ["lib", "pathType"],
      ["lib", "filesystem", "pathType"],
      ["builtins", "readFileType"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/filesystem.nix",
          "line": 39
        }
      },
      "lambdaDocs": {
        "content": "Determine the directory entry type of a filesystem node, being\none of \"directory\", \"regular\", \"symlink\", or \"unknown\".",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "filesystem", "pathType"]
  },
  {
    "aliases": [
      ["lib", "sources", "pathIsRegularFile"],
      ["lib", "pathIsRegularFile"],
      ["lib", "filesystem", "pathIsRegularFile"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/filesystem.nix",
          "line": 102
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/filesystem.nix",
          "line": 102
        }
      }
    },
    "path": ["lib", "filesystem", "pathIsRegularFile"]
  },
  {
    "aliases": [
      ["lib", "sources", "pathIsDirectory"],
      ["lib", "pathIsDirectory"],
      ["lib", "filesystem", "pathIsDirectory"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/filesystem.nix",
          "line": 77
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/filesystem.nix",
          "line": 77
        }
      }
    },
    "path": ["lib", "filesystem", "pathIsDirectory"]
  },
  {
    "aliases": [["lib", "filesystem", "locateDominatingFile"]],
    "docs": {
      "attrDocs": {
        "content": "Find the first directory containing a file matching 'pattern'\nupward from a given 'file'.\nReturns 'null' if no directories contain a file matching 'pattern'.\n\n# Type\n\n```\nRegExp -> Path -> Nullable { path : Path; matches : [ MatchResults ]; }\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/filesystem.nix",
          "line": 143
        }
      },
      "lambdaDocs": {
        "content": "Find the first directory containing a file matching 'pattern'\nupward from a given 'file'.\nReturns 'null' if no directories contain a file matching 'pattern'.\n\n# Type\n\n```\nRegExp -> Path -> Nullable { path : Path; matches : [ MatchResults ]; }\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/filesystem.nix",
          "line": 145
        }
      }
    },
    "path": ["lib", "filesystem", "locateDominatingFile"]
  },
  {
    "aliases": [["lib", "filesystem", "listFilesRecursive"]],
    "docs": {
      "attrDocs": {
        "content": "Given a directory, return a flattened list of all files within it recursively.\n\n# Type\n\n```\nPath -> [ Path ]\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/filesystem.nix",
          "line": 175
        }
      },
      "lambdaDocs": {
        "content": "Given a directory, return a flattened list of all files within it recursively.\n\n# Type\n\n```\nPath -> [ Path ]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/filesystem.nix",
          "line": 177
        }
      }
    },
    "path": ["lib", "filesystem", "listFilesRecursive"]
  },
  {
    "aliases": [["lib", "filesystem", "haskellPathsInDir"]],
    "docs": {
      "attrDocs": {
        "content": "A map of all haskell packages defined in the given path,\nidentified by having a cabal file with the same name as the\ndirectory itself.\n\n# Type\n\n```\nPath -> Map String Path\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/filesystem.nix",
          "line": 116
        }
      },
      "lambdaDocs": {
        "content": "A map of all haskell packages defined in the given path,\nidentified by having a cabal file with the same name as the\ndirectory itself.\n\n# Type\n\n```\nPath -> Map String Path\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/filesystem.nix",
          "line": 118
        }
      }
    },
    "path": ["lib", "filesystem", "haskellPathsInDir"]
  },
  {
    "aliases": [["lib", "fileset", "toSource"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/fileset/default.nix",
          "line": 66
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/fileset/default.nix",
          "line": 66
        }
      }
    },
    "path": ["lib", "fileset", "toSource"]
  },
  {
    "aliases": [
      ["lib", "strings", "fileContents"],
      ["lib", "fileContents"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 18,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1477
        }
      }
    },
    "path": ["lib", "fileContents"]
  },
  {
    "aliases": [
      ["lib", "fixedPoints", "extends"],
      ["lib", "extends"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 31,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 80
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 13,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/fixed-points.nix",
          "line": 99
        }
      }
    },
    "path": ["lib", "extends"]
  },
  {
    "aliases": [
      ["lib", "extendDerivation"],
      ["lib", "customisation", "extendDerivation"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 33,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 116
        }
      },
      "lambdaDocs": {
        "content": "Add attributes to each output of a derivation without changing\nthe derivation itself and check a given condition when evaluating.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 22,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/customisation.nix",
          "line": 203
        }
      }
    },
    "path": ["lib", "extendDerivation"]
  },
  {
    "aliases": [["lib", "extend"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 7,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/fixed-points.nix",
          "line": 153
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/fixed-points.nix",
          "line": 153
        }
      }
    },
    "path": ["lib", "extend"]
  },
  {
    "aliases": [
      ["lib", "modules", "evalOptionValue"],
      ["lib", "evalOptionValue"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 128
        }
      },
      "lambdaDocs": {
        "content": "Merge all the definitions of an option to produce the final\nconfig value.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 782
        }
      }
    },
    "path": ["lib", "evalOptionValue"]
  },
  {
    "aliases": [
      ["lib", "modules", "evalModules"],
      ["lib", "evalModules"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 128
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 75
        }
      }
    },
    "path": ["lib", "evalModules"]
  },
  {
    "aliases": [
      ["lib", "toUpper"],
      ["lib", "toLower"],
      ["lib", "strings", "toUpper"],
      ["lib", "strings", "toLower"],
      ["lib", "strings", "escapeXML"],
      ["lib", "strings", "escapeURL"],
      ["lib", "strings", "escapeRegex"],
      ["lib", "escapeXML"],
      ["lib", "escapeURL"],
      ["lib", "escapeRegex"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "Given string *s*, replace every occurrence of the strings in *from*\nwith the corresponding string in *to*.\n\nThe argument *to* is lazy, that is, it is only evaluated when its corresponding pattern in *from* is matched in the string *s*\n\nExample:\n\n```nix\nbuiltins.replaceStrings [\"oo\" \"a\"] [\"a\" \"i\"] \"foobar\"\n```\n\nevaluates to `\"fabir\"`.",
        "countApplied": 2,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "escapeXML"]
  },
  {
    "aliases": [
      ["lib", "toUpper"],
      ["lib", "toLower"],
      ["lib", "strings", "toUpper"],
      ["lib", "strings", "toLower"],
      ["lib", "strings", "escapeXML"],
      ["lib", "strings", "escapeURL"],
      ["lib", "strings", "escapeRegex"],
      ["lib", "escapeXML"],
      ["lib", "escapeURL"],
      ["lib", "escapeRegex"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "Given string *s*, replace every occurrence of the strings in *from*\nwith the corresponding string in *to*.\n\nThe argument *to* is lazy, that is, it is only evaluated when its corresponding pattern in *from* is matched in the string *s*\n\nExample:\n\n```nix\nbuiltins.replaceStrings [\"oo\" \"a\"] [\"a\" \"i\"] \"foobar\"\n```\n\nevaluates to `\"fabir\"`.",
        "countApplied": 2,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "escapeURL"]
  },
  {
    "aliases": [
      ["lib", "strings", "escapeShellArgs"],
      ["lib", "escapeShellArgs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "Maps a function over a list of strings and then concatenates the\nresult with the specified separator interspersed between\nelements.\n\n# Example\n\n```nix\nconcatMapStringsSep \"-\" (x: toUpper x)  [\"foo\" \"bar\" \"baz\"]\n=> \"FOO-BAR-BAZ\"\n```\n\n# Type\n\n```\nconcatMapStringsSep :: string -> (a -> string) -> [a] -> string\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 167
        }
      }
    },
    "path": ["lib", "escapeShellArgs"]
  },
  {
    "aliases": [
      ["lib", "strings", "escapeShellArg"],
      ["lib", "escapeShellArg"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "Quote string to be used safely within the Bourne shell.\n\n# Example\n\n```nix\nescapeShellArg \"esc'ape\\nme\"\n=> \"'esc'\\\\''ape\\nme'\"\n```\n\n# Type\n\n```\nescapeShellArg :: string -> string\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 20,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 613
        }
      }
    },
    "path": ["lib", "escapeShellArg"]
  },
  {
    "aliases": [
      ["lib", "toUpper"],
      ["lib", "toLower"],
      ["lib", "strings", "toUpper"],
      ["lib", "strings", "toLower"],
      ["lib", "strings", "escapeXML"],
      ["lib", "strings", "escapeURL"],
      ["lib", "strings", "escapeRegex"],
      ["lib", "escapeXML"],
      ["lib", "escapeURL"],
      ["lib", "escapeRegex"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "Given string *s*, replace every occurrence of the strings in *from*\nwith the corresponding string in *to*.\n\nThe argument *to* is lazy, that is, it is only evaluated when its corresponding pattern in *from* is matched in the string *s*\n\nExample:\n\n```nix\nbuiltins.replaceStrings [\"oo\" \"a\"] [\"a\" \"i\"] \"foobar\"\n```\n\nevaluates to `\"fabir\"`.",
        "countApplied": 2,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "escapeRegex"]
  },
  {
    "aliases": [
      ["lib", "strings", "escape"],
      ["lib", "escape"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "Escape occurrence of the elements of `list` in `string` by\nprefixing it with a backslash.\n\n# Example\n\n```nix\nescape [\"(\" \")\"] \"(foo)\"\n=> \"\\\\(foo\\\\)\"\n```\n\n# Type\n\n```\nescape :: [string] -> string -> string\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 12,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 552
        }
      }
    },
    "path": ["lib", "escape"]
  },
  {
    "aliases": [
      ["lib", "strings", "enableFeatureAs"],
      ["lib", "enableFeatureAs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "Create an --{enable-<feat>=<value>,disable-<feat>} string that can be passed to\nstandard GNU Autoconf scripts.\n\n# Example\n\n```nix\nenableFeatureAs true \"shared\" \"foo\"\n=> \"--enable-shared=foo\"\nenableFeatureAs false \"shared\" (throw \"ignored\")\n=> \"--disable-shared\"\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1161
        }
      }
    },
    "path": ["lib", "enableFeatureAs"]
  },
  {
    "aliases": [
      ["lib", "strings", "enableFeature"],
      ["lib", "enableFeature"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "Create an --{enable,disable}-<feat> string that can be passed to\nstandard GNU Autoconf scripts.\n\n# Example\n\n```nix\nenableFeature true \"shared\"\n=> \"--enable-shared\"\nenableFeature false \"shared\"\n=> \"--disable-shared\"\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 19,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 1144
        }
      }
    },
    "path": ["lib", "enableFeature"]
  },
  {
    "aliases": [
      ["lib", "strings", "elemAt"],
      ["lib", "lists", "elemAt"],
      ["lib", "elemAt"],
      ["builtins", "elemAt"],
      ["builtins", "elemAt"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 68
        }
      },
      "lambdaDocs": {
        "content": "Return element *n* from the list *xs*. Elements are counted starting\nfrom 0. A fatal error occurs if the index is out of bounds.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "elemAt"]
  },
  {
    "aliases": [
      ["lib", "strings", "elem"],
      ["lib", "lists", "elem"],
      ["lib", "elem"],
      ["builtins", "elem"],
      ["builtins", "elem"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 68
        }
      },
      "lambdaDocs": {
        "content": "Return `true` if a value equal to *x* occurs in the list *xs*, and\n`false` otherwise.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "elem"]
  },
  {
    "aliases": [
      ["lib", "lists", "drop"],
      ["lib", "drop"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 92
        }
      },
      "lambdaDocs": {
        "content": "Remove the first (at most) N elements of a list.\n\n# Example\n\n```nix\ndrop 2 [ \"a\" \"b\" \"c\" \"d\" ]\n=> [ \"c\" \"d\" ]\ndrop 2 [ ]\n=> [ ]\n```\n\n# Type\n\n```\ndrop :: int -> [a] -> [a]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 864
        }
      }
    },
    "path": ["lib", "drop"]
  },
  {
    "aliases": [
      ["lib", "dontRecurseIntoAttrs"],
      ["lib", "attrsets", "dontRecurseIntoAttrs"],
      ["pkgs", "dontRecurseIntoAttrs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "Undo the effect of recurseIntoAttrs.\n\n# Type\n\n```\ndontRecurseIntoAttrs :: AttrSet -> AttrSet\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1316
        }
      }
    },
    "path": ["lib", "dontRecurseIntoAttrs"]
  },
  {
    "aliases": [
      ["lib", "meta", "dontDistribute"],
      ["lib", "dontDistribute"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 120
        }
      },
      "lambdaDocs": {
        "content": "Disable Hydra builds of given derivation.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 20,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 28
        }
      }
    },
    "path": ["lib", "dontDistribute"]
  },
  {
    "aliases": [
      ["lib", "modules", "doRename"],
      ["lib", "doRename"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 128
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 1285
        }
      }
    },
    "path": ["lib", "doRename"]
  },
  {
    "aliases": [
      ["lib", "modules", "dischargeProperties"],
      ["lib", "dischargeProperties"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 128
        }
      },
      "lambdaDocs": {
        "content": "Given a config value, expand mkMerge properties, and discharge\nany mkIf conditions.  That is, this is the place where mkIf\nconditions are actually evaluated.  The result is a list of\nconfig values.  For example, ‘mkIf false x’ yields ‘[]’,\n‘mkIf true x’ yields ‘[x]’, and\n\nmkMerge [ 1 (mkIf true 2) (mkIf true (mkIf false 3)) ]\n\nyields ‘[ 1 2 ]’.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 900
        }
      }
    },
    "path": ["lib", "dischargeProperties"]
  },
  {
    "aliases": [
      ["lib", "lazyDerivation"],
      ["lib", "derivations", "lazyDerivation"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/derivations.nix",
          "line": 52
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/derivations.nix",
          "line": 53
        }
      }
    },
    "path": ["lib", "derivations", "lazyDerivation"]
  },
  {
    "aliases": [
      ["lib", "types", "defaultTypeMerge"],
      ["lib", "defaultTypeMerge"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 148
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 22,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 79
        }
      }
    },
    "path": ["lib", "defaultTypeMerge"]
  },
  {
    "aliases": [
      ["lib", "misc", "defaultMergeArg"],
      ["lib", "defaultMergeArg"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 156
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 18
        }
      }
    },
    "path": ["lib", "defaultMergeArg"]
  },
  {
    "aliases": [
      ["lib", "misc", "defaultMerge"],
      ["lib", "defaultMerge"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 156
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 18,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 22
        }
      }
    },
    "path": ["lib", "defaultMerge"]
  },
  {
    "aliases": [
      ["lib", "types", "defaultFunctor"],
      ["lib", "defaultFunctor"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 148
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 20,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/types.nix",
          "line": 99
        }
      }
    },
    "path": ["lib", "defaultFunctor"]
  },
  {
    "aliases": [
      ["lib", "trivial", "deepSeq"],
      ["lib", "deepSeq"],
      ["builtins", "deepSeq"],
      ["builtins", "deepSeq"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 68
        }
      },
      "lambdaDocs": {
        "content": "This is like `seq e1 e2`, except that *e1* is evaluated *deeply*:\nif it’s a list or set, its elements or attributes are also\nevaluated recursively.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "deepSeq"]
  },
  {
    "aliases": [
      ["lib", "traceValSeqNFn"],
      ["lib", "debug", "traceValSeqNFn"]
    ],
    "docs": {
      "attrDocs": {
        "content": "A combination of `traceVal` and `traceSeqN` that applies a\nprovided function to the value to be traced.",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/debug.nix",
          "line": 182
        }
      },
      "lambdaDocs": {
        "content": "A combination of `traceVal` and `traceSeqN` that applies a\nprovided function to the value to be traced.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/debug.nix",
          "line": 184
        }
      }
    },
    "path": ["lib", "debug", "traceValSeqNFn"]
  },
  {
    "aliases": [
      ["lib", "traceValSeqN"],
      ["lib", "debug", "traceValSeqN"]
    ],
    "docs": {
      "attrDocs": {
        "content": "A combination of `traceVal` and `traceSeqN`.",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/debug.nix",
          "line": 192
        }
      },
      "lambdaDocs": {
        "content": "A combination of `traceVal` and `traceSeqN` that applies a\nprovided function to the value to be traced.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/debug.nix",
          "line": 185
        }
      }
    },
    "path": ["lib", "debug", "traceValSeqN"]
  },
  {
    "aliases": [
      ["lib", "traceValSeqFn"],
      ["lib", "debug", "traceValSeqFn"]
    ],
    "docs": {
      "attrDocs": {
        "content": "A combination of `traceVal` and `traceSeq` that applies a\nprovided function to the value to be traced after `deepSeq`ing\nit.",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/debug.nix",
          "line": 167
        }
      },
      "lambdaDocs": {
        "content": "A combination of `traceVal` and `traceSeq` that applies a\nprovided function to the value to be traced after `deepSeq`ing\nit.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/debug.nix",
          "line": 169
        }
      }
    },
    "path": ["lib", "debug", "traceValSeqFn"]
  },
  {
    "aliases": [
      ["lib", "traceValSeq"],
      ["lib", "debug", "traceValSeq"]
    ],
    "docs": {
      "attrDocs": {
        "content": "A combination of `traceVal` and `traceSeq`.",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/debug.nix",
          "line": 176
        }
      },
      "lambdaDocs": {
        "content": "A combination of `traceVal` and `traceSeq` that applies a\nprovided function to the value to be traced after `deepSeq`ing\nit.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/debug.nix",
          "line": 171
        }
      }
    },
    "path": ["lib", "debug", "traceValSeq"]
  },
  {
    "aliases": [
      ["lib", "traceValFn"],
      ["lib", "debug", "traceValFn"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Trace the supplied value after applying a function to it, and\nreturn the original value.\n\n# Example\n\n```nix\ntraceValFn (v: \"mystring ${v}\") \"foo\"\ntrace: mystring foo\n=> \"foo\"\n```\n\n# Type\n\n```\ntraceValFn :: (a -> b) -> a -> a\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/debug.nix",
          "line": 79
        }
      },
      "lambdaDocs": {
        "content": "Trace the supplied value after applying a function to it, and\nreturn the original value.\n\n# Example\n\n```nix\ntraceValFn (v: \"mystring ${v}\") \"foo\"\ntrace: mystring foo\n=> \"foo\"\n```\n\n# Type\n\n```\ntraceValFn :: (a -> b) -> a -> a\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/debug.nix",
          "line": 81
        }
      }
    },
    "path": ["lib", "debug", "traceValFn"]
  },
  {
    "aliases": [
      ["lib", "traceVal"],
      ["lib", "debug", "traceVal"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Trace the supplied value and return it.\n\n# Example\n\n```nix\ntraceVal 42\n# trace: 42\n=> 42\n```\n\n# Type\n\n```\ntraceVal :: a -> a\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/debug.nix",
          "line": 102
        }
      },
      "lambdaDocs": {
        "content": "Trace the supplied value after applying a function to it, and\nreturn the original value.\n\n# Example\n\n```nix\ntraceValFn (v: \"mystring ${v}\") \"foo\"\ntrace: mystring foo\n=> \"foo\"\n```\n\n# Type\n\n```\ntraceValFn :: (a -> b) -> a -> a\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/debug.nix",
          "line": 83
        }
      }
    },
    "path": ["lib", "debug", "traceVal"]
  },
  {
    "aliases": [
      ["lib", "traceSeqN"],
      ["lib", "debug", "traceSeqN"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Like `traceSeq`, but only evaluate down to depth n.\nThis is very useful because lots of `traceSeq` usages\nlead to an infinite recursion.\n\n# Example\n\n```nix\ntraceSeqN 2 { a.b.c = 3; } null\ntrace: { a = { b = {…}; }; }\n=> null\n```\n\n# Type\n\n```\ntraceSeqN :: Int -> a -> b -> b\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/debug.nix",
          "line": 149
        }
      },
      "lambdaDocs": {
        "content": "Like `traceSeq`, but only evaluate down to depth n.\nThis is very useful because lots of `traceSeq` usages\nlead to an infinite recursion.\n\n# Example\n\n```nix\ntraceSeqN 2 { a.b.c = 3; } null\ntrace: { a = { b = {…}; }; }\n=> null\n```\n\n# Type\n\n```\ntraceSeqN :: Int -> a -> b -> b\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 15,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/debug.nix",
          "line": 149
        }
      }
    },
    "path": ["lib", "debug", "traceSeqN"]
  },
  {
    "aliases": [
      ["lib", "traceSeq"],
      ["lib", "debug", "traceSeq"]
    ],
    "docs": {
      "attrDocs": {
        "content": "`builtins.trace`, but the value is `builtins.deepSeq`ed first.\n\n# Example\n\n```nix\ntrace { a.b.c = 3; } null\ntrace: { a = <CODE>; }\n=> null\ntraceSeq { a.b.c = 3; } null\ntrace: { a = { b = { c = 3; }; }; }\n=> null\n```\n\n# Type\n\n```\ntraceSeq :: a -> b -> b\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/debug.nix",
          "line": 124
        }
      },
      "lambdaDocs": {
        "content": "`builtins.trace`, but the value is `builtins.deepSeq`ed first.\n\n# Example\n\n```nix\ntrace { a.b.c = 3; } null\ntrace: { a = <CODE>; }\n=> null\ntraceSeq { a.b.c = 3; } null\ntrace: { a = { b = { c = 3; }; }; }\n=> null\n```\n\n# Type\n\n```\ntraceSeq :: a -> b -> b\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/debug.nix",
          "line": 126
        }
      }
    },
    "path": ["lib", "debug", "traceSeq"]
  },
  {
    "aliases": [
      ["lib", "traceIf"],
      ["lib", "debug", "traceIf"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Conditionally trace the supplied message, based on a predicate.\n\n# Example\n\n```nix\ntraceIf true \"hello\" 3\ntrace: hello\n=> 3\n```\n\n# Type\n\n```\ntraceIf :: bool -> string -> a -> a\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/debug.nix",
          "line": 53
        }
      },
      "lambdaDocs": {
        "content": "Conditionally trace the supplied message, based on a predicate.\n\n# Example\n\n```nix\ntraceIf true \"hello\" 3\ntrace: hello\n=> 3\n```\n\n# Type\n\n```\ntraceIf :: bool -> string -> a -> a\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/debug.nix",
          "line": 55
        }
      }
    },
    "path": ["lib", "debug", "traceIf"]
  },
  {
    "aliases": [
      ["lib", "traceFnSeqN"],
      ["lib", "debug", "traceFnSeqN"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/debug.nix",
          "line": 209
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/debug.nix",
          "line": 209
        }
      }
    },
    "path": ["lib", "debug", "traceFnSeqN"]
  },
  {
    "aliases": [
      ["lib", "testAllTrue"],
      ["lib", "debug", "testAllTrue"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Create a test assuming that list elements are `true`.\n\n# Example\n\n```nix\n{ testX = allTrue [ true ]; }\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/debug.nix",
          "line": 307
        }
      },
      "lambdaDocs": {
        "content": "Create a test assuming that list elements are `true`.\n\n# Example\n\n```nix\n{ testX = allTrue [ true ]; }\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/debug.nix",
          "line": 307
        }
      }
    },
    "path": ["lib", "debug", "testAllTrue"]
  },
  {
    "aliases": [
      ["lib", "runTests"],
      ["lib", "debug", "runTests"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Evaluates a set of tests.\n\nA test is an attribute set `{expr, expected}`,\ndenoting an expression and its expected result.\n\nThe result is a `list` of __failed tests__, each represented as\n`{name, expected, result}`,\n\n- expected\n- What was passed as `expected`\n- result\n- The actual `result` of the test\n\nUsed for regression testing of the functions in lib; see\ntests.nix for more examples.\n\nImportant: Only attributes that start with `test` are executed.\n\n- If you want to run only a subset of the tests add the attribute `tests = [\"testName\"];`\n\n# Example\n\n```nix\nrunTests {\n  testAndOk = {\n    expr = lib.and true false;\n    expected = false;\n  };\n  testAndFail = {\n    expr = lib.and true false;\n    expected = true;\n  };\n}\n->\n[\n  {\n    name = \"testAndFail\";\n    expected = true;\n    result = false;\n  }\n]\n```\n\n# Type\n\n```\nrunTests :: {\ntests = [ String ];\n${testName} :: {\nexpr :: a;\nexpected :: a;\n};\n}\n->\n[\n{\nname :: String;\nexpected :: a;\nresult :: a;\n}\n]\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/debug.nix",
          "line": 287
        }
      },
      "lambdaDocs": {
        "content": "Evaluates a set of tests.\n\nA test is an attribute set `{expr, expected}`,\ndenoting an expression and its expected result.\n\nThe result is a `list` of __failed tests__, each represented as\n`{name, expected, result}`,\n\n- expected\n- What was passed as `expected`\n- result\n- The actual `result` of the test\n\nUsed for regression testing of the functions in lib; see\ntests.nix for more examples.\n\nImportant: Only attributes that start with `test` are executed.\n\n- If you want to run only a subset of the tests add the attribute `tests = [\"testName\"];`\n\n# Example\n\n```nix\nrunTests {\n  testAndOk = {\n    expr = lib.and true false;\n    expected = false;\n  };\n  testAndFail = {\n    expr = lib.and true false;\n    expected = true;\n  };\n}\n->\n[\n  {\n    name = \"testAndFail\";\n    expected = true;\n    result = false;\n  }\n]\n```\n\n# Type\n\n```\nrunTests :: {\ntests = [ String ];\n${testName} :: {\nexpr :: a;\nexpected :: a;\n};\n}\n->\n[\n{\nname :: String;\nexpected :: a;\nresult :: a;\n}\n]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/debug.nix",
          "line": 289
        }
      }
    },
    "path": ["lib", "debug", "runTests"]
  },
  {
    "aliases": [
      ["lib", "overrideDerivation"],
      ["lib", "customisation", "overrideDerivation"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/customisation.nix",
          "line": 40
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/customisation.nix",
          "line": 40
        }
      }
    },
    "path": ["lib", "customisation", "overrideDerivation"]
  },
  {
    "aliases": [
      ["lib", "makeScopeWithSplicing'"],
      ["lib", "customisation", "makeScopeWithSplicing'"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Like makeScope, but aims to support cross compilation. It's still ugly, but\nhopefully it helps a little bit.",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/customisation.nix",
          "line": 305
        }
      },
      "lambdaDocs": {
        "content": "Like makeScope, but aims to support cross compilation. It's still ugly, but\nhopefully it helps a little bit.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/customisation.nix",
          "line": 306
        }
      }
    },
    "path": ["lib", "customisation", "makeScopeWithSplicing'"]
  },
  {
    "aliases": [
      ["lib", "makeScopeWithSplicing"],
      ["lib", "customisation", "makeScopeWithSplicing"]
    ],
    "docs": {
      "attrDocs": {
        "content": "backward compatibility with old uncurried form; deprecated",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/customisation.nix",
          "line": 295
        }
      },
      "lambdaDocs": {
        "content": "backward compatibility with old uncurried form; deprecated",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/customisation.nix",
          "line": 296
        }
      }
    },
    "path": ["lib", "customisation", "makeScopeWithSplicing"]
  },
  {
    "aliases": [
      ["lib", "makeScope"],
      ["lib", "customisation", "makeScope"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Make a set of packages with a common scope. All packages called\nwith the provided `callPackage` will be evaluated with the same\narguments. Any package in the set may depend on any other. The\n`overrideScope'` function allows subsequent modification of the package\nset in a consistent way, i.e. all packages in the set will be\ncalled with the overridden packages. The package sets may be\nhierarchical: the packages in the set are called with the scope\nprovided by `newScope` and the set provides a `newScope` attribute\nwhich can form the parent scope for later package sets.",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/customisation.nix",
          "line": 279
        }
      },
      "lambdaDocs": {
        "content": "Make a set of packages with a common scope. All packages called\nwith the provided `callPackage` will be evaluated with the same\narguments. Any package in the set may depend on any other. The\n`overrideScope'` function allows subsequent modification of the package\nset in a consistent way, i.e. all packages in the set will be\ncalled with the overridden packages. The package sets may be\nhierarchical: the packages in the set are called with the scope\nprovided by `newScope` and the set provides a `newScope` attribute\nwhich can form the parent scope for later package sets.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 15,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/customisation.nix",
          "line": 279
        }
      }
    },
    "path": ["lib", "customisation", "makeScope"]
  },
  {
    "aliases": [
      ["lib", "makeOverridable"],
      ["lib", "customisation", "makeOverridable"],
      ["pkgs", "makeOverridable"]
    ],
    "docs": {
      "attrDocs": {
        "content": "`makeOverridable` takes a function from attribute set to attribute set and\ninjects `override` attribute which can be used to override arguments of\nthe function.\n\nnix-repl> x = {a, b}: { result = a + b; }\n\nnix-repl> y = lib.makeOverridable x { a = 1; b = 2; }\n\nnix-repl> y\n{ override = «lambda»; overrideDerivation = «lambda»; result = 3; }\n\nnix-repl> y.override { a = 10; }\n{ override = «lambda»; overrideDerivation = «lambda»; result = 12; }\n\nPlease refer to \"Nixpkgs Contributors Guide\" section\n\"<pkg>.overrideDerivation\" to learn about `overrideDerivation` and caveats\nrelated to its use.",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/customisation.nix",
          "line": 74
        }
      },
      "lambdaDocs": {
        "content": "`makeOverridable` takes a function from attribute set to attribute set and\ninjects `override` attribute which can be used to override arguments of\nthe function.\n\nnix-repl> x = {a, b}: { result = a + b; }\n\nnix-repl> y = lib.makeOverridable x { a = 1; b = 2; }\n\nnix-repl> y\n{ override = «lambda»; overrideDerivation = «lambda»; result = 3; }\n\nnix-repl> y.override { a = 10; }\n{ override = «lambda»; overrideDerivation = «lambda»; result = 12; }\n\nPlease refer to \"Nixpkgs Contributors Guide\" section\n\"<pkg>.overrideDerivation\" to learn about `overrideDerivation` and caveats\nrelated to its use.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/customisation.nix",
          "line": 74
        }
      }
    },
    "path": ["lib", "customisation", "makeOverridable"]
  },
  {
    "aliases": [
      ["lib", "hydraJob"],
      ["lib", "customisation", "hydraJob"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Strip a derivation of all non-essential attributes, returning\nonly those needed by hydra-eval-jobs. Also strictly evaluate the\nresult to ensure that there are no thunks kept alive to prevent\ngarbage collection.",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/customisation.nix",
          "line": 239
        }
      },
      "lambdaDocs": {
        "content": "Strip a derivation of all non-essential attributes, returning\nonly those needed by hydra-eval-jobs. Also strictly evaluate the\nresult to ensure that there are no thunks kept alive to prevent\ngarbage collection.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/customisation.nix",
          "line": 239
        }
      }
    },
    "path": ["lib", "customisation", "hydraJob"]
  },
  {
    "aliases": [
      ["lib", "extendDerivation"],
      ["lib", "customisation", "extendDerivation"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Add attributes to each output of a derivation without changing\nthe derivation itself and check a given condition when evaluating.",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/customisation.nix",
          "line": 203
        }
      },
      "lambdaDocs": {
        "content": "Add attributes to each output of a derivation without changing\nthe derivation itself and check a given condition when evaluating.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 22,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/customisation.nix",
          "line": 203
        }
      }
    },
    "path": ["lib", "customisation", "extendDerivation"]
  },
  {
    "aliases": [
      ["lib", "customisation", "callPackagesWith"],
      ["lib", "callPackagesWith"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Like callPackage, but for a function that returns an attribute\nset of derivations. The override function is added to the\nindividual attributes.",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/customisation.nix",
          "line": 184
        }
      },
      "lambdaDocs": {
        "content": "Like callPackage, but for a function that returns an attribute\nset of derivations. The override function is added to the\nindividual attributes.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 22,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/customisation.nix",
          "line": 184
        }
      }
    },
    "path": ["lib", "customisation", "callPackagesWith"]
  },
  {
    "aliases": [
      ["lib", "customisation", "callPackageWith"],
      ["lib", "callPackageWith"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/customisation.nix",
          "line": 125
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/customisation.nix",
          "line": 125
        }
      }
    },
    "path": ["lib", "customisation", "callPackageWith"]
  },
  {
    "aliases": [
      ["lib", "lists", "crossLists"],
      ["lib", "crossLists"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 92
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 6,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 1042
        }
      }
    },
    "path": ["lib", "crossLists"]
  },
  {
    "aliases": [
      ["lib", "lists", "count"],
      ["lib", "count"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 92
        }
      },
      "lambdaDocs": {
        "content": "Count how many elements of `list` match the supplied predicate\nfunction.\n\n# Example\n\n```nix\ncount (x: x == 3) [ 3 2 3 4 6 ]\n=> 2\n```\n\n# Type\n\n```\ncount :: (a -> bool) -> [a] -> int\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 420
        }
      }
    },
    "path": ["lib", "count"]
  },
  {
    "aliases": [
      ["lib", "fixedPoints", "converge"],
      ["lib", "converge"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 31,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 80
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/fixed-points.nix",
          "line": 55
        }
      }
    },
    "path": ["lib", "converge"]
  },
  {
    "aliases": [
      ["lib", "trivial", "const"],
      ["lib", "const"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 73
        }
      },
      "lambdaDocs": {
        "content": "The constant function\n\nIgnores the second argument. If called with only one argument,\nconstructs a function that always returns a static value.\n\n# Example\n\n```nix\nlet f = const 5; in f 10\n=> 5\n```\n\n# Type\n\n```\nconst :: a -> b -> a\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 42
        }
      }
    },
    "path": ["lib", "const"]
  },
  {
    "aliases": [
      ["lib", "misc", "condConcat"],
      ["lib", "condConcat"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 156
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 16,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 114
        }
      }
    },
    "path": ["lib", "condConcat"]
  },
  {
    "aliases": [
      ["lib", "strings", "concatStringsSep"],
      ["lib", "concatStringsSep"],
      ["builtins", "concatStringsSep"],
      ["builtins", "concatStringsSep"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "Concatenate a list of strings with a separator between each\nelement, e.g. `concatStringsSep \"/\" [\"usr\" \"local\" \"bin\"] ==\n\"usr/local/bin\"`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "concatStringsSep"]
  },
  {
    "aliases": [
      ["lib", "strings", "concatStrings"],
      ["lib", "concatStrings"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "Concatenate a list of strings with a separator between each\nelement, e.g. `concatStringsSep \"/\" [\"usr\" \"local\" \"bin\"] ==\n\"usr/local/bin\"`.",
        "countApplied": 1,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "concatStrings"]
  },
  {
    "aliases": [
      ["lib", "strings", "concatMapStringsSep"],
      ["lib", "concatMapStringsSep"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "Maps a function over a list of strings and then concatenates the\nresult with the specified separator interspersed between\nelements.\n\n# Example\n\n```nix\nconcatMapStringsSep \"-\" (x: toUpper x)  [\"foo\" \"bar\" \"baz\"]\n=> \"FOO-BAR-BAZ\"\n```\n\n# Type\n\n```\nconcatMapStringsSep :: string -> (a -> string) -> [a] -> string\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 163
        }
      }
    },
    "path": ["lib", "concatMapStringsSep"]
  },
  {
    "aliases": [
      ["lib", "strings", "concatMapStrings"],
      ["lib", "concatMapStrings"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "Map a function over a list and concatenate the resulting strings.\n\n# Example\n\n```nix\nconcatMapStrings (x: \"a\" + x) [\"foo\" \"bar\"]\n=> \"afooabar\"\n```\n\n# Type\n\n```\nconcatMapStrings :: (a -> string) -> [a] -> string\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 22,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 78
        }
      }
    },
    "path": ["lib", "concatMapStrings"]
  },
  {
    "aliases": [
      ["lib", "concatMapAttrs"],
      ["lib", "attrsets", "concatMapAttrs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "Map each attribute in the given set and merge them into a new attribute set.\n\n# Example\n\n```nix\nconcatMapAttrs\n  (name: value: {\n    ${name} = value;\n    ${name + value} = value;\n  })\n  { x = \"a\"; y = \"b\"; }\n=> { x = \"a\"; xa = \"a\"; y = \"b\"; yb = \"b\"; }\n```\n\n# Type\n\n```\nconcatMapAttrs :: (String -> a -> AttrSet) -> AttrSet -> AttrSet\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 20,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 160
        }
      }
    },
    "path": ["lib", "concatMapAttrs"]
  },
  {
    "aliases": [
      ["lib", "lists", "concatMap"],
      ["lib", "concatMap"],
      ["builtins", "concatMap"],
      ["builtins", "concatMap"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 92
        }
      },
      "lambdaDocs": {
        "content": "This function is equivalent to `builtins.concatLists (map f list)`\nbut is more efficient.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "concatMap"]
  },
  {
    "aliases": [
      ["lib", "lists", "concatLists"],
      ["lib", "concatLists"],
      ["builtins", "concatLists"],
      ["builtins", "concatLists"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 68
        }
      },
      "lambdaDocs": {
        "content": "Concatenate a list of lists into a single list.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "concatLists"]
  },
  {
    "aliases": [
      ["lib", "strings", "concatLines"],
      ["lib", "concatLines"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "Map a function over a list and concatenate the resulting strings.\n\n# Example\n\n```nix\nconcatMapStrings (x: \"a\" + x) [\"foo\" \"bar\"]\n=> \"afooabar\"\n```\n\n# Type\n\n```\nconcatMapStrings :: (a -> string) -> [a] -> string\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 78
        }
      }
    },
    "path": ["lib", "concatLines"]
  },
  {
    "aliases": [
      ["lib", "strings", "concatImapStringsSep"],
      ["lib", "concatImapStringsSep"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 188
        }
      }
    },
    "path": ["lib", "concatImapStringsSep"]
  },
  {
    "aliases": [
      ["lib", "strings", "concatImapStrings"],
      ["lib", "concatImapStrings"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "Like `concatMapStrings` except that the f functions also gets the\nposition as a parameter.\n\n# Example\n\n```nix\nconcatImapStrings (pos: x: \"${toString pos}-${x}\") [\"foo\" \"bar\"]\n=> \"1-foo2-bar\"\n```\n\n# Type\n\n```\nconcatImapStrings :: (int -> a -> string) -> [a] -> string\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 97
        }
      }
    },
    "path": ["lib", "concatImapStrings"]
  },
  {
    "aliases": [
      ["lib", "trivial", "concat"],
      ["lib", "mergeAttrBy", "propagatedBuildInputs"],
      ["lib", "mergeAttrBy", "prePhases"],
      ["lib", "mergeAttrBy", "postAll"],
      ["lib", "mergeAttrBy", "patches"],
      ["lib", "mergeAttrBy", "nativeBuildInputs"],
      ["lib", "mergeAttrBy", "configureFlags"],
      ["lib", "mergeAttrBy", "buildInputs"],
      ["lib", "concat"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 73
        }
      },
      "lambdaDocs": {
        "content": "Concatenate two lists\n\n# Example\n\n```nix\nconcat [ 1 2 ] [ 3 4 ]\n=> [ 1 2 3 4 ]\n```\n\n# Type\n\n```\nconcat :: [a] -> [a] -> [a]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 12,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 111
        }
      }
    },
    "path": ["lib", "concat"]
  },
  {
    "aliases": [
      ["lib", "fixedPoints", "composeManyExtensions"],
      ["lib", "composeManyExtensions"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 31,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 80
        }
      },
      "lambdaDocs": {
        "content": "“right fold” a binary function `op` between successive elements of\n`list` with `nul` as the starting value, i.e.,\n`foldr op nul [x_1 x_2 ... x_n] == op x_1 (op x_2 ... (op x_n nul))`.\n\n# Example\n\n```nix\nconcat = foldr (a: b: a + b) \"z\"\nconcat [ \"a\" \"b\" \"c\" ]\n=> \"abcz\"\n# different types\nstrange = foldr (int: str: toString (int + 1) + str) \"a\"\nstrange [ 1 2 3 4 ]\n=> \"2345a\"\n```\n\n# Type\n\n```\nfoldr :: (a -> b -> b) -> b -> [a] -> b\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 20,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 77
        }
      }
    },
    "path": ["lib", "composeManyExtensions"]
  },
  {
    "aliases": [
      ["lib", "fixedPoints", "composeExtensions"],
      ["lib", "composeExtensions"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 31,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 80
        }
      },
      "lambdaDocs": {
        "content": "Compose two extending functions of the type expected by 'extends'\ninto one where changes made in the first are available in the\n'super' of the second",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/fixed-points.nix",
          "line": 107
        }
      }
    },
    "path": ["lib", "composeExtensions"]
  },
  {
    "aliases": [
      ["lib", "lists", "compareLists"],
      ["lib", "compareLists"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 92
        }
      },
      "lambdaDocs": {
        "content": "Compare two lists element-by-element.\n\n# Example\n\n```nix\ncompareLists compare [] []\n=> 0\ncompareLists compare [] [ \"a\" ]\n=> -1\ncompareLists compare [ \"a\" ] []\n=> 1\ncompareLists compare [ \"a\" \"b\" ] [ \"a\" \"c\" ]\n=> -1\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 18,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/lists.nix",
          "line": 787
        }
      }
    },
    "path": ["lib", "compareLists"]
  },
  {
    "aliases": [
      ["lib", "trivial", "compare"],
      ["lib", "compare"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 73
        }
      },
      "lambdaDocs": {
        "content": "C-style comparisons\n\na < b,  compare a b => -1\na == b, compare a b => 0\na > b,  compare a b => 1",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 13,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 367
        }
      }
    },
    "path": ["lib", "compare"]
  },
  {
    "aliases": [
      ["lib", "sources", "commitIdFromGitRepo"],
      ["lib", "commitIdFromGitRepo"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 124
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/sources.nix",
          "line": 184
        }
      }
    },
    "path": ["lib", "commitIdFromGitRepo"]
  },
  {
    "aliases": [
      ["lib", "collect"],
      ["lib", "attrsets", "collect"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 544
        }
      }
    },
    "path": ["lib", "collect"]
  },
  {
    "aliases": [
      ["lib", "misc", "closePropagationFast"],
      ["lib", "misc", "closePropagation"],
      ["lib", "closePropagation"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 156
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 26,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 168
        }
      }
    },
    "path": ["lib", "closePropagation"]
  },
  {
    "aliases": [["lib", "cli", "toGNUCommandLineShell"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/cli.nix",
          "line": 46
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/cli.nix",
          "line": 47
        }
      }
    },
    "path": ["lib", "cli", "toGNUCommandLineShell"]
  },
  {
    "aliases": [["lib", "cli", "toGNUCommandLine"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/cli.nix",
          "line": 49
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 22,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/cli.nix",
          "line": 49
        }
      }
    },
    "path": ["lib", "cli", "toGNUCommandLine"]
  },
  {
    "aliases": [
      ["lib", "sources", "cleanSourceWith"],
      ["lib", "cleanSourceWith"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 124
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/sources.nix",
          "line": 76
        }
      }
    },
    "path": ["lib", "cleanSourceWith"]
  },
  {
    "aliases": [
      ["lib", "sources", "cleanSourceFilter"],
      ["lib", "cleanSourceFilter"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 124
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/sources.nix",
          "line": 26
        }
      }
    },
    "path": ["lib", "cleanSourceFilter"]
  },
  {
    "aliases": [
      ["lib", "sources", "cleanSource"],
      ["lib", "cleanSource"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 124
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/sources.nix",
          "line": 52
        }
      }
    },
    "path": ["lib", "cleanSource"]
  },
  {
    "aliases": [
      ["lib", "chooseDevOutputs"],
      ["lib", "attrsets", "chooseDevOutputs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "Pick the outputs of packages to place in `buildInputs`\n\n# Type\n\n```\nchooseDevOutputs :: [Derivation] -> [String]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1273
        }
      }
    },
    "path": ["lib", "chooseDevOutputs"]
  },
  {
    "aliases": [
      ["lib", "misc", "checkReqs"],
      ["lib", "checkReqs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 156
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 15,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 78
        }
      }
    },
    "path": ["lib", "checkReqs"]
  },
  {
    "aliases": [
      ["lib", "trivial", "checkListOfEnum"],
      ["lib", "checkListOfEnum"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 73
        }
      },
      "lambdaDocs": {
        "content": "Check if the elements in a list are valid values from a enum, returning the identity function, or throwing an error message otherwise.\n\n# Example\n\n```nix\nlet colorVariants = [\"bright\" \"dark\" \"black\"]\nin checkListOfEnum \"color variants\" [ \"standard\" \"light\" \"dark\" ] colorVariants;\n=>\nerror: color variants: bright, black unexpected; valid ones: standard, light, dark\n```\n\n# Type\n\n```\nString -> List ComparableVal -> List ComparableVal -> a -> a\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 552
        }
      }
    },
    "path": ["lib", "checkListOfEnum"]
  },
  {
    "aliases": [
      ["lib", "misc", "checkFlag"],
      ["lib", "checkFlag"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 156
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 15,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/deprecated.nix",
          "line": 57
        }
      }
    },
    "path": ["lib", "checkFlag"]
  },
  {
    "aliases": [
      ["lib", "catAttrs"],
      ["lib", "attrsets", "catAttrs"],
      ["builtins", "catAttrs"],
      ["builtins", "catAttrs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "Collect each attribute named *attr* from a list of attribute\nsets.  Attrsets that don't contain the named attribute are\nignored. For example,\n\n```nix\nbuiltins.catAttrs \"a\" [{a = 1;} {b = 0;} {a = 2;}]\n```\n\nevaluates to `[1 2]`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "catAttrs"]
  },
  {
    "aliases": [
      ["lib", "cartesianProductOfSets"],
      ["lib", "attrsets", "cartesianProductOfSets"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "Return the cartesian product of attribute set value combinations.\n\n# Example\n\n```nix\ncartesianProductOfSets { a = [ 1 2 ]; b = [ 10 20 ]; }\n=> [\n     { a = 1; b = 10; }\n     { a = 1; b = 20; }\n     { a = 2; b = 10; }\n     { a = 2; b = 20; }\n   ]\n```\n\n# Type\n\n```\ncartesianProductOfSets :: AttrSet -> [AttrSet]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 577
        }
      }
    },
    "path": ["lib", "cartesianProductOfSets"]
  },
  {
    "aliases": [
      ["lib", "sources", "canCleanSource"],
      ["lib", "canCleanSource"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 124
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 20,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/sources.nix",
          "line": 247
        }
      }
    },
    "path": ["lib", "canCleanSource"]
  },
  {
    "aliases": [
      ["lib", "customisation", "callPackagesWith"],
      ["lib", "callPackagesWith"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 33,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 116
        }
      },
      "lambdaDocs": {
        "content": "Like callPackage, but for a function that returns an attribute\nset of derivations. The override function is added to the\nindividual attributes.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 22,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/customisation.nix",
          "line": 184
        }
      }
    },
    "path": ["lib", "callPackagesWith"]
  },
  {
    "aliases": [
      ["lib", "customisation", "callPackageWith"],
      ["lib", "callPackageWith"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 33,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 116
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/customisation.nix",
          "line": 125
        }
      }
    },
    "path": ["lib", "callPackageWith"]
  },
  {
    "aliases": [
      ["lib", "trivial", "boolToString"],
      ["lib", "boolToString"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 73
        }
      },
      "lambdaDocs": {
        "content": "Convert a boolean to a string.\n\nThis function uses the strings \"true\" and \"false\" to represent\nboolean values. Calling `toString` on a bool instead returns \"1\"\nand \"\" (sic!).\n\n# Type\n\n```\nboolToString :: bool -> string\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 18,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 162
        }
      }
    },
    "path": ["lib", "boolToString"]
  },
  {
    "aliases": [
      ["lib", "trivial", "bitXor"],
      ["lib", "bitXor"],
      ["builtins", "bitXor"],
      ["builtins", "bitXor"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 73
        }
      },
      "lambdaDocs": {
        "content": "Return the bitwise XOR of the integers *e1* and *e2*.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "bitXor"]
  },
  {
    "aliases": [
      ["lib", "trivial", "bitOr"],
      ["lib", "bitOr"],
      ["builtins", "bitOr"],
      ["builtins", "bitOr"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 73
        }
      },
      "lambdaDocs": {
        "content": "Return the bitwise OR of the integers *e1* and *e2*.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "bitOr"]
  },
  {
    "aliases": [
      ["lib", "trivial", "bitNot"],
      ["lib", "bitNot"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 73
        }
      },
      "lambdaDocs": {
        "content": "Return the difference between the numbers *e1* and *e2*.",
        "countApplied": 1,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "bitNot"]
  },
  {
    "aliases": [
      ["lib", "trivial", "bitAnd"],
      ["lib", "bitAnd"],
      ["builtins", "bitAnd"],
      ["builtins", "bitAnd"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 73
        }
      },
      "lambdaDocs": {
        "content": "Return the bitwise AND of the integers *e1* and *e2*.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "bitAnd"]
  },
  {
    "aliases": [
      ["lib", "zipWithNames"],
      ["lib", "zipAttrsWithNames"],
      ["lib", "attrsets", "zipWithNames"],
      ["lib", "attrsets", "zipAttrsWithNames"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1342
        }
      },
      "lambdaDocs": {
        "content": "Merge sets of attributes and use the function `f` to merge attributes\nvalues.\n\n# Example\n\n```nix\nzipAttrsWithNames [\"a\"] (name: vs: vs) [{a = \"x\";} {a = \"y\"; b = \"z\";}]\n=> { a = [\"x\" \"y\"]; }\n```\n\n# Type\n\n```\nzipAttrsWithNames :: [ String ] -> (String -> [ Any ] -> Any) -> [ AttrSet ] -> AttrSet\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 879
        }
      }
    },
    "path": ["lib", "attrsets", "zipWithNames"]
  },
  {
    "aliases": [
      ["lib", "zipWithNames"],
      ["lib", "zipAttrsWithNames"],
      ["lib", "attrsets", "zipWithNames"],
      ["lib", "attrsets", "zipAttrsWithNames"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Merge sets of attributes and use the function `f` to merge attributes\nvalues.\n\n# Example\n\n```nix\nzipAttrsWithNames [\"a\"] (name: vs: vs) [{a = \"x\";} {a = \"y\"; b = \"z\";}]\n=> { a = [\"x\" \"y\"]; }\n```\n\n# Type\n\n```\nzipAttrsWithNames :: [ String ] -> (String -> [ Any ] -> Any) -> [ AttrSet ] -> AttrSet\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 877
        }
      },
      "lambdaDocs": {
        "content": "Merge sets of attributes and use the function `f` to merge attributes\nvalues.\n\n# Example\n\n```nix\nzipAttrsWithNames [\"a\"] (name: vs: vs) [{a = \"x\";} {a = \"y\"; b = \"z\";}]\n=> { a = [\"x\" \"y\"]; }\n```\n\n# Type\n\n```\nzipAttrsWithNames :: [ String ] -> (String -> [ Any ] -> Any) -> [ AttrSet ] -> AttrSet\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 879
        }
      }
    },
    "path": ["lib", "attrsets", "zipAttrsWithNames"]
  },
  {
    "aliases": [
      ["lib", "zipAttrsWith"],
      ["lib", "zip"],
      ["lib", "attrsets", "zipAttrsWith"],
      ["lib", "attrsets", "zip"],
      ["builtins", "zipAttrsWith"],
      ["builtins", "zipAttrsWith"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Merge sets of attributes and use the function f to merge attribute values.\nLike `lib.attrsets.zipAttrsWithNames` with all key names are passed for `names`.\n\nImplementation note: Common names appear multiple times in the list of\nnames, hopefully this does not affect the system because the maximal\nlaziness avoid computing twice the same expression and `listToAttrs` does\nnot care about duplicated attribute names.\n\n# Example\n\n```nix\nzipAttrsWith (name: values: values) [{a = \"x\";} {a = \"y\"; b = \"z\";}]\n=> { a = [\"x\" \"y\"]; b = [\"z\"]; }\n```\n\n# Type\n\n```\nzipAttrsWith :: (String -> [ Any ] -> Any) -> [ AttrSet ] -> AttrSet\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 912
        }
      },
      "lambdaDocs": {
        "content": "Transpose a list of attribute sets into an attribute set of lists,\nthen apply `mapAttrs`.\n\n`f` receives two arguments: the attribute name and a non-empty\nlist of all values encountered for that attribute name.\n\nThe result is an attribute set where the attribute names are the\nunion of the attribute names in each element of `list`. The attribute\nvalues are the return values of `f`.\n\n```nix\nbuiltins.zipAttrsWith\n  (name: values: { inherit name values; })\n  [ { a = \"x\"; } { a = \"y\"; b = \"z\"; } ]\n```\n\nevaluates to\n\n```\n{\n  a = { name = \"a\"; values = [ \"x\" \"y\" ]; };\n  b = { name = \"b\"; values = [ \"z\" ]; };\n}\n```",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "attrsets", "zipAttrsWith"]
  },
  {
    "aliases": [
      ["lib", "zipAttrs"],
      ["lib", "attrsets", "zipAttrs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Merge sets of attributes and combine each attribute value in to a list.\n\nLike `lib.attrsets.zipAttrsWith` with `(name: values: values)` as the function.\n\n# Example\n\n```nix\nzipAttrs [{a = \"x\";} {a = \"y\"; b = \"z\";}]\n=> { a = [\"x\" \"y\"]; b = [\"z\"]; }\n```\n\n# Type\n\n```\nzipAttrs :: [ AttrSet ] -> AttrSet\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 934
        }
      },
      "lambdaDocs": {
        "content": "Merge sets of attributes and combine each attribute value in to a list.\n\nLike `lib.attrsets.zipAttrsWith` with `(name: values: values)` as the function.\n\n# Example\n\n```nix\nzipAttrs [{a = \"x\";} {a = \"y\"; b = \"z\";}]\n=> { a = [\"x\" \"y\"]; b = [\"z\"]; }\n```\n\n# Type\n\n```\nzipAttrs :: [ AttrSet ] -> AttrSet\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 936
        }
      }
    },
    "path": ["lib", "attrsets", "zipAttrs"]
  },
  {
    "aliases": [
      ["lib", "zipAttrsWith"],
      ["lib", "zip"],
      ["lib", "attrsets", "zipAttrsWith"],
      ["lib", "attrsets", "zip"],
      ["builtins", "zipAttrsWith"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1345
        }
      },
      "lambdaDocs": {
        "content": "Transpose a list of attribute sets into an attribute set of lists,\nthen apply `mapAttrs`.\n\n`f` receives two arguments: the attribute name and a non-empty\nlist of all values encountered for that attribute name.\n\nThe result is an attribute set where the attribute names are the\nunion of the attribute names in each element of `list`. The attribute\nvalues are the return values of `f`.\n\n```nix\nbuiltins.zipAttrsWith\n  (name: values: { inherit name values; })\n  [ { a = \"x\"; } { a = \"y\"; b = \"z\"; } ]\n```\n\nevaluates to\n\n```\n{\n  a = { name = \"a\"; values = [ \"x\" \"y\" ]; };\n  b = { name = \"b\"; values = [ \"z\" ]; };\n}\n```",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "attrsets", "zip"]
  },
  {
    "aliases": [
      ["lib", "updateManyAttrsByPath"],
      ["lib", "attrsets", "updateManyAttrsByPath"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Update or set specific paths of an attribute set.\n\nTakes a list of updates to apply and an attribute set to apply them to,\nand returns the attribute set with the updates applied. Updates are\nrepresented as `{ path = ...; update = ...; }` values, where `path` is a\nlist of strings representing the attribute path that should be updated,\nand `update` is a function that takes the old value at that attribute path\nas an argument and returns the new\nvalue it should be.\n\nProperties:\n\n- Updates to deeper attribute paths are applied before updates to more\nshallow attribute paths\n\n- Multiple updates to the same attribute path are applied in the order\nthey appear in the update list\n\n- If any but the last `path` element leads into a value that is not an\nattribute set, an error is thrown\n\n- If there is an update for an attribute path that doesn't exist,\naccessing the argument in the update function causes an error, but\nintermediate attribute sets are implicitly created as needed\n\n# Example\n\n```nix\nupdateManyAttrsByPath [\n  {\n    path = [ \"a\" \"b\" ];\n    update = old: { d = old.c; };\n  }\n  {\n    path = [ \"a\" \"b\" \"c\" ];\n    update = old: old + 1;\n  }\n  {\n    path = [ \"x\" \"y\" ];\n    update = old: \"xy\";\n  }\n] { a.b.c = 0; }\n=> { a = { b = { d = 1; }; }; x = { y = \"xy\"; }; }\n```\n\n# Type\n\n```\nupdateManyAttrsByPath :: [{ path :: [String]; update :: (Any -> Any); }] -> AttrSet -> AttrSet\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 219
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 6,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 276
        }
      }
    },
    "path": ["lib", "attrsets", "updateManyAttrsByPath"]
  },
  {
    "aliases": [["lib", "attrsets", "unionOfDisjoint"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1331
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1331
        }
      }
    },
    "path": ["lib", "attrsets", "unionOfDisjoint"]
  },
  {
    "aliases": [
      ["lib", "toDerivation"],
      ["lib", "attrsets", "toDerivation"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Converts a store path to a fake derivation.\n\n# Type\n\n```\ntoDerivation :: Path -> Derivation\n```",
        "position": {
          "column": 4,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 817
        }
      },
      "lambdaDocs": {
        "content": "Converts a store path to a fake derivation.\n\n# Type\n\n```\ntoDerivation :: Path -> Derivation\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 6,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 819
        }
      }
    },
    "path": ["lib", "attrsets", "toDerivation"]
  },
  {
    "aliases": [
      ["lib", "showAttrPath"],
      ["lib", "attrsets", "showAttrPath"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Turns a list of strings into a human-readable description of those\nstrings represented as an attribute path. The result of this function is\nnot intended to be machine-readable.\nCreate a new attribute set with `value` set at the nested attribute location specified in `attrPath`.\n\n# Example\n\n```nix\nshowAttrPath [ \"foo\" \"10\" \"bar\" ]\n=> \"foo.\\\"10\\\".bar\"\nshowAttrPath []\n=> \"<root attribute path>\"\n```\n\n# Type\n\n```\nshowAttrPath :: [String] -> String\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1154
        }
      },
      "lambdaDocs": {
        "content": "Turns a list of strings into a human-readable description of those\nstrings represented as an attribute path. The result of this function is\nnot intended to be machine-readable.\nCreate a new attribute set with `value` set at the nested attribute location specified in `attrPath`.\n\n# Example\n\n```nix\nshowAttrPath [ \"foo\" \"10\" \"bar\" ]\n=> \"foo.\\\"10\\\".bar\"\nshowAttrPath []\n=> \"<root attribute path>\"\n```\n\n# Type\n\n```\nshowAttrPath :: [String] -> String\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1156
        }
      }
    },
    "path": ["lib", "attrsets", "showAttrPath"]
  },
  {
    "aliases": [
      ["lib", "setAttrByPath"],
      ["lib", "attrsets", "setAttrByPath"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Create a new attribute set with `value` set at the nested attribute location specified in `attrPath`.\n\n# Example\n\n```nix\nsetAttrByPath [\"a\" \"b\"] 3\n=> { a = { b = 3; }; }\n```\n\n# Type\n\n```\nsetAttrByPath :: [String] -> Any -> AttrSet\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "Create a new attribute set with `value` set at the nested attribute location specified in `attrPath`.\n\n# Example\n\n```nix\nsetAttrByPath [\"a\" \"b\"] 3\n=> { a = { b = 3; }; }\n```\n\n# Type\n\n```\nsetAttrByPath :: [String] -> Any -> AttrSet\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 100
        }
      }
    },
    "path": ["lib", "attrsets", "setAttrByPath"]
  },
  {
    "aliases": [
      ["lib", "attrsets", "removeAttrs"],
      ["builtins", "removeAttrs"],
      ["builtins", "removeAttrs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 12
        }
      },
      "lambdaDocs": {
        "content": "Remove the attributes listed in *list* from *set*. The attributes\ndon’t have to exist in *set*. For instance,\n\n```nix\nremoveAttrs { x = 1; y = 2; z = 3; } [ \"a\" \"x\" \"z\" ]\n```\n\nevaluates to `{ y = 2; }`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "attrsets", "removeAttrs"]
  },
  {
    "aliases": [
      ["lib", "recursiveUpdateUntil"],
      ["lib", "attrsets", "recursiveUpdateUntil"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1019
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1021
        }
      }
    },
    "path": ["lib", "attrsets", "recursiveUpdateUntil"]
  },
  {
    "aliases": [
      ["lib", "recursiveUpdate"],
      ["lib", "attrsets", "recursiveUpdate"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1066
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1068
        }
      }
    },
    "path": ["lib", "attrsets", "recursiveUpdate"]
  },
  {
    "aliases": [
      ["lib", "recurseIntoAttrs"],
      ["lib", "attrsets", "recurseIntoAttrs"],
      ["pkgs", "recurseIntoAttrs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Make various Nix tools consider the contents of the resulting\nattribute set when looking for what to build, find, etc.\n\nThis function only affects a single attribute set; it does not\napply itself recursively for nested attribute sets.\n\n# Example\n\n```nix\n{ pkgs ? import <nixpkgs> {} }:\n{\n  myTools = pkgs.lib.recurseIntoAttrs {\n    inherit (pkgs) hello figlet;\n  };\n}\n```\n\n# Type\n\n```\nrecurseIntoAttrs :: AttrSet -> AttrSet\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1300
        }
      },
      "lambdaDocs": {
        "content": "Make various Nix tools consider the contents of the resulting\nattribute set when looking for what to build, find, etc.\n\nThis function only affects a single attribute set; it does not\napply itself recursively for nested attribute sets.\n\n# Example\n\n```nix\n{ pkgs ? import <nixpkgs> {} }:\n{\n  myTools = pkgs.lib.recurseIntoAttrs {\n    inherit (pkgs) hello figlet;\n  };\n}\n```\n\n# Type\n\n```\nrecurseIntoAttrs :: AttrSet -> AttrSet\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1302
        }
      }
    },
    "path": ["lib", "attrsets", "recurseIntoAttrs"]
  },
  {
    "aliases": [
      ["lib", "overrideExisting"],
      ["lib", "attrsets", "overrideExisting"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Override only the attributes that are already present in the old set\nuseful for deep-overriding.\n\n# Example\n\n```nix\noverrideExisting {} { a = 1; }\n=> {}\noverrideExisting { b = 2; } { a = 1; }\n=> { b = 2; }\noverrideExisting { a = 3; b = 2; } { a = 1; }\n=> { a = 1; b = 2; }\n```\n\n# Type\n\n```\noverrideExisting :: AttrSet -> AttrSet -> AttrSet\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1125
        }
      },
      "lambdaDocs": {
        "content": "Override only the attributes that are already present in the old set\nuseful for deep-overriding.\n\n# Example\n\n```nix\noverrideExisting {} { a = 1; }\n=> {}\noverrideExisting { b = 2; } { a = 1; }\n=> { b = 2; }\noverrideExisting { a = 3; b = 2; } { a = 1; }\n=> { a = 1; b = 2; }\n```\n\n# Type\n\n```\noverrideExisting :: AttrSet -> AttrSet -> AttrSet\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1127
        }
      }
    },
    "path": ["lib", "attrsets", "overrideExisting"]
  },
  {
    "aliases": [
      ["lib", "optionalAttrs"],
      ["lib", "attrsets", "optionalAttrs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "If `cond` is true, return the attribute set `as`,\notherwise an empty attribute set.\n\n# Example\n\n```nix\noptionalAttrs (true) { my = \"set\"; }\n=> { my = \"set\"; }\noptionalAttrs (false) { my = \"set\"; }\n=> { }\n```\n\n# Type\n\n```\noptionalAttrs :: Bool -> AttrSet -> AttrSet\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 852
        }
      },
      "lambdaDocs": {
        "content": "If `cond` is true, return the attribute set `as`,\notherwise an empty attribute set.\n\n# Example\n\n```nix\noptionalAttrs (true) { my = \"set\"; }\n=> { my = \"set\"; }\noptionalAttrs (false) { my = \"set\"; }\n=> { }\n```\n\n# Type\n\n```\noptionalAttrs :: Bool -> AttrSet -> AttrSet\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 854
        }
      }
    },
    "path": ["lib", "attrsets", "optionalAttrs"]
  },
  {
    "aliases": [
      ["lib", "nameValuePair"],
      ["lib", "attrsets", "nameValuePair"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Utility function that creates a `{name, value}` pair as expected by `builtins.listToAttrs`.\n\n# Example\n\n```nix\nnameValuePair \"some\" 6\n=> { name = \"some\"; value = 6; }\n```\n\n# Type\n\n```\nnameValuePair :: String -> Any -> { name :: String; value :: Any; }\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 601
        }
      },
      "lambdaDocs": {
        "content": "Utility function that creates a `{name, value}` pair as expected by `builtins.listToAttrs`.\n\n# Example\n\n```nix\nnameValuePair \"some\" 6\n=> { name = \"some\"; value = 6; }\n```\n\n# Type\n\n```\nnameValuePair :: String -> Any -> { name :: String; value :: Any; }\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 603
        }
      }
    },
    "path": ["lib", "attrsets", "nameValuePair"]
  },
  {
    "aliases": [["lib", "attrsets", "mergeAttrsList"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 960
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 20,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 960
        }
      }
    },
    "path": ["lib", "attrsets", "mergeAttrsList"]
  },
  {
    "aliases": [
      ["lib", "matchAttrs"],
      ["lib", "attrsets", "matchAttrs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Returns true if the pattern is contained in the set. False otherwise.\n\n# Example\n\n```nix\nmatchAttrs { cpu = {}; } { cpu = { bits = 64; }; }\n=> true\n```\n\n# Type\n\n```\nmatchAttrs :: AttrSet -> AttrSet -> Bool\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1090
        }
      },
      "lambdaDocs": {
        "content": "Returns true if the pattern is contained in the set. False otherwise.\n\n# Example\n\n```nix\nmatchAttrs { cpu = {}; } { cpu = { bits = 64; }; }\n=> true\n```\n\n# Type\n\n```\nmatchAttrs :: AttrSet -> AttrSet -> Bool\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1092
        }
      }
    },
    "path": ["lib", "attrsets", "matchAttrs"]
  },
  {
    "aliases": [
      ["lib", "mapAttrsToList"],
      ["lib", "attrsets", "mapAttrsToList"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Call a function for each attribute in the given set and return\nthe result in a list.\n\n# Example\n\n```nix\nmapAttrsToList (name: value: name + value)\n   { x = \"a\"; y = \"b\"; }\n=> [ \"xa\" \"yb\" ]\n```\n\n# Type\n\n```\nmapAttrsToList :: (String -> a -> b) -> AttrSet -> [b]\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 676
        }
      },
      "lambdaDocs": {
        "content": "Call a function for each attribute in the given set and return\nthe result in a list.\n\n# Example\n\n```nix\nmapAttrsToList (name: value: name + value)\n   { x = \"a\"; y = \"b\"; }\n=> [ \"xa\" \"yb\" ]\n```\n\n# Type\n\n```\nmapAttrsToList :: (String -> a -> b) -> AttrSet -> [b]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 678
        }
      }
    },
    "path": ["lib", "attrsets", "mapAttrsToList"]
  },
  {
    "aliases": [
      ["lib", "mapAttrsRecursiveCond"],
      ["lib", "attrsets", "mapAttrsRecursiveCond"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Like `mapAttrsRecursive`, but it takes an additional predicate\nfunction that tells it whether to recurse into an attribute\nset.  If it returns false, `mapAttrsRecursiveCond` does not\nrecurse, but does apply the map function.  If it returns true, it\ndoes recurse, and does not apply the map function.\n\n# Example\n\n```nix\n# To prevent recursing into derivations (which are attribute\n# sets with the attribute \"type\" equal to \"derivation\"):\nmapAttrsRecursiveCond\n  (as: !(as ? \"type\" && as.type == \"derivation\"))\n  (x: ... do something ...)\n  attrs\n```\n\n# Type\n\n```\nmapAttrsRecursiveCond :: (AttrSet -> Bool) -> ([String] -> a -> b) -> AttrSet -> AttrSet\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 740
        }
      },
      "lambdaDocs": {
        "content": "Like `mapAttrsRecursive`, but it takes an additional predicate\nfunction that tells it whether to recurse into an attribute\nset.  If it returns false, `mapAttrsRecursiveCond` does not\nrecurse, but does apply the map function.  If it returns true, it\ndoes recurse, and does not apply the map function.\n\n# Example\n\n```nix\n# To prevent recursing into derivations (which are attribute\n# sets with the attribute \"type\" equal to \"derivation\"):\nmapAttrsRecursiveCond\n  (as: !(as ? \"type\" && as.type == \"derivation\"))\n  (x: ... do something ...)\n  attrs\n```\n\n# Type\n\n```\nmapAttrsRecursiveCond :: (AttrSet -> Bool) -> ([String] -> a -> b) -> AttrSet -> AttrSet\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 742
        }
      }
    },
    "path": ["lib", "attrsets", "mapAttrsRecursiveCond"]
  },
  {
    "aliases": [
      ["lib", "mapAttrsRecursive"],
      ["lib", "attrsets", "mapAttrsRecursive"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 708
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 710
        }
      }
    },
    "path": ["lib", "attrsets", "mapAttrsRecursive"]
  },
  {
    "aliases": [
      ["lib", "mapAttrs'"],
      ["lib", "attrsets", "mapAttrs'"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Like `mapAttrs`, but allows the name of each attribute to be\nchanged in addition to the value.  The applied function should\nreturn both the new name and value as a `nameValuePair`.\n\n# Example\n\n```nix\nmapAttrs' (name: value: nameValuePair (\"foo_\" + name) (\"bar-\" + value))\n   { x = \"a\"; y = \"b\"; }\n=> { foo_x = \"bar-a\"; foo_y = \"bar-b\"; }\n```\n\n# Type\n\n```\nmapAttrs' :: (String -> Any -> { name :: String; value :: Any; }) -> AttrSet -> AttrSet\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 650
        }
      },
      "lambdaDocs": {
        "content": "Like `mapAttrs`, but allows the name of each attribute to be\nchanged in addition to the value.  The applied function should\nreturn both the new name and value as a `nameValuePair`.\n\n# Example\n\n```nix\nmapAttrs' (name: value: nameValuePair (\"foo_\" + name) (\"bar-\" + value))\n   { x = \"a\"; y = \"b\"; }\n=> { foo_x = \"bar-a\"; foo_y = \"bar-b\"; }\n```\n\n# Type\n\n```\nmapAttrs' :: (String -> Any -> { name :: String; value :: Any; }) -> AttrSet -> AttrSet\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 652
        }
      }
    },
    "path": ["lib", "attrsets", "mapAttrs'"]
  },
  {
    "aliases": [
      ["lib", "mapAttrs"],
      ["lib", "attrsets", "mapAttrs"],
      ["builtins", "mapAttrs"],
      ["builtins", "mapAttrs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Apply a function to each element in an attribute set, creating a new attribute set.\n\n# Example\n\n```nix\nmapAttrs (name: value: name + \"-\" + value)\n   { x = \"foo\"; y = \"bar\"; }\n=> { x = \"x-foo\"; y = \"y-bar\"; }\n```\n\n# Type\n\n```\nmapAttrs :: (String -> Any -> Any) -> AttrSet -> AttrSet\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 626
        }
      },
      "lambdaDocs": {
        "content": "Apply function *f* to every element of *attrset*. For example,\n\n```nix\nbuiltins.mapAttrs (name: value: value * 10) { a = 1; b = 2; }\n```\n\nevaluates to `{ a = 10; b = 20; }`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "attrsets", "mapAttrs"]
  },
  {
    "aliases": [
      ["lib", "listToAttrs"],
      ["lib", "attrsets", "listToAttrs"],
      ["builtins", "listToAttrs"],
      ["builtins", "listToAttrs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 12
        }
      },
      "lambdaDocs": {
        "content": "Construct a set from a list specifying the names and values of each\nattribute. Each element of the list should be a set consisting of a\nstring-valued attribute `name` specifying the name of the attribute,\nand an attribute `value` specifying its value.\n\nIn case of duplicate occurrences of the same name, the first\ntakes precedence.\n\nExample:\n\n```nix\nbuiltins.listToAttrs\n  [ { name = \"foo\"; value = 123; }\n    { name = \"bar\"; value = 456; }\n    { name = \"bar\"; value = 420; }\n  ]\n```\n\nevaluates to\n\n```nix\n{ foo = 123; bar = 456; }\n```",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "attrsets", "listToAttrs"]
  },
  {
    "aliases": [
      ["lib", "isDerivation"],
      ["lib", "attrsets", "isDerivation"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Check whether the argument is a derivation. Any set with\n`{ type = \"derivation\"; }` counts as a derivation.\n\n# Example\n\n```nix\nnixpkgs = import <nixpkgs> {}\nisDerivation nixpkgs.ruby\n=> true\nisDerivation \"foobar\"\n=> false\n```\n\n# Type\n\n```\nisDerivation :: Any -> Bool\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 804
        }
      },
      "lambdaDocs": {
        "content": "Check whether the argument is a derivation. Any set with\n`{ type = \"derivation\"; }` counts as a derivation.\n\n# Example\n\n```nix\nnixpkgs = import <nixpkgs> {}\nisDerivation nixpkgs.ruby\n=> true\nisDerivation \"foobar\"\n=> false\n```\n\n# Type\n\n```\nisDerivation :: Any -> Bool\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 806
        }
      }
    },
    "path": ["lib", "attrsets", "isDerivation"]
  },
  {
    "aliases": [
      ["lib", "strings", "isAttrs"],
      ["lib", "isAttrs"],
      ["lib", "attrsets", "isAttrs"],
      ["builtins", "isAttrs"],
      ["builtins", "isAttrs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 12
        }
      },
      "lambdaDocs": {
        "content": "Return `true` if *e* evaluates to a set, and `false` otherwise.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "attrsets", "isAttrs"]
  },
  {
    "aliases": [
      ["lib", "hasAttrByPath"],
      ["lib", "attrsets", "hasAttrByPath"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Return if an attribute from nested attribute set exists.\n\n# Example\n\n```nix\nx = { a = { b = 3; }; }\nhasAttrByPath [\"a\" \"b\"] x\n=> true\nhasAttrByPath [\"z\" \"z\"] x\n=> false\n```\n\n# Type\n\n```\nhasAttrByPath :: [String] -> AttrSet -> Bool\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 69
        }
      },
      "lambdaDocs": {
        "content": "Return if an attribute from nested attribute set exists.\n\n# Example\n\n```nix\nx = { a = { b = 3; }; }\nhasAttrByPath [\"a\" \"b\"] x\n=> true\nhasAttrByPath [\"z\" \"z\"] x\n=> false\n```\n\n# Type\n\n```\nhasAttrByPath :: [String] -> AttrSet -> Bool\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 71
        }
      }
    },
    "path": ["lib", "attrsets", "hasAttrByPath"]
  },
  {
    "aliases": [
      ["lib", "hasAttr"],
      ["lib", "attrsets", "hasAttr"],
      ["builtins", "hasAttr"],
      ["builtins", "hasAttr"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 12
        }
      },
      "lambdaDocs": {
        "content": "`hasAttr` returns `true` if *set* has an attribute named *s*, and\n`false` otherwise. This is a dynamic version of the `?` operator,\nsince *s* is an expression rather than an identifier.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "attrsets", "hasAttr"]
  },
  {
    "aliases": [
      ["lib", "getOutput"],
      ["lib", "attrsets", "getOutput"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1178
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 15,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1178
        }
      }
    },
    "path": ["lib", "attrsets", "getOutput"]
  },
  {
    "aliases": [
      ["lib", "getMan"],
      ["lib", "getLib"],
      ["lib", "getDev"],
      ["lib", "getBin"],
      ["lib", "attrsets", "getMan"],
      ["lib", "attrsets", "getLib"],
      ["lib", "attrsets", "getDev"],
      ["lib", "attrsets", "getBin"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1260
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1178
        }
      }
    },
    "path": ["lib", "attrsets", "getMan"]
  },
  {
    "aliases": [
      ["lib", "getMan"],
      ["lib", "getLib"],
      ["lib", "getDev"],
      ["lib", "getBin"],
      ["lib", "attrsets", "getMan"],
      ["lib", "attrsets", "getLib"],
      ["lib", "attrsets", "getDev"],
      ["lib", "attrsets", "getBin"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1220
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1178
        }
      }
    },
    "path": ["lib", "attrsets", "getLib"]
  },
  {
    "aliases": [
      ["lib", "getMan"],
      ["lib", "getLib"],
      ["lib", "getDev"],
      ["lib", "getBin"],
      ["lib", "attrsets", "getMan"],
      ["lib", "attrsets", "getLib"],
      ["lib", "attrsets", "getDev"],
      ["lib", "attrsets", "getBin"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1240
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1178
        }
      }
    },
    "path": ["lib", "attrsets", "getDev"]
  },
  {
    "aliases": [
      ["lib", "getMan"],
      ["lib", "getLib"],
      ["lib", "getDev"],
      ["lib", "getBin"],
      ["lib", "attrsets", "getMan"],
      ["lib", "attrsets", "getLib"],
      ["lib", "attrsets", "getDev"],
      ["lib", "attrsets", "getBin"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1200
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1178
        }
      }
    },
    "path": ["lib", "attrsets", "getBin"]
  },
  {
    "aliases": [
      ["lib", "getAttrs"],
      ["lib", "attrsets", "getAttrs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Given a set of attribute names, return the set of the corresponding\nattributes from the given set.\n\n# Example\n\n```nix\ngetAttrs [ \"a\" \"b\" ] { a = 1; b = 2; c = 3; }\n=> { a = 1; b = 2; }\n```\n\n# Type\n\n```\ngetAttrs :: [String] -> AttrSet -> AttrSet\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 338
        }
      },
      "lambdaDocs": {
        "content": "Given a set of attribute names, return the set of the corresponding\nattributes from the given set.\n\n# Example\n\n```nix\ngetAttrs [ \"a\" \"b\" ] { a = 1; b = 2; c = 3; }\n=> { a = 1; b = 2; }\n```\n\n# Type\n\n```\ngetAttrs :: [String] -> AttrSet -> AttrSet\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 340
        }
      }
    },
    "path": ["lib", "attrsets", "getAttrs"]
  },
  {
    "aliases": [
      ["lib", "getAttrFromPath"],
      ["lib", "attrsets", "getAttrFromPath"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Like `attrByPath`, but without a default value. If it doesn't find the\npath it will throw an error.\n\n# Example\n\n```nix\nx = { a = { b = 3; }; }\ngetAttrFromPath [\"a\" \"b\"] x\n=> 3\ngetAttrFromPath [\"z\" \"z\"] x\n=> error: cannot find attribute `z.z'\n```\n\n# Type\n\n```\ngetAttrFromPath :: [String] -> AttrSet -> Any\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 131
        }
      },
      "lambdaDocs": {
        "content": "Like `attrByPath`, but without a default value. If it doesn't find the\npath it will throw an error.\n\n# Example\n\n```nix\nx = { a = { b = 3; }; }\ngetAttrFromPath [\"a\" \"b\"] x\n=> 3\ngetAttrFromPath [\"z\" \"z\"] x\n=> error: cannot find attribute `z.z'\n```\n\n# Type\n\n```\ngetAttrFromPath :: [String] -> AttrSet -> Any\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 133
        }
      }
    },
    "path": ["lib", "attrsets", "getAttrFromPath"]
  },
  {
    "aliases": [
      ["lib", "getAttr"],
      ["lib", "attrsets", "getAttr"],
      ["builtins", "getAttr"],
      ["builtins", "getAttr"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 12
        }
      },
      "lambdaDocs": {
        "content": "`getAttr` returns the attribute named *s* from *set*. Evaluation\naborts if the attribute doesn’t exist. This is a dynamic version of\nthe `.` operator, since *s* is an expression rather than an\nidentifier.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "attrsets", "getAttr"]
  },
  {
    "aliases": [
      ["lib", "genAttrs"],
      ["lib", "attrsets", "genAttrs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Generate an attribute set by mapping a function over a list of\nattribute names.\n\n# Example\n\n```nix\ngenAttrs [ \"foo\" \"bar\" ] (name: \"x_\" + name)\n=> { foo = \"x_foo\"; bar = \"x_bar\"; }\n```\n\n# Type\n\n```\ngenAttrs :: [ String ] -> (String -> Any) -> AttrSet\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 776
        }
      },
      "lambdaDocs": {
        "content": "Generate an attribute set by mapping a function over a list of\nattribute names.\n\n# Example\n\n```nix\ngenAttrs [ \"foo\" \"bar\" ] (name: \"x_\" + name)\n=> { foo = \"x_foo\"; bar = \"x_bar\"; }\n```\n\n# Type\n\n```\ngenAttrs :: [ String ] -> (String -> Any) -> AttrSet\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 778
        }
      }
    },
    "path": ["lib", "attrsets", "genAttrs"]
  },
  {
    "aliases": [
      ["lib", "foldlAttrs"],
      ["lib", "attrsets", "foldlAttrs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 484
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 16,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 484
        }
      }
    },
    "path": ["lib", "attrsets", "foldlAttrs"]
  },
  {
    "aliases": [
      ["lib", "foldAttrs"],
      ["lib", "attrsets", "foldAttrs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Apply fold functions to values grouped by key.\n\n# Example\n\n```nix\nfoldAttrs (item: acc: [item] ++ acc) [] [{ a = 2; } { a = 3; }]\n=> { a = [ 2 3 ]; }\n```\n\n# Type\n\n```\nfoldAttrs :: (Any -> Any -> Any) -> Any -> [AttrSets] -> Any\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 506
        }
      },
      "lambdaDocs": {
        "content": "Apply fold functions to values grouped by key.\n\n# Example\n\n```nix\nfoldAttrs (item: acc: [item] ++ acc) [] [{ a = 2; } { a = 3; }]\n=> { a = [ 2 3 ]; }\n```\n\n# Type\n\n```\nfoldAttrs :: (Any -> Any -> Any) -> Any -> [AttrSets] -> Any\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 508
        }
      }
    },
    "path": ["lib", "attrsets", "foldAttrs"]
  },
  {
    "aliases": [
      ["lib", "filterAttrsRecursive"],
      ["lib", "attrsets", "filterAttrsRecursive"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Filter an attribute set recursively by removing all attributes for\nwhich the given predicate return false.\n\n# Example\n\n```nix\nfilterAttrsRecursive (n: v: v != null) { foo = { bar = null; }; }\n=> { foo = {}; }\n```\n\n# Type\n\n```\nfilterAttrsRecursive :: (String -> Any -> Bool) -> AttrSet -> AttrSet\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 407
        }
      },
      "lambdaDocs": {
        "content": "Filter an attribute set recursively by removing all attributes for\nwhich the given predicate return false.\n\n# Example\n\n```nix\nfilterAttrsRecursive (n: v: v != null) { foo = { bar = null; }; }\n=> { foo = {}; }\n```\n\n# Type\n\n```\nfilterAttrsRecursive :: (String -> Any -> Bool) -> AttrSet -> AttrSet\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 409
        }
      }
    },
    "path": ["lib", "attrsets", "filterAttrsRecursive"]
  },
  {
    "aliases": [
      ["lib", "filterAttrs"],
      ["lib", "attrsets", "filterAttrs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Filter an attribute set by removing all attributes for which the\ngiven predicate return false.\n\n# Example\n\n```nix\nfilterAttrs (n: v: n == \"foo\") { foo = 1; bar = 2; }\n=> { foo = 1; }\n```\n\n# Type\n\n```\nfilterAttrs :: (String -> Any -> Bool) -> AttrSet -> AttrSet\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 382
        }
      },
      "lambdaDocs": {
        "content": "Filter an attribute set by removing all attributes for which the\ngiven predicate return false.\n\n# Example\n\n```nix\nfilterAttrs (n: v: n == \"foo\") { foo = 1; bar = 2; }\n=> { foo = 1; }\n```\n\n# Type\n\n```\nfilterAttrs :: (String -> Any -> Bool) -> AttrSet -> AttrSet\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 384
        }
      }
    },
    "path": ["lib", "attrsets", "filterAttrs"]
  },
  {
    "aliases": [
      ["lib", "dontRecurseIntoAttrs"],
      ["lib", "attrsets", "dontRecurseIntoAttrs"],
      ["pkgs", "dontRecurseIntoAttrs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Undo the effect of recurseIntoAttrs.\n\n# Type\n\n```\ndontRecurseIntoAttrs :: AttrSet -> AttrSet\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1314
        }
      },
      "lambdaDocs": {
        "content": "Undo the effect of recurseIntoAttrs.\n\n# Type\n\n```\ndontRecurseIntoAttrs :: AttrSet -> AttrSet\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1316
        }
      }
    },
    "path": ["lib", "attrsets", "dontRecurseIntoAttrs"]
  },
  {
    "aliases": [
      ["lib", "concatMapAttrs"],
      ["lib", "attrsets", "concatMapAttrs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Map each attribute in the given set and merge them into a new attribute set.\n\n# Example\n\n```nix\nconcatMapAttrs\n  (name: value: {\n    ${name} = value;\n    ${name + value} = value;\n  })\n  { x = \"a\"; y = \"b\"; }\n=> { x = \"a\"; xa = \"a\"; y = \"b\"; yb = \"b\"; }\n```\n\n# Type\n\n```\nconcatMapAttrs :: (String -> a -> AttrSet) -> AttrSet -> AttrSet\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 160
        }
      },
      "lambdaDocs": {
        "content": "Map each attribute in the given set and merge them into a new attribute set.\n\n# Example\n\n```nix\nconcatMapAttrs\n  (name: value: {\n    ${name} = value;\n    ${name + value} = value;\n  })\n  { x = \"a\"; y = \"b\"; }\n=> { x = \"a\"; xa = \"a\"; y = \"b\"; yb = \"b\"; }\n```\n\n# Type\n\n```\nconcatMapAttrs :: (String -> a -> AttrSet) -> AttrSet -> AttrSet\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 20,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 160
        }
      }
    },
    "path": ["lib", "attrsets", "concatMapAttrs"]
  },
  {
    "aliases": [
      ["lib", "collect"],
      ["lib", "attrsets", "collect"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 542
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 544
        }
      }
    },
    "path": ["lib", "attrsets", "collect"]
  },
  {
    "aliases": [
      ["lib", "chooseDevOutputs"],
      ["lib", "attrsets", "chooseDevOutputs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Pick the outputs of packages to place in `buildInputs`\n\n# Type\n\n```\nchooseDevOutputs :: [Derivation] -> [String]\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1271
        }
      },
      "lambdaDocs": {
        "content": "Pick the outputs of packages to place in `buildInputs`\n\n# Type\n\n```\nchooseDevOutputs :: [Derivation] -> [String]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1273
        }
      }
    },
    "path": ["lib", "attrsets", "chooseDevOutputs"]
  },
  {
    "aliases": [
      ["lib", "catAttrs"],
      ["lib", "attrsets", "catAttrs"],
      ["builtins", "catAttrs"],
      ["builtins", "catAttrs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Collect each attribute named `attr` from a list of attribute\nsets.  Sets that don't contain the named attribute are ignored.\n\n# Example\n\n```nix\ncatAttrs \"a\" [{a = 1;} {b = 0;} {a = 2;}]\n=> [1 2]\n```\n\n# Type\n\n```\ncatAttrs :: String -> [AttrSet] -> [Any]\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 361
        }
      },
      "lambdaDocs": {
        "content": "Collect each attribute named *attr* from a list of attribute\nsets.  Attrsets that don't contain the named attribute are\nignored. For example,\n\n```nix\nbuiltins.catAttrs \"a\" [{a = 1;} {b = 0;} {a = 2;}]\n```\n\nevaluates to `[1 2]`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "attrsets", "catAttrs"]
  },
  {
    "aliases": [
      ["lib", "cartesianProductOfSets"],
      ["lib", "attrsets", "cartesianProductOfSets"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Return the cartesian product of attribute set value combinations.\n\n# Example\n\n```nix\ncartesianProductOfSets { a = [ 1 2 ]; b = [ 10 20 ]; }\n=> [\n     { a = 1; b = 10; }\n     { a = 1; b = 20; }\n     { a = 2; b = 10; }\n     { a = 2; b = 20; }\n   ]\n```\n\n# Type\n\n```\ncartesianProductOfSets :: AttrSet -> [AttrSet]\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 575
        }
      },
      "lambdaDocs": {
        "content": "Return the cartesian product of attribute set value combinations.\n\n# Example\n\n```nix\ncartesianProductOfSets { a = [ 1 2 ]; b = [ 10 20 ]; }\n=> [\n     { a = 1; b = 10; }\n     { a = 1; b = 20; }\n     { a = 2; b = 10; }\n     { a = 2; b = 20; }\n   ]\n```\n\n# Type\n\n```\ncartesianProductOfSets :: AttrSet -> [AttrSet]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 577
        }
      }
    },
    "path": ["lib", "attrsets", "cartesianProductOfSets"]
  },
  {
    "aliases": [
      ["lib", "attrsets", "attrValues"],
      ["lib", "attrValues"],
      ["builtins", "attrValues"],
      ["builtins", "attrValues"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Return the values of all attributes in the given set, sorted by\nattribute name.\n\n# Example\n\n```nix\nattrValues {c = 3; a = 1; b = 2;}\n=> [1 2 3]\n```\n\n# Type\n\n```\nattrValues :: AttrSet -> [Any]\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 318
        }
      },
      "lambdaDocs": {
        "content": "Return the values of the attributes in the set *set* in the order\ncorresponding to the sorted attribute names.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "attrsets", "attrValues"]
  },
  {
    "aliases": [
      ["lib", "attrsets", "attrVals"],
      ["lib", "attrVals"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Return the specified attributes from a set.\n\n# Example\n\n```nix\nattrVals [\"a\" \"b\" \"c\"] as\n=> [as.a as.b as.c]\n```\n\n# Type\n\n```\nattrVals :: [String] -> AttrSet -> [Any]\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 294
        }
      },
      "lambdaDocs": {
        "content": "Return the specified attributes from a set.\n\n# Example\n\n```nix\nattrVals [\"a\" \"b\" \"c\"] as\n=> [as.a as.b as.c]\n```\n\n# Type\n\n```\nattrVals :: [String] -> AttrSet -> [Any]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 296
        }
      }
    },
    "path": ["lib", "attrsets", "attrVals"]
  },
  {
    "aliases": [
      ["lib", "attrsets", "attrNames"],
      ["lib", "attrNames"],
      ["builtins", "attrNames"],
      ["builtins", "attrNames"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 12
        }
      },
      "lambdaDocs": {
        "content": "Return the names of the attributes in the set *set* in an\nalphabetically sorted list. For instance, `builtins.attrNames { y\n= 1; x = \"foo\"; }` evaluates to `[ \"x\" \"y\" ]`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "attrsets", "attrNames"]
  },
  {
    "aliases": [
      ["lib", "attrsets", "attrByPath"],
      ["lib", "attrByPath"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Return an attribute from nested attribute sets.\n\n# Example\n\n```nix\nx = { a = { b = 3; }; }\n# [\"a\" \"b\"] is equivalent to x.a.b\n# 6 is a default value to return if the path does not exist in attrset\nattrByPath [\"a\" \"b\"] 6 x\n=> 3\nattrByPath [\"z\" \"z\"] 6 x\n=> 6\n```\n\n# Type\n\n```\nattrByPath :: [String] -> Any -> AttrSet -> Any\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 36
        }
      },
      "lambdaDocs": {
        "content": "Return an attribute from nested attribute sets.\n\n# Example\n\n```nix\nx = { a = { b = 3; }; }\n# [\"a\" \"b\"] is equivalent to x.a.b\n# 6 is a default value to return if the path does not exist in attrset\nattrByPath [\"a\" \"b\"] 6 x\n=> 3\nattrByPath [\"z\" \"z\"] 6 x\n=> 6\n```\n\n# Type\n\n```\nattrByPath :: [String] -> Any -> AttrSet -> Any\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 38
        }
      }
    },
    "path": ["lib", "attrsets", "attrByPath"]
  },
  {
    "aliases": [
      ["lib", "attrsets", "attrValues"],
      ["lib", "attrValues"],
      ["builtins", "attrValues"],
      ["builtins", "attrValues"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "Return the values of the attributes in the set *set* in the order\ncorresponding to the sorted attribute names.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "attrValues"]
  },
  {
    "aliases": [
      ["lib", "attrsets", "attrVals"],
      ["lib", "attrVals"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "Return the specified attributes from a set.\n\n# Example\n\n```nix\nattrVals [\"a\" \"b\" \"c\"] as\n=> [as.a as.b as.c]\n```\n\n# Type\n\n```\nattrVals :: [String] -> AttrSet -> [Any]\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 296
        }
      }
    },
    "path": ["lib", "attrVals"]
  },
  {
    "aliases": [
      ["lib", "attrsets", "attrNames"],
      ["lib", "attrNames"],
      ["builtins", "attrNames"],
      ["builtins", "attrNames"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 68
        }
      },
      "lambdaDocs": {
        "content": "Return the names of the attributes in the set *set* in an\nalphabetically sorted list. For instance, `builtins.attrNames { y\n= 1; x = \"foo\"; }` evaluates to `[ \"x\" \"y\" ]`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "attrNames"]
  },
  {
    "aliases": [
      ["lib", "attrsets", "attrByPath"],
      ["lib", "attrByPath"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 82
        }
      },
      "lambdaDocs": {
        "content": "Return an attribute from nested attribute sets.\n\n# Example\n\n```nix\nx = { a = { b = 3; }; }\n# [\"a\" \"b\"] is equivalent to x.a.b\n# 6 is a default value to return if the path does not exist in attrset\nattrByPath [\"a\" \"b\"] 6 x\n=> 3\nattrByPath [\"z\" \"z\"] 6 x\n=> 6\n```\n\n# Type\n\n```\nattrByPath :: [String] -> Any -> AttrSet -> Any\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 38
        }
      }
    },
    "path": ["lib", "attrByPath"]
  },
  {
    "aliases": [
      ["lib", "asserts", "assertOneOf"],
      ["lib", "assertOneOf"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Specialized `assertMsg` for checking if `val` is one of the elements\nof the list `xs`. Useful for checking enums.\n\n# Example\n\n```nix\nlet sslLibrary = \"libressl\";\nin assertOneOf \"sslLibrary\" sslLibrary [ \"openssl\" \"bearssl\" ]\nstderr> error: sslLibrary must be one of [\nstderr>   \"openssl\"\nstderr>   \"bearssl\"\nstderr> ], but is: \"libressl\"\n```\n\n# Type\n\n```\nassertOneOf :: String -> ComparableVal -> List ComparableVal -> Bool\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/asserts.nix",
          "line": 54
        }
      },
      "lambdaDocs": {
        "content": "Specialized `assertMsg` for checking if `val` is one of the elements\nof the list `xs`. Useful for checking enums.\n\n# Example\n\n```nix\nlet sslLibrary = \"libressl\";\nin assertOneOf \"sslLibrary\" sslLibrary [ \"openssl\" \"bearssl\" ]\nstderr> error: sslLibrary must be one of [\nstderr>   \"openssl\"\nstderr>   \"bearssl\"\nstderr> ], but is: \"libressl\"\n```\n\n# Type\n\n```\nassertOneOf :: String -> ComparableVal -> List ComparableVal -> Bool\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/asserts.nix",
          "line": 56
        }
      }
    },
    "path": ["lib", "asserts", "assertOneOf"]
  },
  {
    "aliases": [
      ["lib", "asserts", "assertMsg"],
      ["lib", "assertMsg"]
    ],
    "docs": {
      "attrDocs": {
        "content": "Throw if pred is false, else return pred.\nIntended to be used to augment asserts with helpful error messages.\n\n# Example\n\n```nix\nassertMsg false \"nope\"\n           stderr> error: nope\n\n           assert assertMsg (\"foo\" == \"bar\") \"foo is not bar, silly\"; \"\"\n           stderr> error: foo is not bar, silly\n```\n\n# Type\n\n```\nassertMsg :: Bool -> String -> Bool\n```",
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/asserts.nix",
          "line": 26
        }
      },
      "lambdaDocs": {
        "content": "Throw if pred is false, else return pred.\nIntended to be used to augment asserts with helpful error messages.\n\n# Example\n\n```nix\nassertMsg false \"nope\"\n           stderr> error: nope\n\n           assert assertMsg (\"foo\" == \"bar\") \"foo is not bar, silly\"; \"\"\n           stderr> error: foo is not bar, silly\n```\n\n# Type\n\n```\nassertMsg :: Bool -> String -> Bool\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/asserts.nix",
          "line": 28
        }
      }
    },
    "path": ["lib", "asserts", "assertMsg"]
  },
  {
    "aliases": [
      ["lib", "asserts", "assertOneOf"],
      ["lib", "assertOneOf"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 150
        }
      },
      "lambdaDocs": {
        "content": "Specialized `assertMsg` for checking if `val` is one of the elements\nof the list `xs`. Useful for checking enums.\n\n# Example\n\n```nix\nlet sslLibrary = \"libressl\";\nin assertOneOf \"sslLibrary\" sslLibrary [ \"openssl\" \"bearssl\" ]\nstderr> error: sslLibrary must be one of [\nstderr>   \"openssl\"\nstderr>   \"bearssl\"\nstderr> ], but is: \"libressl\"\n```\n\n# Type\n\n```\nassertOneOf :: String -> ComparableVal -> List ComparableVal -> Bool\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/asserts.nix",
          "line": 56
        }
      }
    },
    "path": ["lib", "assertOneOf"]
  },
  {
    "aliases": [
      ["lib", "asserts", "assertMsg"],
      ["lib", "assertMsg"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 150
        }
      },
      "lambdaDocs": {
        "content": "Throw if pred is false, else return pred.\nIntended to be used to augment asserts with helpful error messages.\n\n# Example\n\n```nix\nassertMsg false \"nope\"\n           stderr> error: nope\n\n           assert assertMsg (\"foo\" == \"bar\") \"foo is not bar, silly\"; \"\"\n           stderr> error: foo is not bar, silly\n```\n\n# Type\n\n```\nassertMsg :: Bool -> String -> Bool\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/asserts.nix",
          "line": 28
        }
      }
    },
    "path": ["lib", "assertMsg"]
  },
  {
    "aliases": [
      ["lib", "modules", "applyModuleArgsIfFunction"],
      ["lib", "applyModuleArgsIfFunction"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 128
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 31,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/modules.nix",
          "line": 492
        }
      }
    },
    "path": ["lib", "applyModuleArgsIfFunction"]
  },
  {
    "aliases": [
      ["lib", "meta", "appendToName"],
      ["lib", "appendToName"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 120
        }
      },
      "lambdaDocs": {
        "content": "Append a suffix to the name of a package (before the version\npart).",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 18,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 54
        }
      }
    },
    "path": ["lib", "appendToName"]
  },
  {
    "aliases": [
      ["lib", "lists", "any"],
      ["lib", "any"],
      ["builtins", "any"],
      ["builtins", "any"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 92
        }
      },
      "lambdaDocs": {
        "content": "Return `true` if the function *pred* returns `true` for at least one\nelement of *list*, and `false` otherwise.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "any"]
  },
  {
    "aliases": [
      ["lib", "trivial", "and"],
      ["lib", "and"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 73
        }
      },
      "lambdaDocs": {
        "content": "boolean “and”",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 9,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/trivial.nix",
          "line": 121
        }
      }
    },
    "path": ["lib", "and"]
  },
  {
    "aliases": [
      ["lib", "lists", "all"],
      ["lib", "all"],
      ["builtins", "all"],
      ["builtins", "all"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 92
        }
      },
      "lambdaDocs": {
        "content": "Return `true` if the function *pred* returns `true` for all elements\nof *list*, and `false` otherwise.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "all"]
  },
  {
    "aliases": [
      ["lib", "meta", "addMetaAttrs"],
      ["lib", "addMetaAttrs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 120
        }
      },
      "lambdaDocs": {
        "content": "Add to or override the meta attributes of the given\nderivation.\n\n# Example\n\n```nix\naddMetaAttrs {description = \"Bla blah\";} somePkg\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 18,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 21
        }
      }
    },
    "path": ["lib", "addMetaAttrs"]
  },
  {
    "aliases": [["builtins", "addErrorContext"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 68
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "addErrorContext"]
  },
  {
    "aliases": [
      ["lib", "strings", "addContextFrom"],
      ["lib", "addContextFrom"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 98
        }
      },
      "lambdaDocs": {
        "content": "Appends string context from another string.  This is an implementation\ndetail of Nix and should be used carefully.\n\nStrings in Nix carry an invisible `context` which is a list of strings\nrepresenting store paths.  If the string is later used in a derivation\nattribute, the derivation will properly populate the inputDrvs and\ninputSrcs.\n\n# Example\n\n```nix\npkgs = import <nixpkgs> { };\naddContextFrom pkgs.coreutils \"bar\"\n=> \"bar\"\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 20,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/strings.nix",
          "line": 857
        }
      }
    },
    "path": ["lib", "addContextFrom"]
  },
  {
    "aliases": [
      ["lib", "trivial", "add"],
      ["lib", "add"],
      ["builtins", "add"],
      ["builtins", "add"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/default.nix",
          "line": 68
        }
      },
      "lambdaDocs": {
        "content": "Return the sum of the numbers *e1* and *e2*.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["lib", "add"]
  },
  {
    "aliases": [["lib", "__unfix__"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 30,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/fixed-points.nix",
          "line": 38
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 11,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/fixed-points.nix",
          "line": 152
        }
      }
    },
    "path": ["lib", "__unfix__"]
  },
  {
    "aliases": [
      ["builtins", "abort"],
      ["builtins", "abort"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Abort Nix expression evaluation and print the error message *s*.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "abort"]
  },
  {
    "aliases": [
      ["lib", "trivial", "add"],
      ["lib", "add"],
      ["builtins", "add"],
      ["builtins", "add"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return the sum of the numbers *e1* and *e2*.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "add"]
  },
  {
    "aliases": [["builtins", "addErrorContext"]],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "addErrorContext"]
  },
  {
    "aliases": [
      ["lib", "lists", "all"],
      ["lib", "all"],
      ["builtins", "all"],
      ["builtins", "all"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return `true` if the function *pred* returns `true` for all elements\nof *list*, and `false` otherwise.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "all"]
  },
  {
    "aliases": [
      ["lib", "lists", "any"],
      ["lib", "any"],
      ["builtins", "any"],
      ["builtins", "any"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return `true` if the function *pred* returns `true` for at least one\nelement of *list*, and `false` otherwise.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "any"]
  },
  {
    "aliases": [["builtins", "appendContext"]],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "appendContext"]
  },
  {
    "aliases": [
      ["lib", "attrsets", "attrNames"],
      ["lib", "attrNames"],
      ["builtins", "attrNames"],
      ["builtins", "attrNames"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return the names of the attributes in the set *set* in an\nalphabetically sorted list. For instance, `builtins.attrNames { y\n= 1; x = \"foo\"; }` evaluates to `[ \"x\" \"y\" ]`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "attrNames"]
  },
  {
    "aliases": [
      ["lib", "attrsets", "attrValues"],
      ["lib", "attrValues"],
      ["builtins", "attrValues"],
      ["builtins", "attrValues"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return the values of the attributes in the set *set* in the order\ncorresponding to the sorted attribute names.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "attrValues"]
  },
  {
    "aliases": [
      ["builtins", "baseNameOf"],
      ["builtins", "baseNameOf"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return the *base name* of the string *s*, that is, everything\nfollowing the final slash in the string. This is similar to the GNU\n`basename` command.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "baseNameOf"]
  },
  {
    "aliases": [
      ["lib", "trivial", "bitAnd"],
      ["lib", "bitAnd"],
      ["builtins", "bitAnd"],
      ["builtins", "bitAnd"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return the bitwise AND of the integers *e1* and *e2*.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "bitAnd"]
  },
  {
    "aliases": [
      ["lib", "trivial", "bitOr"],
      ["lib", "bitOr"],
      ["builtins", "bitOr"],
      ["builtins", "bitOr"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return the bitwise OR of the integers *e1* and *e2*.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "bitOr"]
  },
  {
    "aliases": [
      ["lib", "trivial", "bitXor"],
      ["lib", "bitXor"],
      ["builtins", "bitXor"],
      ["builtins", "bitXor"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return the bitwise XOR of the integers *e1* and *e2*.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "bitXor"]
  },
  {
    "aliases": [
      ["builtins", "break"],
      ["builtins", "break"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "In debug mode (enabled using `--debugger`), pause Nix expression evaluation and enter the REPL.\nOtherwise, return the argument `v`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "break"]
  },
  {
    "aliases": [
      ["lib", "catAttrs"],
      ["lib", "attrsets", "catAttrs"],
      ["builtins", "catAttrs"],
      ["builtins", "catAttrs"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Collect each attribute named *attr* from a list of attribute\nsets.  Attrsets that don't contain the named attribute are\nignored. For example,\n\n```nix\nbuiltins.catAttrs \"a\" [{a = 1;} {b = 0;} {a = 2;}]\n```\n\nevaluates to `[1 2]`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "catAttrs"]
  },
  {
    "aliases": [
      ["builtins", "ceil"],
      ["builtins", "ceil"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Converts an IEEE-754 double-precision floating-point number (*double*) to\nthe next higher integer.\n\nIf the datatype is neither an integer nor a \"float\", an evaluation error will be\nthrown.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "ceil"]
  },
  {
    "aliases": [
      ["lib", "strings", "compareVersions"],
      ["builtins", "compareVersions"],
      ["builtins", "compareVersions"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Compare two strings representing versions and return `-1` if\nversion *s1* is older than version *s2*, `0` if they are the same,\nand `1` if *s1* is newer than *s2*. The version comparison\nalgorithm is the same as the one used by [`nix-env\n-u`](../command-ref/nix-env.md#operation---upgrade).",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "compareVersions"]
  },
  {
    "aliases": [
      ["lib", "lists", "concatLists"],
      ["lib", "concatLists"],
      ["builtins", "concatLists"],
      ["builtins", "concatLists"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Concatenate a list of lists into a single list.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "concatLists"]
  },
  {
    "aliases": [
      ["lib", "lists", "concatMap"],
      ["lib", "concatMap"],
      ["builtins", "concatMap"],
      ["builtins", "concatMap"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "This function is equivalent to `builtins.concatLists (map f list)`\nbut is more efficient.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "concatMap"]
  },
  {
    "aliases": [
      ["lib", "strings", "concatStringsSep"],
      ["lib", "concatStringsSep"],
      ["builtins", "concatStringsSep"],
      ["builtins", "concatStringsSep"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Concatenate a list of strings with a separator between each\nelement, e.g. `concatStringsSep \"/\" [\"usr\" \"local\" \"bin\"] ==\n\"usr/local/bin\"`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "concatStringsSep"]
  },
  {
    "aliases": [
      ["lib", "trivial", "deepSeq"],
      ["lib", "deepSeq"],
      ["builtins", "deepSeq"],
      ["builtins", "deepSeq"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "This is like `seq e1 e2`, except that *e1* is evaluated *deeply*:\nif it’s a list or set, its elements or attributes are also\nevaluated recursively.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "deepSeq"]
  },
  {
    "aliases": [
      ["builtins", "derivation"],
      ["builtins", "derivation"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 1,
          "file": "/builtin/derivation.nix",
          "line": 5
        }
      }
    },
    "path": ["builtins", "derivation"]
  },
  {
    "aliases": [["builtins", "derivationStrict"]],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "derivationStrict"]
  },
  {
    "aliases": [
      ["builtins", "dirOf"],
      ["builtins", "dirOf"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return the directory part of the string *s*, that is, everything\nbefore the final slash in the string. This is similar to the GNU\n`dirname` command.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "dirOf"]
  },
  {
    "aliases": [
      ["builtins", "div"],
      ["builtins", "div"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return the quotient of the numbers *e1* and *e2*.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "div"]
  },
  {
    "aliases": [
      ["lib", "strings", "elem"],
      ["lib", "lists", "elem"],
      ["lib", "elem"],
      ["builtins", "elem"],
      ["builtins", "elem"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return `true` if a value equal to *x* occurs in the list *xs*, and\n`false` otherwise.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "elem"]
  },
  {
    "aliases": [
      ["lib", "strings", "elemAt"],
      ["lib", "lists", "elemAt"],
      ["lib", "elemAt"],
      ["builtins", "elemAt"],
      ["builtins", "elemAt"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return element *n* from the list *xs*. Elements are counted starting\nfrom 0. A fatal error occurs if the index is out of bounds.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "elemAt"]
  },
  {
    "aliases": [
      ["builtins", "fetchGit"],
      ["builtins", "fetchGit"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Fetch a path from git. *args* can be a URL, in which case the HEAD\nof the repo at that URL is fetched. Otherwise, it can be an\nattribute with the following attributes (all except `url` optional):\n\n- `url`\n\n  The URL of the repo.\n\n- `name` (default: *basename of the URL*)\n\n  The name of the directory the repo should be exported to in the store.\n\n- `rev` (default: *the tip of `ref`*)\n\n  The [Git revision] to fetch.\n  This is typically a commit hash.\n\n  [Git revision]: https://git-scm.com/docs/git-rev-parse#_specifying_revisions\n\n- `ref` (default: `HEAD`)\n\n  The [Git reference] under which to look for the requested revision.\n  This is often a branch or tag name.\n\n  [Git reference]: https://git-scm.com/book/en/v2/Git-Internals-Git-References\n\n  By default, the `ref` value is prefixed with `refs/heads/`.\n  As of 2.3.0, Nix will not prefix `refs/heads/` if `ref` starts with `refs/`.\n\n- `submodules` (default: `false`)\n\n  A Boolean parameter that specifies whether submodules should be checked out.\n\n- `shallow` (default: `false`)\n\n  A Boolean parameter that specifies whether fetching a shallow clone is allowed.\n\n- `allRefs`\n\n  Whether to fetch all references of the repository.\n  With this argument being true, it's possible to load a `rev` from *any* `ref`\n  (by default only `rev`s from the specified `ref` are supported).\n\nHere are some examples of how to use `fetchGit`.\n\n  - To fetch a private repository over SSH:\n\n    ```nix\n    builtins.fetchGit {\n      url = \"git@github.com:my-secret/repository.git\";\n      ref = \"master\";\n      rev = \"adab8b916a45068c044658c4158d81878f9ed1c3\";\n    }\n    ```\n\n  - To fetch an arbitrary reference:\n\n    ```nix\n    builtins.fetchGit {\n      url = \"https://github.com/NixOS/nix.git\";\n      ref = \"refs/heads/0.5-release\";\n    }\n    ```\n\n  - If the revision you're looking for is in the default branch of\n    the git repository you don't strictly need to specify the branch\n    name in the `ref` attribute.\n\n    However, if the revision you're looking for is in a future\n    branch for the non-default branch you will need to specify the\n    the `ref` attribute as well.\n\n    ```nix\n    builtins.fetchGit {\n      url = \"https://github.com/nixos/nix.git\";\n      rev = \"841fcbd04755c7a2865c51c1e2d3b045976b7452\";\n      ref = \"1.11-maintenance\";\n    }\n    ```\n\n    > **Note**\n    >\n    > It is nice to always specify the branch which a revision\n    > belongs to. Without the branch being specified, the fetcher\n    > might fail if the default branch changes. Additionally, it can\n    > be confusing to try a commit from a non-default branch and see\n    > the fetch fail. If the branch is specified the fault is much\n    > more obvious.\n\n  - If the revision you're looking for is in the default branch of\n    the git repository you may omit the `ref` attribute.\n\n    ```nix\n    builtins.fetchGit {\n      url = \"https://github.com/nixos/nix.git\";\n      rev = \"841fcbd04755c7a2865c51c1e2d3b045976b7452\";\n    }\n    ```\n\n  - To fetch a specific tag:\n\n    ```nix\n    builtins.fetchGit {\n      url = \"https://github.com/nixos/nix.git\";\n      ref = \"refs/tags/1.9\";\n    }\n    ```\n\n  - To fetch the latest version of a remote branch:\n\n    ```nix\n    builtins.fetchGit {\n      url = \"ssh://git@github.com/nixos/nix.git\";\n      ref = \"master\";\n    }\n    ```\n\n    Nix will refetch the branch according to the [`tarball-ttl`](@docroot@/command-ref/conf-file.md#conf-tarball-ttl) setting.\n\n    This behavior is disabled in [pure evaluation mode](@docroot@/command-ref/conf-file.md#conf-pure-eval).\n\n  - To fetch the content of a checked-out work directory:\n\n    ```nix\n    builtins.fetchGit ./work-dir\n    ```\n\nIf the URL points to a local directory, and no `ref` or `rev` is\ngiven, `fetchGit` will use the current content of the checked-out\nfiles, even if they are not committed or added to Git's index. It will\nonly consider files added to the Git repository, as listed by `git ls-files`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "fetchGit"]
  },
  {
    "aliases": [["builtins", "fetchMercurial"]],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "fetchMercurial"]
  },
  {
    "aliases": [
      ["builtins", "fetchTarball"],
      ["builtins", "fetchTarball"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Download the specified URL, unpack it and return the path of the\nunpacked tree. The file must be a tape archive (`.tar`) compressed\nwith `gzip`, `bzip2` or `xz`. The top-level path component of the\nfiles in the tarball is removed, so it is best if the tarball\ncontains a single directory at top level. The typical use of the\nfunction is to obtain external Nix expression dependencies, such as\na particular version of Nixpkgs, e.g.\n\n```nix\nwith import (fetchTarball https://github.com/NixOS/nixpkgs/archive/nixos-14.12.tar.gz) {};\n\nstdenv.mkDerivation { … }\n```\n\nThe fetched tarball is cached for a certain amount of time (1\nhour by default) in `~/.cache/nix/tarballs/`. You can change the\ncache timeout either on the command line with `--tarball-ttl`\n*number-of-seconds* or in the Nix configuration file by adding\nthe line `tarball-ttl = ` *number-of-seconds*.\n\nNote that when obtaining the hash with `nix-prefetch-url` the\noption `--unpack` is required.\n\nThis function can also verify the contents against a hash. In that\ncase, the function takes a set instead of a URL. The set requires\nthe attribute `url` and the attribute `sha256`, e.g.\n\n```nix\nwith import (fetchTarball {\n  url = \"https://github.com/NixOS/nixpkgs/archive/nixos-14.12.tar.gz\";\n  sha256 = \"1jppksrfvbk5ypiqdz4cddxdl8z6zyzdb2srq8fcffr327ld5jj2\";\n}) {};\n\nstdenv.mkDerivation { … }\n```\n\nNot available in [restricted evaluation mode](@docroot@/command-ref/conf-file.md#conf-restrict-eval).",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "fetchTarball"]
  },
  {
    "aliases": [["builtins", "fetchTree"]],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "fetchTree"]
  },
  {
    "aliases": [
      ["builtins", "fetchurl"],
      ["builtins", "fetchurl"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Download the specified URL and return the path of the downloaded file.\n\nNot available in [restricted evaluation mode](@docroot@/command-ref/conf-file.md#conf-restrict-eval).",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "fetchurl"]
  },
  {
    "aliases": [
      ["lib", "strings", "filter"],
      ["lib", "lists", "filter"],
      ["lib", "filter"],
      ["builtins", "filter"],
      ["builtins", "filter"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return a list consisting of the elements of *list* for which the\nfunction *f* returns `true`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "filter"]
  },
  {
    "aliases": [
      ["builtins", "filterSource"],
      ["builtins", "filterSource"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "> **Warning**\n>\n> `filterSource` should not be used to filter store paths. Since\n> `filterSource` uses the name of the input directory while naming\n> the output directory, doing so will produce a directory name in\n> the form of `<hash2>-<hash>-<name>`, where `<hash>-<name>` is\n> the name of the input directory. Since `<hash>` depends on the\n> unfiltered directory, the name of the output directory will\n> indirectly depend on files that are filtered out by the\n> function. This will trigger a rebuild even when a filtered out\n> file is changed. Use `builtins.path` instead, which allows\n> specifying the name of the output directory.\n\nThis function allows you to copy sources into the Nix store while\nfiltering certain files. For instance, suppose that you want to use\nthe directory `source-dir` as an input to a Nix expression, e.g.\n\n```nix\nstdenv.mkDerivation {\n  ...\n  src = ./source-dir;\n}\n```\n\nHowever, if `source-dir` is a Subversion working copy, then all\nthose annoying `.svn` subdirectories will also be copied to the\nstore. Worse, the contents of those directories may change a lot,\ncausing lots of spurious rebuilds. With `filterSource` you can\nfilter out the `.svn` directories:\n\n```nix\nsrc = builtins.filterSource\n  (path: type: type != \"directory\" || baseNameOf path != \".svn\")\n  ./source-dir;\n```\n\nThus, the first argument *e1* must be a predicate function that is\ncalled for each regular file, directory or symlink in the source\ntree *e2*. If the function returns `true`, the file is copied to the\nNix store, otherwise it is omitted. The function is called with two\narguments. The first is the full path of the file. The second is a\nstring that identifies the type of the file, which is either\n`\"regular\"`, `\"directory\"`, `\"symlink\"` or `\"unknown\"` (for other\nkinds of files such as device nodes or fifos — but note that those\ncannot be copied to the Nix store, so if the predicate returns\n`true` for them, the copy will fail). If you exclude a directory,\nthe entire corresponding subtree of *e2* will be excluded.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "filterSource"]
  },
  {
    "aliases": [
      ["builtins", "findFile"],
      ["builtins", "findFile"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Look up the given path with the given search path.\n\nA search path is represented list of [attribute sets](./values.md#attribute-set) with two attributes, `prefix`, and `path`.\n`prefix` is a relative path.\n`path` denotes a file system location; the exact syntax depends on the command line interface.\n\nExamples of search path attribute sets:\n\n- ```\n  {\n    prefix = \"nixos-config\";\n    path = \"/etc/nixos/configuration.nix\";\n  }\n  ```\n\n- ```\n  {\n    prefix = \"\";\n    path = \"/nix/var/nix/profiles/per-user/root/channels\";\n  }\n  ```\n\nThe lookup algorithm checks each entry until a match is found, returning a [path value](@docroot@/language/values.html#type-path) of the match.\n\nThis is the process for each entry:\nIf the lookup path matches `prefix`, then the remainder of the lookup path (the \"suffix\") is searched for within the directory denoted by `patch`.\nNote that the `path` may need to be downloaded at this point to look inside.\nIf the suffix is found inside that directory, then the entry is a match;\nthe combined absolute path of the directory (now downloaded if need be) and the suffix is returned.\n\nThe syntax\n\n```nix\n<nixpkgs>\n```\n\nis equivalent to:\n\n```nix\nbuiltins.findFile builtins.nixPath \"nixpkgs\"\n```",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "findFile"]
  },
  {
    "aliases": [
      ["builtins", "flakeRefToString"],
      ["builtins", "flakeRefToString"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Convert a flake reference from attribute set format to URL format.\n\nFor example:\n```nix\nbuiltins.flakeRefToString {\n  dir = \"lib\"; owner = \"NixOS\"; ref = \"23.05\"; repo = \"nixpkgs\"; type = \"github\";\n}\n```\nevaluates to\n```nix\n\"github:NixOS/nixpkgs/23.05?dir=lib\"\n```",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "flakeRefToString"]
  },
  {
    "aliases": [
      ["builtins", "floor"],
      ["builtins", "floor"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Converts an IEEE-754 double-precision floating-point number (*double*) to\nthe next lower integer.\n\nIf the datatype is neither an integer nor a \"float\", an evaluation error will be\nthrown.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "floor"]
  },
  {
    "aliases": [
      ["lib", "lists", "foldl'"],
      ["lib", "foldl'"],
      ["builtins", "foldl'"],
      ["builtins", "foldl'"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Reduce a list by applying a binary operator, from left to right,\ne.g. `foldl' op nul [x0 x1 x2 ...] = op (op (op nul x0) x1) x2)\n...`. For example, `foldl' (x: y: x + y) 0 [1 2 3]` evaluates to 6.\nThe return value of each application of `op` is evaluated immediately,\neven for intermediate values.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "foldl'"]
  },
  {
    "aliases": [
      ["lib", "strings", "fromJSON"],
      ["builtins", "fromJSON"],
      ["builtins", "fromJSON"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Convert a JSON string to a Nix value. For example,\n\n```nix\nbuiltins.fromJSON ''{\"x\": [1, 2, 3], \"y\": null}''\n```\n\nreturns the value `{ x = [ 1 2 3 ]; y = null; }`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "fromJSON"]
  },
  {
    "aliases": [
      ["builtins", "fromTOML"],
      ["builtins", "fromTOML"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Convert a TOML string to a Nix value. For example,\n\n```nix\nbuiltins.fromTOML ''\n  x=1\n  s=\"a\"\n  [table]\n  y=2\n''\n```\n\nreturns the value `{ s = \"a\"; table = { y = 2; }; x = 1; }`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "fromTOML"]
  },
  {
    "aliases": [
      ["builtins", "functionArgs"],
      ["builtins", "functionArgs"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return a set containing the names of the formal arguments expected\nby the function *f*. The value of each attribute is a Boolean\ndenoting whether the corresponding argument has a default value. For\ninstance, `functionArgs ({ x, y ? 123}: ...) = { x = false; y =\ntrue; }`.\n\n\"Formal argument\" here refers to the attributes pattern-matched by\nthe function. Plain lambdas are not included, e.g. `functionArgs (x:\n...) = { }`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "functionArgs"]
  },
  {
    "aliases": [
      ["lib", "strings", "genList"],
      ["lib", "lists", "genList"],
      ["lib", "genList"],
      ["builtins", "genList"],
      ["builtins", "genList"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Generate list of size *length*, with each element *i* equal to the\nvalue returned by *generator* `i`. For example,\n\n```nix\nbuiltins.genList (x: x * x) 5\n```\n\nreturns the list `[ 0 1 4 9 16 ]`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "genList"]
  },
  {
    "aliases": [
      ["lib", "trivial", "genericClosure"],
      ["lib", "genericClosure"],
      ["builtins", "genericClosure"],
      ["builtins", "genericClosure"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Take an *attrset* with values named `startSet` and `operator` in order to\nreturn a *list of attrsets* by starting with the `startSet` and recursively\napplying the `operator` function to each `item`. The *attrsets* in the\n`startSet` and the *attrsets* produced by `operator` must contain a value\nnamed `key` which is comparable. The result is produced by calling `operator`\nfor each `item` with a value for `key` that has not been called yet including\nnewly produced `item`s. The function terminates when no new `item`s are\nproduced. The resulting *list of attrsets* contains only *attrsets* with a\nunique key. For example,\n\n```\nbuiltins.genericClosure {\n  startSet = [ {key = 5;} ];\n  operator = item: [{\n    key = if (item.key / 2 ) * 2 == item.key\n         then item.key / 2\n         else 3 * item.key + 1;\n  }];\n}\n```\nevaluates to\n```\n[ { key = 5; } { key = 16; } { key = 8; } { key = 4; } { key = 2; } { key = 1; } ]\n```",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "genericClosure"]
  },
  {
    "aliases": [
      ["lib", "getAttr"],
      ["lib", "attrsets", "getAttr"],
      ["builtins", "getAttr"],
      ["builtins", "getAttr"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "`getAttr` returns the attribute named *s* from *set*. Evaluation\naborts if the attribute doesn’t exist. This is a dynamic version of\nthe `.` operator, since *s* is an expression rather than an\nidentifier.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "getAttr"]
  },
  {
    "aliases": [
      ["builtins", "getContext"],
      ["builtins", "getContext"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return the string context of *s*.\n\nThe string context tracks references to derivations within a string.\nIt is represented as an attribute set of [store derivation](@docroot@/glossary.md#gloss-store-derivation) paths mapping to output names.\n\nUsing [string interpolation](@docroot@/language/string-interpolation.md) on a derivation will add that derivation to the string context.\nFor example,\n\n```nix\nbuiltins.getContext \"${derivation { name = \"a\"; builder = \"b\"; system = \"c\"; }}\"\n```\n\nevaluates to\n\n```\n{ \"/nix/store/arhvjaf6zmlyn8vh8fgn55rpwnxq0n7l-a.drv\" = { outputs = [ \"out\" ]; }; }\n```",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "getContext"]
  },
  {
    "aliases": [
      ["builtins", "getEnv"],
      ["builtins", "getEnv"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "`getEnv` returns the value of the environment variable *s*, or an\nempty string if the variable doesn’t exist. This function should be\nused with care, as it can introduce all sorts of nasty environment\ndependencies in your Nix expression.\n\n`getEnv` is used in Nix Packages to locate the file\n`~/.nixpkgs/config.nix`, which contains user-local settings for Nix\nPackages. (That is, it does a `getEnv \"HOME\"` to locate the user’s\nhome directory.)",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "getEnv"]
  },
  {
    "aliases": [
      ["builtins", "getFlake"],
      ["builtins", "getFlake"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Fetch a flake from a flake reference, and return its output attributes and some metadata. For example:\n\n```nix\n(builtins.getFlake \"nix/55bc52401966fbffa525c574c14f67b00bc4fb3a\").packages.x86_64-linux.nix\n```\n\nUnless impure evaluation is allowed (`--impure`), the flake reference\nmust be \"locked\", e.g. contain a Git revision or content hash. An\nexample of an unlocked usage is:\n\n```nix\n(builtins.getFlake \"github:edolstra/dwarffs\").rev\n```",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "getFlake"]
  },
  {
    "aliases": [
      ["lib", "lists", "groupBy"],
      ["lib", "groupBy"],
      ["builtins", "groupBy"],
      ["builtins", "groupBy"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Groups elements of *list* together by the string returned from the\nfunction *f* called on each element. It returns an attribute set\nwhere each attribute value contains the elements of *list* that are\nmapped to the same corresponding attribute name returned by *f*.\n\nFor example,\n\n```nix\nbuiltins.groupBy (builtins.substring 0 1) [\"foo\" \"bar\" \"baz\"]\n```\n\nevaluates to\n\n```nix\n{ b = [ \"bar\" \"baz\" ]; f = [ \"foo\" ]; }\n```",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "groupBy"]
  },
  {
    "aliases": [
      ["lib", "hasAttr"],
      ["lib", "attrsets", "hasAttr"],
      ["builtins", "hasAttr"],
      ["builtins", "hasAttr"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "`hasAttr` returns `true` if *set* has an attribute named *s*, and\n`false` otherwise. This is a dynamic version of the `?` operator,\nsince *s* is an expression rather than an identifier.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "hasAttr"]
  },
  {
    "aliases": [
      ["lib", "sources", "pathHasContext"],
      ["lib", "pathHasContext"],
      ["builtins", "hasContext"],
      ["builtins", "hasContext"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return `true` if string *s* has a non-empty context. The\ncontext can be obtained with\n[`getContext`](#builtins-getContext).",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "hasContext"]
  },
  {
    "aliases": [
      ["builtins", "hashFile"],
      ["builtins", "hashFile"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return a base-16 representation of the cryptographic hash of the\nfile at path *p*. The hash algorithm specified by *type* must be one\nof `\"md5\"`, `\"sha1\"`, `\"sha256\"` or `\"sha512\"`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "hashFile"]
  },
  {
    "aliases": [
      ["builtins", "hashString"],
      ["builtins", "hashString"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return a base-16 representation of the cryptographic hash of string\n*s*. The hash algorithm specified by *type* must be one of `\"md5\"`,\n`\"sha1\"`, `\"sha256\"` or `\"sha512\"`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "hashString"]
  },
  {
    "aliases": [
      ["lib", "strings", "head"],
      ["lib", "lists", "head"],
      ["lib", "head"],
      ["builtins", "head"],
      ["builtins", "head"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return the first element of a list; abort evaluation if the argument\nisn’t a list or is an empty list. You can test whether a list is\nempty by comparing it with `[]`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "head"]
  },
  {
    "aliases": [
      ["builtins", "import"],
      ["builtins", "import"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Load, parse and return the Nix expression in the file *path*.\n\nThe value *path* can be a path, a string, or an attribute set with an\n`__toString` attribute or a `outPath` attribute (as derivations or flake\ninputs typically have).\n\nIf *path* is a directory, the file `default.nix` in that directory\nis loaded.\n\nEvaluation aborts if the file doesn’t exist or contains\nan incorrect Nix expression. `import` implements Nix’s module\nsystem: you can put any Nix expression (such as a set or a\nfunction) in a separate file, and use it from Nix expressions in\nother files.\n\n> **Note**\n>\n> Unlike some languages, `import` is a regular function in Nix.\n> Paths using the angle bracket syntax (e.g., `import` *\\<foo\\>*)\n> are normal [path values](@docroot@/language/values.md#type-path).\n\nA Nix expression loaded by `import` must not contain any *free\nvariables* (identifiers that are not defined in the Nix expression\nitself and are not built-in). Therefore, it cannot refer to\nvariables that are in scope at the call site. For instance, if you\nhave a calling expression\n\n```nix\nrec {\n  x = 123;\n  y = import ./foo.nix;\n}\n```\n\nthen the following `foo.nix` will give an error:\n\n```nix\nx + 456\n```\n\nsince `x` is not in scope in `foo.nix`. If you want `x` to be\navailable in `foo.nix`, you should pass it as a function argument:\n\n```nix\nrec {\n  x = 123;\n  y = import ./foo.nix x;\n}\n```\n\nand\n\n```nix\nx: x + 456\n```\n\n(The function argument doesn’t have to be called `x` in `foo.nix`;\nany name would work.)",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "import"]
  },
  {
    "aliases": [
      ["builtins", "intersectAttrs"],
      ["builtins", "intersectAttrs"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return a set consisting of the attributes in the set *e2* which have the\nsame name as some attribute in *e1*.\n\nPerforms in O(*n* log *m*) where *n* is the size of the smaller set and *m* the larger set's size.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "intersectAttrs"]
  },
  {
    "aliases": [
      ["lib", "strings", "isAttrs"],
      ["lib", "isAttrs"],
      ["lib", "attrsets", "isAttrs"],
      ["builtins", "isAttrs"],
      ["builtins", "isAttrs"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return `true` if *e* evaluates to a set, and `false` otherwise.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "isAttrs"]
  },
  {
    "aliases": [
      ["lib", "trivial", "isBool"],
      ["lib", "isBool"],
      ["builtins", "isBool"],
      ["builtins", "isBool"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return `true` if *e* evaluates to a bool, and `false` otherwise.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "isBool"]
  },
  {
    "aliases": [
      ["lib", "trivial", "isFloat"],
      ["lib", "isFloat"],
      ["builtins", "isFloat"],
      ["builtins", "isFloat"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return `true` if *e* evaluates to a float, and `false` otherwise.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "isFloat"]
  },
  {
    "aliases": [
      ["builtins", "isFunction"],
      ["builtins", "isFunction"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return `true` if *e* evaluates to a function, and `false` otherwise.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "isFunction"]
  },
  {
    "aliases": [
      ["lib", "trivial", "isInt"],
      ["lib", "strings", "isInt"],
      ["lib", "isInt"],
      ["builtins", "isInt"],
      ["builtins", "isInt"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return `true` if *e* evaluates to an integer, and `false` otherwise.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "isInt"]
  },
  {
    "aliases": [
      ["lib", "strings", "isList"],
      ["lib", "lists", "isList"],
      ["lib", "isList"],
      ["builtins", "isList"],
      ["builtins", "isList"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return `true` if *e* evaluates to a list, and `false` otherwise.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "isList"]
  },
  {
    "aliases": [
      ["builtins", "isNull"],
      ["builtins", "isNull"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return `true` if *e* evaluates to `null`, and `false` otherwise.\n\n> **Warning**\n>\n> This function is *deprecated*; just write `e == null` instead.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "isNull"]
  },
  {
    "aliases": [
      ["lib", "strings", "isPath"],
      ["lib", "isPath"],
      ["builtins", "isPath"],
      ["builtins", "isPath"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return `true` if *e* evaluates to a path, and `false` otherwise.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "isPath"]
  },
  {
    "aliases": [
      ["lib", "strings", "isString"],
      ["lib", "isString"],
      ["builtins", "isString"],
      ["builtins", "isString"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return `true` if *e* evaluates to a string, and `false` otherwise.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "isString"]
  },
  {
    "aliases": [
      ["lib", "lists", "length"],
      ["lib", "length"],
      ["builtins", "length"],
      ["builtins", "length"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return the length of the list *e*.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "length"]
  },
  {
    "aliases": [
      ["lib", "trivial", "lessThan"],
      ["lib", "lessThan"],
      ["builtins", "lessThan"],
      ["builtins", "lessThan"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return `true` if the number *e1* is less than the number *e2*, and\n`false` otherwise. Evaluation aborts if either *e1* or *e2* does not\nevaluate to a number.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "lessThan"]
  },
  {
    "aliases": [
      ["lib", "listToAttrs"],
      ["lib", "attrsets", "listToAttrs"],
      ["builtins", "listToAttrs"],
      ["builtins", "listToAttrs"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Construct a set from a list specifying the names and values of each\nattribute. Each element of the list should be a set consisting of a\nstring-valued attribute `name` specifying the name of the attribute,\nand an attribute `value` specifying its value.\n\nIn case of duplicate occurrences of the same name, the first\ntakes precedence.\n\nExample:\n\n```nix\nbuiltins.listToAttrs\n  [ { name = \"foo\"; value = 123; }\n    { name = \"bar\"; value = 456; }\n    { name = \"bar\"; value = 420; }\n  ]\n```\n\nevaluates to\n\n```nix\n{ foo = 123; bar = 456; }\n```",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "listToAttrs"]
  },
  {
    "aliases": [
      ["lib", "lists", "map"],
      ["builtins", "map"],
      ["builtins", "map"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Apply the function *f* to each element in the list *list*. For\nexample,\n\n```nix\nmap (x: \"foo\" + x) [ \"bar\" \"bla\" \"abc\" ]\n```\n\nevaluates to `[ \"foobar\" \"foobla\" \"fooabc\" ]`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "map"]
  },
  {
    "aliases": [
      ["lib", "mapAttrs"],
      ["lib", "attrsets", "mapAttrs"],
      ["builtins", "mapAttrs"],
      ["builtins", "mapAttrs"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Apply function *f* to every element of *attrset*. For example,\n\n```nix\nbuiltins.mapAttrs (name: value: value * 10) { a = 1; b = 2; }\n```\n\nevaluates to `{ a = 10; b = 20; }`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "mapAttrs"]
  },
  {
    "aliases": [
      ["lib", "strings", "match"],
      ["builtins", "match"],
      ["builtins", "match"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Returns a list if the [extended POSIX regular\nexpression](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04)\n*regex* matches *str* precisely, otherwise returns `null`. Each item\nin the list is a regex group.\n\n```nix\nbuiltins.match \"ab\" \"abc\"\n```\n\nEvaluates to `null`.\n\n```nix\nbuiltins.match \"abc\" \"abc\"\n```\n\nEvaluates to `[ ]`.\n\n```nix\nbuiltins.match \"a(b)(c)\" \"abc\"\n```\n\nEvaluates to `[ \"b\" \"c\" ]`.\n\n```nix\nbuiltins.match \"[[:space:]]+([[:upper:]]+)[[:space:]]+\" \"  FOO   \"\n```\n\nEvaluates to `[ \"FOO\" ]`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "match"]
  },
  {
    "aliases": [
      ["builtins", "mul"],
      ["builtins", "mul"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return the product of the numbers *e1* and *e2*.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "mul"]
  },
  {
    "aliases": [
      ["lib", "strings", "parseDrvName"],
      ["builtins", "parseDrvName"],
      ["builtins", "parseDrvName"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Split the string *s* into a package name and version. The package\nname is everything up to but not including the first dash not followed\nby a letter, and the version is everything following that dash. The\nresult is returned in a set `{ name, version }`. Thus,\n`builtins.parseDrvName \"nix-0.12pre12876\"` returns `{ name =\n\"nix\"; version = \"0.12pre12876\"; }`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "parseDrvName"]
  },
  {
    "aliases": [
      ["builtins", "parseFlakeRef"],
      ["builtins", "parseFlakeRef"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Parse a flake reference, and return its exploded form.\n\nFor example:\n```nix\nbuiltins.parseFlakeRef \"github:NixOS/nixpkgs/23.05?dir=lib\"\n```\nevaluates to:\n```nix\n{ dir = \"lib\"; owner = \"NixOS\"; ref = \"23.05\"; repo = \"nixpkgs\"; type = \"github\"; }\n```",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "parseFlakeRef"]
  },
  {
    "aliases": [
      ["lib", "partition"],
      ["lib", "lists", "partition"],
      ["builtins", "partition"],
      ["builtins", "partition"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Given a predicate function *pred*, this function returns an\nattrset containing a list named `right`, containing the elements\nin *list* for which *pred* returned `true`, and a list named\n`wrong`, containing the elements for which it returned\n`false`. For example,\n\n```nix\nbuiltins.partition (x: x > 10) [1 23 9 3 42]\n```\n\nevaluates to\n\n```nix\n{ right = [ 23 42 ]; wrong = [ 1 9 3 ]; }\n```",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "partition"]
  },
  {
    "aliases": [
      ["builtins", "path"],
      ["builtins", "path"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "An enrichment of the built-in path type, based on the attributes\npresent in *args*. All are optional except `path`:\n\n  - path\\\n    The underlying path.\n\n  - name\\\n    The name of the path when added to the store. This can used to\n    reference paths that have nix-illegal characters in their names,\n    like `@`.\n\n  - filter\\\n    A function of the type expected by `builtins.filterSource`,\n    with the same semantics.\n\n  - recursive\\\n    When `false`, when `path` is added to the store it is with a\n    flat hash, rather than a hash of the NAR serialization of the\n    file. Thus, `path` must refer to a regular file, not a\n    directory. This allows similar behavior to `fetchurl`. Defaults\n    to `true`.\n\n  - sha256\\\n    When provided, this is the expected hash of the file at the\n    path. Evaluation will fail if the hash is incorrect, and\n    providing a hash allows `builtins.path` to be used even when the\n    `pure-eval` nix config option is on.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "path"]
  },
  {
    "aliases": [
      ["lib", "trivial", "pathExists"],
      ["lib", "pathExists"],
      ["builtins", "pathExists"],
      ["builtins", "pathExists"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return `true` if the path *path* exists at evaluation time, and\n`false` otherwise.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "pathExists"]
  },
  {
    "aliases": [
      ["builtins", "placeholder"],
      ["builtins", "placeholder"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return a placeholder string for the specified *output* that will be\nsubstituted by the corresponding output path at build time. Typical\noutputs would be `\"out\"`, `\"bin\"` or `\"dev\"`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "placeholder"]
  },
  {
    "aliases": [
      ["builtins", "readDir"],
      ["builtins", "readDir"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return the contents of the directory *path* as a set mapping\ndirectory entries to the corresponding file type. For instance, if\ndirectory `A` contains a regular file `B` and another directory\n`C`, then `builtins.readDir ./A` will return the set\n\n```nix\n{ B = \"regular\"; C = \"directory\"; }\n```\n\nThe possible values for the file type are `\"regular\"`,\n`\"directory\"`, `\"symlink\"` and `\"unknown\"`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "readDir"]
  },
  {
    "aliases": [
      ["lib", "trivial", "readFile"],
      ["lib", "strings", "readFile"],
      ["lib", "readFile"],
      ["builtins", "readFile"],
      ["builtins", "readFile"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return the contents of the file *path* as a string.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "readFile"]
  },
  {
    "aliases": [
      ["lib", "sources", "pathType"],
      ["lib", "pathType"],
      ["lib", "filesystem", "pathType"],
      ["builtins", "readFileType"],
      ["builtins", "readFileType"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Determine the directory entry type of a filesystem node, being\none of \"directory\", \"regular\", \"symlink\", or \"unknown\".",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "readFileType"]
  },
  {
    "aliases": [
      ["lib", "attrsets", "removeAttrs"],
      ["builtins", "removeAttrs"],
      ["builtins", "removeAttrs"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Remove the attributes listed in *list* from *set*. The attributes\ndon’t have to exist in *set*. For instance,\n\n```nix\nremoveAttrs { x = 1; y = 2; z = 3; } [ \"a\" \"x\" \"z\" ]\n```\n\nevaluates to `{ y = 2; }`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "removeAttrs"]
  },
  {
    "aliases": [
      ["lib", "strings", "replaceStrings"],
      ["lib", "strings", "replaceChars"],
      ["lib", "replaceStrings"],
      ["lib", "replaceChars"],
      ["builtins", "replaceStrings"],
      ["builtins", "replaceStrings"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Given string *s*, replace every occurrence of the strings in *from*\nwith the corresponding string in *to*.\n\nThe argument *to* is lazy, that is, it is only evaluated when its corresponding pattern in *from* is matched in the string *s*\n\nExample:\n\n```nix\nbuiltins.replaceStrings [\"oo\" \"a\"] [\"a\" \"i\"] \"foobar\"\n```\n\nevaluates to `\"fabir\"`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "replaceStrings"]
  },
  {
    "aliases": [["builtins", "scopedImport"]],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "scopedImport"]
  },
  {
    "aliases": [
      ["lib", "trivial", "seq"],
      ["lib", "seq"],
      ["builtins", "seq"],
      ["builtins", "seq"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Evaluate *e1*, then evaluate and return *e2*. This ensures that a\ncomputation is strict in the value of *e1*.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "seq"]
  },
  {
    "aliases": [
      ["lib", "sort"],
      ["lib", "lists", "sort"],
      ["builtins", "sort"],
      ["builtins", "sort"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return *list* in sorted order. It repeatedly calls the function\n*comparator* with two elements. The comparator should return `true`\nif the first element is less than the second, and `false` otherwise.\nFor example,\n\n```nix\nbuiltins.sort builtins.lessThan [ 483 249 526 147 42 77 ]\n```\n\nproduces the list `[ 42 77 147 249 483 526 ]`.\n\nThis is a stable sort: it preserves the relative order of elements\ndeemed equal by the comparator.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "sort"]
  },
  {
    "aliases": [
      ["lib", "strings", "split"],
      ["builtins", "split"],
      ["builtins", "split"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Returns a list composed of non matched strings interleaved with the\nlists of the [extended POSIX regular\nexpression](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04)\n*regex* matches of *str*. Each item in the lists of matched\nsequences is a regex group.\n\n```nix\nbuiltins.split \"(a)b\" \"abc\"\n```\n\nEvaluates to `[ \"\" [ \"a\" ] \"c\" ]`.\n\n```nix\nbuiltins.split \"([ac])\" \"abc\"\n```\n\nEvaluates to `[ \"\" [ \"a\" ] \"b\" [ \"c\" ] \"\" ]`.\n\n```nix\nbuiltins.split \"(a)|(c)\" \"abc\"\n```\n\nEvaluates to `[ \"\" [ \"a\" null ] \"b\" [ null \"c\" ] \"\" ]`.\n\n```nix\nbuiltins.split \"([[:upper:]]+)\" \" FOO \"\n```\n\nEvaluates to `[ \" \" [ \"FOO\" ] \" \" ]`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "split"]
  },
  {
    "aliases": [
      ["lib", "versions", "splitVersion"],
      ["lib", "splitVersion"],
      ["builtins", "splitVersion"],
      ["builtins", "splitVersion"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Split a string representing a version into its components, by the\nsame version splitting logic underlying the version comparison in\n[`nix-env -u`](../command-ref/nix-env.md#operation---upgrade).",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "splitVersion"]
  },
  {
    "aliases": [
      ["builtins", "storePath"],
      ["builtins", "storePath"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "This function allows you to define a dependency on an already\nexisting store path. For example, the derivation attribute `src\n= builtins.storePath /nix/store/f1d18v1y…-source` causes the\nderivation to depend on the specified path, which must exist or\nbe substitutable. Note that this differs from a plain path\n(e.g. `src = /nix/store/f1d18v1y…-source`) in that the latter\ncauses the path to be *copied* again to the Nix store, resulting\nin a new path (e.g. `/nix/store/ld01dnzc…-source-source`).\n\nNot available in [pure evaluation mode](@docroot@/command-ref/conf-file.md#conf-pure-eval).\n\nSee also [`builtins.fetchClosure`](#builtins-fetchClosure).",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "storePath"]
  },
  {
    "aliases": [
      ["lib", "strings", "stringLength"],
      ["lib", "stringLength"],
      ["builtins", "stringLength"],
      ["builtins", "stringLength"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return the length of the string *e*. If *e* is not a string,\nevaluation is aborted.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "stringLength"]
  },
  {
    "aliases": [
      ["lib", "trivial", "sub"],
      ["lib", "sub"],
      ["builtins", "sub"],
      ["builtins", "sub"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return the difference between the numbers *e1* and *e2*.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "sub"]
  },
  {
    "aliases": [
      ["lib", "substring"],
      ["lib", "strings", "substring"],
      ["builtins", "substring"],
      ["builtins", "substring"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return the substring of *s* from character position *start*\n(zero-based) up to but not including *start + len*. If *start* is\ngreater than the length of the string, an empty string is returned,\nand if *start + len* lies beyond the end of the string, only the\nsubstring up to the end of the string is returned. *start* must be\nnon-negative. For example,\n\n```nix\nbuiltins.substring 0 3 \"nixos\"\n```\n\nevaluates to `\"nix\"`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "substring"]
  },
  {
    "aliases": [
      ["lib", "tail"],
      ["lib", "strings", "tail"],
      ["lib", "lists", "tail"],
      ["builtins", "tail"],
      ["builtins", "tail"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return the second to last elements of a list; abort evaluation if\nthe argument isn’t a list or is an empty list.\n\n> **Warning**\n>\n> This function should generally be avoided since it's inefficient:\n> unlike Haskell's `tail`, it takes O(n) time, so recursing over a\n> list by repeatedly calling `tail` takes O(n^2) time.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "tail"]
  },
  {
    "aliases": [
      ["builtins", "throw"],
      ["builtins", "throw"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Throw an error message *s*. This usually aborts Nix expression\nevaluation, but in `nix-env -qa` and other commands that try to\nevaluate a set of derivations to get information about those\nderivations, a derivation that throws an error is silently skipped\n(which is not the case for `abort`).",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "throw"]
  },
  {
    "aliases": [
      ["builtins", "toFile"],
      ["builtins", "toFile"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Store the string *s* in a file in the Nix store and return its\npath.  The file has suffix *name*. This file can be used as an\ninput to derivations. One application is to write builders\n“inline”. For instance, the following Nix expression combines the\nNix expression for GNU Hello and its build script into one file:\n\n```nix\n{ stdenv, fetchurl, perl }:\n\nstdenv.mkDerivation {\n  name = \"hello-2.1.1\";\n\n  builder = builtins.toFile \"builder.sh\" \"\n    source $stdenv/setup\n\n    PATH=$perl/bin:$PATH\n\n    tar xvfz $src\n    cd hello-*\n    ./configure --prefix=$out\n    make\n    make install\n  \";\n\n  src = fetchurl {\n    url = \"http://ftp.nluug.nl/pub/gnu/hello/hello-2.1.1.tar.gz\";\n    sha256 = \"1md7jsfd8pa45z73bz1kszpp01yw6x5ljkjk2hx7wl800any6465\";\n  };\n  inherit perl;\n}\n```\n\nIt is even possible for one file to refer to another, e.g.,\n\n```nix\nbuilder = let\n  configFile = builtins.toFile \"foo.conf\" \"\n    # This is some dummy configuration file.\n    ...\n  \";\nin builtins.toFile \"builder.sh\" \"\n  source $stdenv/setup\n  ...\n  cp ${configFile} $out/etc/foo.conf\n\";\n```\n\nNote that `${configFile}` is a\n[string interpolation](@docroot@/language/values.md#type-string), so the result of the\nexpression `configFile`\n(i.e., a path like `/nix/store/m7p7jfny445k...-foo.conf`) will be\nspliced into the resulting string.\n\nIt is however *not* allowed to have files mutually referring to each\nother, like so:\n\n```nix\nlet\n  foo = builtins.toFile \"foo\" \"...${bar}...\";\n  bar = builtins.toFile \"bar\" \"...${foo}...\";\nin foo\n```\n\nThis is not allowed because it would cause a cyclic dependency in\nthe computation of the cryptographic hashes for `foo` and `bar`.\n\nIt is also not possible to reference the result of a derivation. If\nyou are using Nixpkgs, the `writeTextFile` function is able to do\nthat.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "toFile"]
  },
  {
    "aliases": [
      ["lib", "strings", "toJSON"],
      ["builtins", "toJSON"],
      ["builtins", "toJSON"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return a string containing a JSON representation of *e*. Strings,\nintegers, floats, booleans, nulls and lists are mapped to their JSON\nequivalents. Sets (except derivations) are represented as objects.\nDerivations are translated to a JSON string containing the\nderivation’s output path. Paths are copied to the store and\nrepresented as a JSON string of the resulting store path.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "toJSON"]
  },
  {
    "aliases": [
      ["builtins", "toPath"],
      ["builtins", "toPath"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "**DEPRECATED.** Use `/. + \"/path\"` to convert a string into an absolute\npath. For relative paths, use `./. + \"/path\"`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "toPath"]
  },
  {
    "aliases": [
      ["builtins", "toString"],
      ["builtins", "toString"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Convert the expression *e* to a string. *e* can be:\n\n  - A string (in which case the string is returned unmodified).\n\n  - A path (e.g., `toString /foo/bar` yields `\"/foo/bar\"`.\n\n  - A set containing `{ __toString = self: ...; }` or `{ outPath = ...; }`.\n\n  - An integer.\n\n  - A list, in which case the string representations of its elements\n    are joined with spaces.\n\n  - A Boolean (`false` yields `\"\"`, `true` yields `\"1\"`).\n\n  - `null`, which yields the empty string.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "toString"]
  },
  {
    "aliases": [
      ["builtins", "toXML"],
      ["builtins", "toXML"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return a string containing an XML representation of *e*. The main\napplication for `toXML` is to communicate information with the\nbuilder in a more structured format than plain environment\nvariables.\n\nHere is an example where this is the case:\n\n```nix\n{ stdenv, fetchurl, libxslt, jira, uberwiki }:\n\nstdenv.mkDerivation (rec {\n  name = \"web-server\";\n\n  buildInputs = [ libxslt ];\n\n  builder = builtins.toFile \"builder.sh\" \"\n    source $stdenv/setup\n    mkdir $out\n    echo \"$servlets\" | xsltproc ${stylesheet} - > $out/server-conf.xml ①\n  \";\n\n  stylesheet = builtins.toFile \"stylesheet.xsl\" ②\n   \"<?xml version='1.0' encoding='UTF-8'?>\n    <xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'>\n      <xsl:template match='/'>\n        <Configure>\n          <xsl:for-each select='/expr/list/attrs'>\n            <Call name='addWebApplication'>\n              <Arg><xsl:value-of select=\\\"attr[@name = 'path']/string/@value\\\" /></Arg>\n              <Arg><xsl:value-of select=\\\"attr[@name = 'war']/path/@value\\\" /></Arg>\n            </Call>\n          </xsl:for-each>\n        </Configure>\n      </xsl:template>\n    </xsl:stylesheet>\n  \";\n\n  servlets = builtins.toXML [ ③\n    { path = \"/bugtracker\"; war = jira + \"/lib/atlassian-jira.war\"; }\n    { path = \"/wiki\"; war = uberwiki + \"/uberwiki.war\"; }\n  ];\n})\n```\n\nThe builder is supposed to generate the configuration file for a\n[Jetty servlet container](http://jetty.mortbay.org/). A servlet\ncontainer contains a number of servlets (`*.war` files) each\nexported under a specific URI prefix. So the servlet configuration\nis a list of sets containing the `path` and `war` of the servlet\n(①). This kind of information is difficult to communicate with the\nnormal method of passing information through an environment\nvariable, which just concatenates everything together into a\nstring (which might just work in this case, but wouldn’t work if\nfields are optional or contain lists themselves). Instead the Nix\nexpression is converted to an XML representation with `toXML`,\nwhich is unambiguous and can easily be processed with the\nappropriate tools. For instance, in the example an XSLT stylesheet\n(at point ②) is applied to it (at point ①) to generate the XML\nconfiguration file for the Jetty server. The XML representation\nproduced at point ③ by `toXML` is as follows:\n\n```xml\n<?xml version='1.0' encoding='utf-8'?>\n<expr>\n  <list>\n    <attrs>\n      <attr name=\"path\">\n        <string value=\"/bugtracker\" />\n      </attr>\n      <attr name=\"war\">\n        <path value=\"/nix/store/d1jh9pasa7k2...-jira/lib/atlassian-jira.war\" />\n      </attr>\n    </attrs>\n    <attrs>\n      <attr name=\"path\">\n        <string value=\"/wiki\" />\n      </attr>\n      <attr name=\"war\">\n        <path value=\"/nix/store/y6423b1yi4sx...-uberwiki/uberwiki.war\" />\n      </attr>\n    </attrs>\n  </list>\n</expr>\n```\n\nNote that we used the `toFile` built-in to write the builder and\nthe stylesheet “inline” in the Nix expression. The path of the\nstylesheet is spliced into the builder using the syntax `xsltproc\n${stylesheet}`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "toXML"]
  },
  {
    "aliases": [
      ["lib", "trace"],
      ["builtins", "trace"],
      ["builtins", "trace"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Evaluate *e1* and print its abstract syntax representation on\nstandard error. Then return *e2*. This function is useful for\ndebugging.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "trace"]
  },
  {
    "aliases": [
      ["builtins", "traceVerbose"],
      ["builtins", "traceVerbose"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Evaluate *e1* and print its abstract syntax representation on standard\nerror if `--trace-verbose` is enabled. Then return *e2*. This function\nis useful for debugging.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "traceVerbose"]
  },
  {
    "aliases": [
      ["builtins", "tryEval"],
      ["builtins", "tryEval"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Try to shallowly evaluate *e*. Return a set containing the\nattributes `success` (`true` if *e* evaluated successfully,\n`false` if an error was thrown) and `value`, equalling *e* if\nsuccessful and `false` otherwise. `tryEval` will only prevent\nerrors created by `throw` or `assert` from being thrown.\nErrors `tryEval` will not catch are for example those created\nby `abort` and type errors generated by builtins. Also note that\nthis doesn't evaluate *e* deeply, so `let e = { x = throw \"\"; };\nin (builtins.tryEval e).success` will be `true`. Using\n`builtins.deepSeq` one can get the expected result:\n`let e = { x = throw \"\"; }; in\n(builtins.tryEval (builtins.deepSeq e e)).success` will be\n`false`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "tryEval"]
  },
  {
    "aliases": [
      ["lib", "strings", "typeOf"],
      ["builtins", "typeOf"],
      ["builtins", "typeOf"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Return a string representing the type of the value *e*, namely\n`\"int\"`, `\"bool\"`, `\"string\"`, `\"path\"`, `\"null\"`, `\"set\"`,\n`\"list\"`, `\"lambda\"` or `\"float\"`.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "typeOf"]
  },
  {
    "aliases": [["builtins", "unsafeDiscardOutputDependency"]],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "unsafeDiscardOutputDependency"]
  },
  {
    "aliases": [["builtins", "unsafeDiscardStringContext"]],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "unsafeDiscardStringContext"]
  },
  {
    "aliases": [
      ["builtins", "unsafeGetAttrDoc"],
      ["builtins", "unsafeGetAttrDoc"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "For attribute `path` in `set` returns the doc-comment.\n\nReturn value: AttributeSet containing the `content` of a multiline doc-comment (format: `    */`)\n\nThe doc-comment must be placed before the attribute path or name.",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "unsafeGetAttrDoc"]
  },
  {
    "aliases": [["builtins", "unsafeGetAttrPos"]],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "unsafeGetAttrPos"]
  },
  {
    "aliases": [
      ["builtins", "unsafeGetLambdaDoc"],
      ["builtins", "unsafeGetLambdaDoc"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Returns an AttributeSet containing the `content` of a multiline doc-comment.\n\nA doc-comment placed directly before the lambda is always valid.\n\nThe doc-comment can be placed before the atteribute path, if the lambda is directly assigned to an attribute name (see example).\n\nExample:\n\n```nix\nbuiltins.unsafeGetLambdaDoc\n    {\n           \n          # The id function\n\n          * Bullet item\n          * another item\n\n          ## h2 markdown heading\n\n          some more docs\n        */\n        foo = x: x;\n    }.foo\n```\n\nevaluates to\n\n```nix\n{ content = \"# The id function\\n...\"; isPrimop = false; position = { column = 23; file = \".../test.nix\"; line = 14; }; }\n```",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "unsafeGetLambdaDoc"]
  },
  {
    "aliases": [
      ["lib", "zipAttrsWith"],
      ["lib", "zip"],
      ["lib", "attrsets", "zipAttrsWith"],
      ["lib", "attrsets", "zip"],
      ["builtins", "zipAttrsWith"],
      ["builtins", "zipAttrsWith"]
    ],
    "docs": {
      "attrDocs": { "content": "", "position": null },
      "lambdaDocs": {
        "content": "Transpose a list of attribute sets into an attribute set of lists,\nthen apply `mapAttrs`.\n\n`f` receives two arguments: the attribute name and a non-empty\nlist of all values encountered for that attribute name.\n\nThe result is an attribute set where the attribute names are the\nunion of the attribute names in each element of `list`. The attribute\nvalues are the return values of `f`.\n\n```nix\nbuiltins.zipAttrsWith\n  (name: values: { inherit name values; })\n  [ { a = \"x\"; } { a = \"y\"; b = \"z\"; } ]\n```\n\nevaluates to\n\n```\n{\n  a = { name = \"a\"; values = [ \"x\" \"y\" ]; };\n  b = { name = \"b\"; values = [ \"z\" ]; };\n}\n```",
        "countApplied": 0,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["builtins", "zipAttrsWith"]
  },
  {
    "aliases": [["pkgs", "zabbixFor"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 15,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/all-packages.nix",
          "line": 27715
        }
      }
    },
    "path": ["pkgs", "zabbixFor"]
  },
  {
    "aliases": [["pkgs", "writeTextFile"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/build-support/trivial-builders/default.nix",
          "line": 135
        }
      }
    },
    "path": ["pkgs", "writeTextFile"]
  },
  {
    "aliases": [["pkgs", "writeTextDir"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 18,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/build-support/trivial-builders/default.nix",
          "line": 202
        }
      }
    },
    "path": ["pkgs", "writeTextDir"]
  },
  {
    "aliases": [["pkgs", "writeText"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 15,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/build-support/trivial-builders/default.nix",
          "line": 185
        }
      }
    },
    "path": ["pkgs", "writeText"]
  },
  {
    "aliases": [["pkgs", "writeStringReferencesToFile"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 33,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/build-support/trivial-builders/default.nix",
          "line": 728
        }
      }
    },
    "path": ["pkgs", "writeStringReferencesToFile"]
  },
  {
    "aliases": [["pkgs", "writeShellScriptBin"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/build-support/trivial-builders/default.nix",
          "line": 295
        }
      }
    },
    "path": ["pkgs", "writeShellScriptBin"]
  },
  {
    "aliases": [["pkgs", "writeShellScript"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 22,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/build-support/trivial-builders/default.nix",
          "line": 266
        }
      }
    },
    "path": ["pkgs", "writeShellScript"]
  },
  {
    "aliases": [["pkgs", "writeShellApplication"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/build-support/trivial-builders/default.nix",
          "line": 336
        }
      }
    },
    "path": ["pkgs", "writeShellApplication"]
  },
  {
    "aliases": [["pkgs", "writeScriptBin"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 20,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/build-support/trivial-builders/default.nix",
          "line": 245
        }
      }
    },
    "path": ["pkgs", "writeScriptBin"]
  },
  {
    "aliases": [["pkgs", "writeScript"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/build-support/trivial-builders/default.nix",
          "line": 227
        }
      }
    },
    "path": ["pkgs", "writeScript"]
  },
  {
    "aliases": [["pkgs", "writeReferencesToFile"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/build-support/trivial-builders/default.nix",
          "line": 675
        }
      }
    },
    "path": ["pkgs", "writeReferencesToFile"]
  },
  {
    "aliases": [["pkgs", "writeDirectReferencesToFile"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 33,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/build-support/trivial-builders/default.nix",
          "line": 694
        }
      }
    },
    "path": ["pkgs", "writeDirectReferencesToFile"]
  },
  {
    "aliases": [["pkgs", "writeCBin"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 15,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/build-support/trivial-builders/default.nix",
          "line": 382
        }
      }
    },
    "path": ["pkgs", "writeCBin"]
  },
  {
    "aliases": [["pkgs", "wrapRetroArch"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 19,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/all-packages.nix",
          "line": 2831
        }
      }
    },
    "path": ["pkgs", "wrapRetroArch"]
  },
  {
    "aliases": [["pkgs", "wrapNonDeterministicGcc"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 29,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/all-packages.nix",
          "line": 15821
        }
      }
    },
    "path": ["pkgs", "wrapNonDeterministicGcc"]
  },
  {
    "aliases": [["pkgs", "wrapNeovim"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 16,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/all-packages.nix",
          "line": 36376
        }
      }
    },
    "path": ["pkgs", "wrapNeovim"]
  },
  {
    "aliases": [["pkgs", "wrapLisp_old"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 18,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/all-packages.nix",
          "line": 26127
        }
      }
    },
    "path": ["pkgs", "wrapLisp_old"]
  },
  {
    "aliases": [["pkgs", "wrapKakoune"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/all-packages.nix",
          "line": 9693
        }
      }
    },
    "path": ["pkgs", "wrapKakoune"]
  },
  {
    "aliases": [["pkgs", "wrapClangMulti"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 20,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/all-packages.nix",
          "line": 15883
        }
      }
    },
    "path": ["pkgs", "wrapClangMulti"]
  },
  {
    "aliases": [["pkgs", "wrapCCWith"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/all-packages.nix",
          "line": 17597
        }
      }
    },
    "path": ["pkgs", "wrapCCWith"]
  },
  {
    "aliases": [["pkgs", "wrapCCMulti"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/all-packages.nix",
          "line": 15860
        }
      }
    },
    "path": ["pkgs", "wrapCCMulti"]
  },
  {
    "aliases": [["pkgs", "wrapCC"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 12,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/all-packages.nix",
          "line": 17628
        }
      }
    },
    "path": ["pkgs", "wrapCC"]
  },
  {
    "aliases": [["pkgs", "wrapBintoolsWith"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/all-packages.nix",
          "line": 17633
        }
      }
    },
    "path": ["pkgs", "wrapBintoolsWith"]
  },
  {
    "aliases": [["pkgs", "withCFlags"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 16,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/stdenv/adapters.nix",
          "line": 245
        }
      }
    },
    "path": ["pkgs", "withCFlags"]
  },
  {
    "aliases": [["pkgs", "winePackagesFor"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/all-packages.nix",
          "line": 41591
        }
      }
    },
    "path": ["pkgs", "winePackagesFor"]
  },
  {
    "aliases": [
      ["pkgs", "vscodium-fhsWithPackages"],
      ["pkgs", "vscode-fhsWithPackages"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/applications/editors/vscode/generic.nix",
          "line": 31
        }
      }
    },
    "path": ["pkgs", "vscodium-fhsWithPackages"]
  },
  {
    "aliases": [
      ["pkgs", "vscodium-fhsWithPackages"],
      ["pkgs", "vscode-fhsWithPackages"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/applications/editors/vscode/generic.nix",
          "line": 31
        }
      }
    },
    "path": ["pkgs", "vscode-fhsWithPackages"]
  },
  {
    "aliases": [["pkgs", "useMoldLinker"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 19,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/stdenv/adapters.nix",
          "line": 192
        }
      }
    },
    "path": ["pkgs", "useMoldLinker"]
  },
  {
    "aliases": [["pkgs", "useGoldLinker"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 19,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/stdenv/adapters.nix",
          "line": 185
        }
      }
    },
    "path": ["pkgs", "useGoldLinker"]
  },
  {
    "aliases": [["pkgs", "traceDrvLicenses"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 22,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/stdenv/adapters.nix",
          "line": 156
        }
      }
    },
    "path": ["pkgs", "traceDrvLicenses"]
  },
  {
    "aliases": [["pkgs", "threadsCrossFor"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/all-packages.nix",
          "line": 21807
        }
      }
    },
    "path": ["pkgs", "threadsCrossFor"]
  },
  {
    "aliases": [["pkgs", "themes"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 12,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/all-packages.nix",
          "line": 30267
        }
      }
    },
    "path": ["pkgs", "themes"]
  },
  {
    "aliases": [["pkgs", "testVersion"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/build-support/testers/default.nix",
          "line": 59
        }
      }
    },
    "path": ["pkgs", "testVersion"]
  },
  {
    "aliases": [["pkgs", "symlinkJoin"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/build-support/trivial-builders/default.nix",
          "line": 530
        }
      }
    },
    "path": ["pkgs", "symlinkJoin"]
  },
  {
    "aliases": [["pkgs", "splicePackages"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/splice.nix",
          "line": 98
        }
      }
    },
    "path": ["pkgs", "splicePackages"]
  },
  {
    "aliases": [["pkgs", "runCommandWith"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/build-support/trivial-builders/default.nix",
          "line": 74
        }
      }
    },
    "path": ["pkgs", "runCommandWith"]
  },
  {
    "aliases": [
      ["pkgs", "runCommandNoCCLocal"],
      ["pkgs", "runCommandLocal"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/build-support/trivial-builders/default.nix",
          "line": 44
        }
      }
    },
    "path": ["pkgs", "runCommandNoCCLocal"]
  },
  {
    "aliases": [
      ["pkgs", "runCommandNoCC"],
      ["pkgs", "runCommand"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 16,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/build-support/trivial-builders/default.nix",
          "line": 38
        }
      }
    },
    "path": ["pkgs", "runCommandNoCC"]
  },
  {
    "aliases": [
      ["pkgs", "runCommandNoCCLocal"],
      ["pkgs", "runCommandLocal"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/build-support/trivial-builders/default.nix",
          "line": 44
        }
      }
    },
    "path": ["pkgs", "runCommandLocal"]
  },
  {
    "aliases": [["pkgs", "runCommandCC"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 18,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/build-support/trivial-builders/default.nix",
          "line": 51
        }
      }
    },
    "path": ["pkgs", "runCommandCC"]
  },
  {
    "aliases": [
      ["pkgs", "runCommandNoCC"],
      ["pkgs", "runCommand"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 16,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/build-support/trivial-builders/default.nix",
          "line": 38
        }
      }
    },
    "path": ["pkgs", "runCommand"]
  },
  {
    "aliases": [["pkgs", "resolveMirrorURLs"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/all-packages.nix",
          "line": 1219
        }
      }
    },
    "path": ["pkgs", "resolveMirrorURLs"]
  },
  {
    "aliases": [["pkgs", "requireFile"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/build-support/trivial-builders/default.nix",
          "line": 816
        }
      }
    },
    "path": ["pkgs", "requireFile"]
  },
  {
    "aliases": [
      ["lib", "recurseIntoAttrs"],
      ["lib", "attrsets", "recurseIntoAttrs"],
      ["pkgs", "recurseIntoAttrs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "Make various Nix tools consider the contents of the resulting\nattribute set when looking for what to build, find, etc.\n\nThis function only affects a single attribute set; it does not\napply itself recursively for nested attribute sets.\n\n# Example\n\n```nix\n{ pkgs ? import <nixpkgs> {} }:\n{\n  myTools = pkgs.lib.recurseIntoAttrs {\n    inherit (pkgs) hello figlet;\n  };\n}\n```\n\n# Type\n\n```\nrecurseIntoAttrs :: AttrSet -> AttrSet\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1302
        }
      }
    },
    "path": ["pkgs", "recurseIntoAttrs"]
  },
  {
    "aliases": [["pkgs", "rebar3WithPlugins"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/development/tools/build-managers/rebar3/default.nix",
          "line": 101
        }
      }
    },
    "path": ["pkgs", "rebar3WithPlugins"]
  },
  {
    "aliases": [["pkgs", "quicklispPackagesFor"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 26,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/all-packages.nix",
          "line": 26136
        }
      }
    },
    "path": ["pkgs", "quicklispPackagesFor"]
  },
  {
    "aliases": [["pkgs", "puredata-with-plugins"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 27,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/all-packages.nix",
          "line": 35077
        }
      }
    },
    "path": ["pkgs", "puredata-with-plugins"]
  },
  {
    "aliases": [["pkgs", "propagateBuildInputs"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 26,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/stdenv/adapters.nix",
          "line": 130
        }
      }
    },
    "path": ["pkgs", "propagateBuildInputs"]
  },
  {
    "aliases": [["pkgs", "prefer-remote-fetch"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 1,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/build-support/prefer-remote-fetch/default.nix",
          "line": 13
        }
      }
    },
    "path": ["pkgs", "prefer-remote-fetch"]
  },
  {
    "aliases": [["pkgs", "pkgsModule"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 16,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/all-packages.nix",
          "line": 40850
        }
      }
    },
    "path": ["pkgs", "pkgsModule"]
  },
  {
    "aliases": [["pkgs", "overrideSetup"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 19,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/stdenv/adapters.nix",
          "line": 53
        }
      }
    },
    "path": ["pkgs", "overrideSetup"]
  },
  {
    "aliases": [["pkgs", "overrideInStdenv"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 22,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/stdenv/adapters.nix",
          "line": 41
        }
      }
    },
    "path": ["pkgs", "overrideInStdenv"]
  },
  {
    "aliases": [["pkgs", "overrideCC"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 16,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/stdenv/adapters.nix",
          "line": 35
        }
      }
    },
    "path": ["pkgs", "overrideCC"]
  },
  {
    "aliases": [
      ["pkgs", "oraclejdk8distro"],
      ["pkgs", "jdkdistro"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 22,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/all-packages.nix",
          "line": 16504
        }
      }
    },
    "path": ["pkgs", "oraclejdk8distro"]
  },
  {
    "aliases": [["pkgs", "nuspellWithDicts"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 22,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/all-packages.nix",
          "line": 24350
        }
      }
    },
    "path": ["pkgs", "nuspellWithDicts"]
  },
  {
    "aliases": [["pkgs", "nixosTest"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 7,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/build-support/testers/default.nix",
          "line": 131
        }
      }
    },
    "path": ["pkgs", "nixosTest"]
  },
  {
    "aliases": [["pkgs", "nixosOptionsDoc"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/all-packages.nix",
          "line": 40862
        }
      }
    },
    "path": ["pkgs", "nixosOptionsDoc"]
  },
  {
    "aliases": [["pkgs", "nixos"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/all-packages.nix",
          "line": 40825
        }
      }
    },
    "path": ["pkgs", "nixos"]
  },
  {
    "aliases": [["pkgs", "newScope"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/splice.nix",
          "line": 144
        }
      }
    },
    "path": ["pkgs", "newScope"]
  },
  {
    "aliases": [["pkgs", "mkYarnPackage"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 19,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/development/tools/yarn2nix-moretea/yarn2nix/default.nix",
          "line": 249
        }
      }
    },
    "path": ["pkgs", "mkYarnPackage"]
  },
  {
    "aliases": [["pkgs", "mkYarnModules"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 19,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/development/tools/yarn2nix-moretea/yarn2nix/default.nix",
          "line": 63
        }
      }
    },
    "path": ["pkgs", "mkYarnModules"]
  },
  {
    "aliases": [["pkgs", "mkTerraform"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/applications/networking/cluster/terraform/default.nix",
          "line": 167
        }
      }
    },
    "path": ["pkgs", "mkTerraform"]
  },
  {
    "aliases": [["pkgs", "mkStdenvNoLibs"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 20,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/all-packages.nix",
          "line": 47
        }
      }
    },
    "path": ["pkgs", "mkStdenvNoLibs"]
  },
  {
    "aliases": [["pkgs", "mkRubyVersion"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/development/interpreters/ruby/ruby-version.nix",
          "line": 6
        }
      }
    },
    "path": ["pkgs", "mkRubyVersion"]
  },
  {
    "aliases": [["pkgs", "mkRuby"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 13,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/development/interpreters/ruby/default.nix",
          "line": 28
        }
      }
    },
    "path": ["pkgs", "mkRuby"]
  },
  {
    "aliases": [["pkgs", "mkNvidiaContainerPkg"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 26,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/all-packages.nix",
          "line": 24357
        }
      }
    },
    "path": ["pkgs", "mkNvidiaContainerPkg"]
  },
  {
    "aliases": [["pkgs", "mkKops"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 13,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/applications/networking/cluster/kops/default.nix",
          "line": 3
        }
      }
    },
    "path": ["pkgs", "mkKops"]
  },
  {
    "aliases": [["pkgs", "mkCoqPackages"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 19,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/coq-packages.nix",
          "line": 167
        }
      }
    },
    "path": ["pkgs", "mkCoqPackages"]
  },
  {
    "aliases": [["pkgs", "makeStaticLibraries"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/stdenv/adapters.nix",
          "line": 79
        }
      }
    },
    "path": ["pkgs", "makeStaticLibraries"]
  },
  {
    "aliases": [["pkgs", "makeStaticDarwin"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 22,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/stdenv/adapters.nix",
          "line": 95
        }
      }
    },
    "path": ["pkgs", "makeStaticDarwin"]
  },
  {
    "aliases": [["pkgs", "makeStaticBinaries"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/stdenv/adapters.nix",
          "line": 58
        }
      }
    },
    "path": ["pkgs", "makeStaticBinaries"]
  },
  {
    "aliases": [["pkgs", "makeStatic"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 16,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/stdenv/adapters.nix",
          "line": 116
        }
      }
    },
    "path": ["pkgs", "makeStatic"]
  },
  {
    "aliases": [["pkgs", "makeSetupHook"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/build-support/trivial-builders/default.nix",
          "line": 633
        }
      }
    },
    "path": ["pkgs", "makeSetupHook"]
  },
  {
    "aliases": [["pkgs", "makeScopeWithSplicing'"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/customisation.nix",
          "line": 309
        }
      }
    },
    "path": ["pkgs", "makeScopeWithSplicing'"]
  },
  {
    "aliases": [["pkgs", "makeScopeWithSplicing"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "backward compatibility with old uncurried form; deprecated",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 31,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/customisation.nix",
          "line": 296
        }
      }
    },
    "path": ["pkgs", "makeScopeWithSplicing"]
  },
  {
    "aliases": [
      ["lib", "makeOverridable"],
      ["lib", "customisation", "makeOverridable"],
      ["pkgs", "makeOverridable"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "`makeOverridable` takes a function from attribute set to attribute set and\ninjects `override` attribute which can be used to override arguments of\nthe function.\n\nnix-repl> x = {a, b}: { result = a + b; }\n\nnix-repl> y = lib.makeOverridable x { a = 1; b = 2; }\n\nnix-repl> y\n{ override = «lambda»; overrideDerivation = «lambda»; result = 3; }\n\nnix-repl> y.override { a = 10; }\n{ override = «lambda»; overrideDerivation = «lambda»; result = 12; }\n\nPlease refer to \"Nixpkgs Contributors Guide\" section\n\"<pkg>.overrideDerivation\" to learn about `overrideDerivation` and caveats\nrelated to its use.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/customisation.nix",
          "line": 74
        }
      }
    },
    "path": ["pkgs", "makeOverridable"]
  },
  {
    "aliases": [["pkgs", "makeModulesClosure"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/all-packages.nix",
          "line": 1282
        }
      }
    },
    "path": ["pkgs", "makeModulesClosure"]
  },
  {
    "aliases": [
      ["pkgs", "makeInitrdNG"],
      ["pkgs", "makeInitrd"],
      ["pkgs", "makeImpureTest"],
      ["pkgs", "gccFun"],
      ["pkgs", "clwrapperFunction"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 35,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/customisation.nix",
          "line": 125
        }
      }
    },
    "path": ["pkgs", "makeInitrdNG"]
  },
  {
    "aliases": [
      ["pkgs", "makeInitrdNG"],
      ["pkgs", "makeInitrd"],
      ["pkgs", "makeImpureTest"],
      ["pkgs", "gccFun"],
      ["pkgs", "clwrapperFunction"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 35,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/customisation.nix",
          "line": 125
        }
      }
    },
    "path": ["pkgs", "makeInitrd"]
  },
  {
    "aliases": [
      ["pkgs", "makeInitrdNG"],
      ["pkgs", "makeInitrd"],
      ["pkgs", "makeImpureTest"],
      ["pkgs", "gccFun"],
      ["pkgs", "clwrapperFunction"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 35,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/customisation.nix",
          "line": 125
        }
      }
    },
    "path": ["pkgs", "makeImpureTest"]
  },
  {
    "aliases": [["pkgs", "makeFontsConf"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 52,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/all-packages.nix",
          "line": 21508
        }
      }
    },
    "path": ["pkgs", "makeFontsConf"]
  },
  {
    "aliases": [["pkgs", "makeFontsCache"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 53,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/all-packages.nix",
          "line": 21513
        }
      }
    },
    "path": ["pkgs", "makeFontsCache"]
  },
  {
    "aliases": [["pkgs", "makeDBusConf"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 18,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/all-packages.nix",
          "line": 21182
        }
      }
    },
    "path": ["pkgs", "makeDBusConf"]
  },
  {
    "aliases": [
      ["lib", "meta", "lowPrio"],
      ["lib", "meta", "hiPrio"],
      ["lib", "lowPrio"],
      ["lib", "hiPrio"],
      ["pkgs", "lowPrio"],
      ["pkgs", "hiPrio"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "Add to or override the meta attributes of the given\nderivation.\n\n# Example\n\n```nix\naddMetaAttrs {description = \"Bla blah\";} somePkg\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 21
        }
      }
    },
    "path": ["pkgs", "lowPrio"]
  },
  {
    "aliases": [["pkgs", "lispPackagesFor"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/all-packages.nix",
          "line": 26129
        }
      }
    },
    "path": ["pkgs", "lispPackagesFor"]
  },
  {
    "aliases": [["pkgs", "linuxPackages_custom"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 19,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/linux-kernels.nix",
          "line": 660
        }
      }
    },
    "path": ["pkgs", "linuxPackages_custom"]
  },
  {
    "aliases": [["pkgs", "linuxPackagesFor"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/linux-kernels.nix",
          "line": 291
        }
      }
    },
    "path": ["pkgs", "linuxPackagesFor"]
  },
  {
    "aliases": [["pkgs", "linuxConfig"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/linux-kernels.nix",
          "line": 666
        }
      }
    },
    "path": ["pkgs", "linuxConfig"]
  },
  {
    "aliases": [["pkgs", "linkFarmFromDrvs"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 22,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/build-support/trivial-builders/default.nix",
          "line": 626
        }
      }
    },
    "path": ["pkgs", "linkFarmFromDrvs"]
  },
  {
    "aliases": [["pkgs", "linkFarm"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/build-support/trivial-builders/default.nix",
          "line": 582
        }
      }
    },
    "path": ["pkgs", "linkFarm"]
  },
  {
    "aliases": [["pkgs", "libcIconv"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 15,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/all-packages.nix",
          "line": 23291
        }
      }
    },
    "path": ["pkgs", "libcIconv"]
  },
  {
    "aliases": [["pkgs", "libcCrossChooser"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 22,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/all-packages.nix",
          "line": 21778
        }
      }
    },
    "path": ["pkgs", "libcCrossChooser"]
  },
  {
    "aliases": [["pkgs", "keepDebugInfo"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 19,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/stdenv/adapters.nix",
          "line": 175
        }
      }
    },
    "path": ["pkgs", "keepDebugInfo"]
  },
  {
    "aliases": [
      ["pkgs", "oraclejdk8distro"],
      ["pkgs", "jdkdistro"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 22,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/all-packages.nix",
          "line": 16504
        }
      }
    },
    "path": ["pkgs", "jdkdistro"]
  },
  {
    "aliases": [["pkgs", "invalidateFetcherByDrvHash"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 32,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/build-support/testers/default.nix",
          "line": 82
        }
      }
    },
    "path": ["pkgs", "invalidateFetcherByDrvHash"]
  },
  {
    "aliases": [["pkgs", "impureUseNativeOptimizations"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 34,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/stdenv/adapters.nix",
          "line": 219
        }
      }
    },
    "path": ["pkgs", "impureUseNativeOptimizations"]
  },
  {
    "aliases": [["pkgs", "hunspellWithDicts"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 23,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/all-packages.nix",
          "line": 22230
        }
      }
    },
    "path": ["pkgs", "hunspellWithDicts"]
  },
  {
    "aliases": [
      ["lib", "meta", "lowPrio"],
      ["lib", "meta", "hiPrio"],
      ["lib", "lowPrio"],
      ["lib", "hiPrio"],
      ["pkgs", "lowPrio"],
      ["pkgs", "hiPrio"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "Add to or override the meta attributes of the given\nderivation.\n\n# Example\n\n```nix\naddMetaAttrs {description = \"Bla blah\";} somePkg\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/meta.nix",
          "line": 21
        }
      }
    },
    "path": ["pkgs", "hiPrio"]
  },
  {
    "aliases": [["pkgs", "hardenedLinuxPackagesFor"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/linux-kernels.nix",
          "line": 578
        }
      }
    },
    "path": ["pkgs", "hardenedLinuxPackagesFor"]
  },
  {
    "aliases": [["pkgs", "gradleGen"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/development/tools/build-managers/gradle/default.nix",
          "line": 6
        }
      }
    },
    "path": ["pkgs", "gradleGen"]
  },
  {
    "aliases": [["pkgs", "generateSplicesForMkScope"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 31,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/splice.nix",
          "line": 151
        }
      }
    },
    "path": ["pkgs", "generateSplicesForMkScope"]
  },
  {
    "aliases": [
      ["pkgs", "makeInitrdNG"],
      ["pkgs", "makeInitrd"],
      ["pkgs", "makeImpureTest"],
      ["pkgs", "gccFun"],
      ["pkgs", "clwrapperFunction"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 35,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/customisation.nix",
          "line": 125
        }
      }
    },
    "path": ["pkgs", "gccFun"]
  },
  {
    "aliases": [["pkgs", "forceSystem"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/aliases.nix",
          "line": 53
        }
      }
    },
    "path": ["pkgs", "forceSystem"]
  },
  {
    "aliases": [["pkgs", "fetchsvnrevision"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 25,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/build-support/fetchsvnrevision/default.nix",
          "line": 1
        }
      }
    },
    "path": ["pkgs", "fetchsvnrevision"]
  },
  {
    "aliases": [["pkgs", "fetchipfs"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 1,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/build-support/fetchipfs/default.nix",
          "line": 5
        }
      }
    },
    "path": ["pkgs", "fetchipfs"]
  },
  {
    "aliases": [["pkgs", "fetchegg"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/development/compilers/chicken/5/default.nix",
          "line": 5
        }
      }
    },
    "path": ["pkgs", "fetchegg"]
  },
  {
    "aliases": [["pkgs", "fetchNpmDeps"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/build-support/node/fetch-npm-deps/default.nix",
          "line": 124
        }
      }
    },
    "path": ["pkgs", "fetchNpmDeps"]
  },
  {
    "aliases": [["pkgs", "extend"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/stage.nix",
          "line": 261
        }
      }
    },
    "path": ["pkgs", "extend"]
  },
  {
    "aliases": [["pkgs", "ensureNewerSourcesHook"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/all-packages.nix",
          "line": 213
        }
      }
    },
    "path": ["pkgs", "ensureNewerSourcesHook"]
  },
  {
    "aliases": [["pkgs", "enableDebugging"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 21,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/all-packages.nix",
          "line": 1402
        }
      }
    },
    "path": ["pkgs", "enableDebugging"]
  },
  {
    "aliases": [
      ["pkgs", "emacsWithPackages"],
      ["pkgs", "emacs28WithPackages"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 1,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/build-support/emacs/wrapper.nix",
          "line": 42
        }
      }
    },
    "path": ["pkgs", "emacsWithPackages"]
  },
  {
    "aliases": [
      ["pkgs", "emacsPackagesNgFor"],
      ["pkgs", "emacsPackagesFor"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 22,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/all-packages.nix",
          "line": 31543
        }
      }
    },
    "path": ["pkgs", "emacsPackagesNgFor"]
  },
  {
    "aliases": [
      ["pkgs", "emacsPackagesNgFor"],
      ["pkgs", "emacsPackagesFor"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 22,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/all-packages.nix",
          "line": 31543
        }
      }
    },
    "path": ["pkgs", "emacsPackagesFor"]
  },
  {
    "aliases": [
      ["pkgs", "emacsWithPackages"],
      ["pkgs", "emacs28WithPackages"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 1,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/build-support/emacs/wrapper.nix",
          "line": 42
        }
      }
    },
    "path": ["pkgs", "emacs28WithPackages"]
  },
  {
    "aliases": [
      ["lib", "dontRecurseIntoAttrs"],
      ["lib", "attrsets", "dontRecurseIntoAttrs"],
      ["pkgs", "dontRecurseIntoAttrs"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "Undo the effect of recurseIntoAttrs.\n\n# Type\n\n```\ndontRecurseIntoAttrs :: AttrSet -> AttrSet\n```",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 1316
        }
      }
    },
    "path": ["pkgs", "dontRecurseIntoAttrs"]
  },
  {
    "aliases": [["pkgs", "diffPlugins"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 17,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/build-support/plugins.nix",
          "line": 13
        }
      }
    },
    "path": ["pkgs", "diffPlugins"]
  },
  {
    "aliases": [["pkgs", "datadog-integrations-core"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 31,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/all-packages.nix",
          "line": 31274
        }
      }
    },
    "path": ["pkgs", "datadog-integrations-core"]
  },
  {
    "aliases": [
      ["lib", "options", "getValues"],
      ["lib", "options", "getFiles"],
      ["lib", "getValues"],
      ["lib", "getFiles"],
      ["pkgs", "copyPathsToStore"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "Apply the function *f* to each element in the list *list*. For\nexample,\n\n```nix\nmap (x: \"foo\" + x) [ \"bar\" \"bla\" \"abc\" ]\n```\n\nevaluates to `[ \"foobar\" \"foobla\" \"fooabc\" ]`.",
        "countApplied": 1,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["pkgs", "copyPathsToStore"]
  },
  {
    "aliases": [["pkgs", "copyPathToStore"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "> **Warning**\n>\n> `filterSource` should not be used to filter store paths. Since\n> `filterSource` uses the name of the input directory while naming\n> the output directory, doing so will produce a directory name in\n> the form of `<hash2>-<hash>-<name>`, where `<hash>-<name>` is\n> the name of the input directory. Since `<hash>` depends on the\n> unfiltered directory, the name of the output directory will\n> indirectly depend on files that are filtered out by the\n> function. This will trigger a rebuild even when a filtered out\n> file is changed. Use `builtins.path` instead, which allows\n> specifying the name of the output directory.\n\nThis function allows you to copy sources into the Nix store while\nfiltering certain files. For instance, suppose that you want to use\nthe directory `source-dir` as an input to a Nix expression, e.g.\n\n```nix\nstdenv.mkDerivation {\n  ...\n  src = ./source-dir;\n}\n```\n\nHowever, if `source-dir` is a Subversion working copy, then all\nthose annoying `.svn` subdirectories will also be copied to the\nstore. Worse, the contents of those directories may change a lot,\ncausing lots of spurious rebuilds. With `filterSource` you can\nfilter out the `.svn` directories:\n\n```nix\nsrc = builtins.filterSource\n  (path: type: type != \"directory\" || baseNameOf path != \".svn\")\n  ./source-dir;\n```\n\nThus, the first argument *e1* must be a predicate function that is\ncalled for each regular file, directory or symlink in the source\ntree *e2*. If the function returns `true`, the file is copied to the\nNix store, otherwise it is omitted. The function is called with two\narguments. The first is the full path of the file. The second is a\nstring that identifies the type of the file, which is either\n`\"regular\"`, `\"directory\"`, `\"symlink\"` or `\"unknown\"` (for other\nkinds of files such as device nodes or fifos — but note that those\ncannot be copied to the Nix store, so if the predicate returns\n`true` for them, the copy will fail). If you exclude a directory,\nthe entire corresponding subtree of *e2* will be excluded.",
        "countApplied": 1,
        "isPrimop": true,
        "position": null
      }
    },
    "path": ["pkgs", "copyPathToStore"]
  },
  {
    "aliases": [["pkgs", "concatTextFile"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/build-support/trivial-builders/default.nix",
          "line": 430
        }
      }
    },
    "path": ["pkgs", "concatTextFile"]
  },
  {
    "aliases": [["pkgs", "concatText"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 16,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/build-support/trivial-builders/default.nix",
          "line": 463
        }
      }
    },
    "path": ["pkgs", "concatText"]
  },
  {
    "aliases": [["pkgs", "concatScript"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 18,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/build-support/trivial-builders/default.nix",
          "line": 473
        }
      }
    },
    "path": ["pkgs", "concatScript"]
  },
  {
    "aliases": [
      ["pkgs", "makeInitrdNG"],
      ["pkgs", "makeInitrd"],
      ["pkgs", "makeImpureTest"],
      ["pkgs", "gccFun"],
      ["pkgs", "clwrapperFunction"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 35,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/customisation.nix",
          "line": 125
        }
      }
    },
    "path": ["pkgs", "clwrapperFunction"]
  },
  {
    "aliases": [["pkgs", "callPackages"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "Like callPackage, but for a function that returns an attribute\nset of derivations. The override function is added to the\nindividual attributes.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 32,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/customisation.nix",
          "line": 184
        }
      }
    },
    "path": ["pkgs", "callPackages"]
  },
  {
    "aliases": [
      ["pkgs", "callPackage_i686"],
      ["pkgs", "callPackage"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 31,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/customisation.nix",
          "line": 125
        }
      }
    },
    "path": ["pkgs", "callPackage_i686"]
  },
  {
    "aliases": [
      ["pkgs", "callPackage_i686"],
      ["pkgs", "callPackage"]
    ],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 31,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/customisation.nix",
          "line": 125
        }
      }
    },
    "path": ["pkgs", "callPackage"]
  },
  {
    "aliases": [["pkgs", "buildUBoot"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "`makeOverridable` takes a function from attribute set to attribute set and\ninjects `override` attribute which can be used to override arguments of\nthe function.\n\nnix-repl> x = {a, b}: { result = a + b; }\n\nnix-repl> y = lib.makeOverridable x { a = 1; b = 2; }\n\nnix-repl> y\n{ override = «lambda»; overrideDerivation = «lambda»; result = 3; }\n\nnix-repl> y.override { a = 10; }\n{ override = «lambda»; overrideDerivation = «lambda»; result = 12; }\n\nPlease refer to \"Nixpkgs Contributors Guide\" section\n\"<pkg>.overrideDerivation\" to learn about `overrideDerivation` and caveats\nrelated to its use.",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 24,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/customisation.nix",
          "line": 74
        }
      }
    },
    "path": ["pkgs", "buildUBoot"]
  },
  {
    "aliases": [["pkgs", "buildMozillaMach"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 22,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/all-packages.nix",
          "line": 32075
        }
      }
    },
    "path": ["pkgs", "buildMozillaMach"]
  },
  {
    "aliases": [["pkgs", "buildLinux"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 16,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/linux-kernels.nix",
          "line": 692
        }
      }
    },
    "path": ["pkgs", "buildLinux"]
  },
  {
    "aliases": [["pkgs", "buildBarebox"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 18,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/misc/barebox/default.nix",
          "line": 15
        }
      }
    },
    "path": ["pkgs", "buildBarebox"]
  },
  {
    "aliases": [["pkgs", "buildArmTrustedFirmware"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 29,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/misc/arm-trusted-firmware/default.nix",
          "line": 14
        }
      }
    },
    "path": ["pkgs", "buildArmTrustedFirmware"]
  },
  {
    "aliases": [["pkgs", "applyPatches"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 5,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/build-support/trivial-builders/default.nix",
          "line": 899
        }
      }
    },
    "path": ["pkgs", "applyPatches"]
  },
  {
    "aliases": [["pkgs", "appendOverlays"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 22,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/stage.nix",
          "line": 249
        }
      }
    },
    "path": ["pkgs", "appendOverlays"]
  },
  {
    "aliases": [["pkgs", "apacheHttpdPackagesFor"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 28,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/all-packages.nix",
          "line": 26341
        }
      }
    },
    "path": ["pkgs", "apacheHttpdPackagesFor"]
  },
  {
    "aliases": [["pkgs", "aggregateModules"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 22,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/top-level/all-packages.nix",
          "line": 28501
        }
      }
    },
    "path": ["pkgs", "aggregateModules"]
  },
  {
    "aliases": [["pkgs", "addAttrsToDerivation"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 26,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/stdenv/adapters.nix",
          "line": 148
        }
      }
    },
    "path": ["pkgs", "addAttrsToDerivation"]
  },
  {
    "aliases": [["pkgs", "stdenv", "overrides"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 19,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/stdenv/linux/default.nix",
          "line": 657
        }
      }
    },
    "path": ["pkgs", "stdenv", "overrides"]
  },
  {
    "aliases": [["pkgs", "stdenv", "overrideDerivation"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 32,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/customisation.nix",
          "line": 91
        }
      }
    },
    "path": ["pkgs", "stdenv", "overrideDerivation"]
  },
  {
    "aliases": [["pkgs", "stdenv", "mkDerivation"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 3,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/stdenv/generic/make-derivation.nix",
          "line": 546
        }
      }
    },
    "path": ["pkgs", "stdenv", "mkDerivation"]
  },
  {
    "aliases": [["pkgs", "stdenv", "fetchurlBoot"]],
    "docs": {
      "attrDocs": {
        "content": "",
        "position": {
          "column": 14,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/lib/attrsets.nix",
          "line": 606
        }
      },
      "lambdaDocs": {
        "content": "",
        "countApplied": 0,
        "isPrimop": false,
        "position": {
          "column": 1,
          "file": "/nix/store/gjxkph9ldmqnsagl4g533k8ja5yf93kc-source/pkgs/build-support/fetchurl/boot.nix",
          "line": 5
        }
      }
    },
    "path": ["pkgs", "stdenv", "fetchurlBoot"]
  }
]
