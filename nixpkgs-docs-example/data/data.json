[
  {
    "content": "",
    "isPrimop": false,
    "name": "__unfix__",
    "position": {
      "column": 11,
      "file": "/home/johannes/git/nixpkgs/lib/fixed-points.nix",
      "line": 152
    }
  },
  {
    "content": "Return the sum of the numbers *e1* and *e2*.",
    "isPrimop": true,
    "name": "add",
    "position": null
  },
  {
    "content": "Appends string context from another string.  This is an implementation\ndetail of Nix and should be used carefully.\n\nStrings in Nix carry an invisible `context` which is a list of strings\nrepresenting store paths.  If the string is later used in a derivation\nattribute, the derivation will properly populate the inputDrvs and\ninputSrcs.\n\n# Example\n\n```nix\npkgs = import <nixpkgs> { };\naddContextFrom pkgs.coreutils \"bar\"\n=> \"bar\"\n```",
    "isPrimop": false,
    "name": "addContextFrom",
    "position": {
      "column": 20,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 857
    }
  },
  {
    "content": "",
    "isPrimop": true,
    "name": "addErrorContext",
    "position": null
  },
  {
    "content": "Add to or override the meta attributes of the given\nderivation.\n\n# Example\n\n```nix\naddMetaAttrs {description = \"Bla blah\";} somePkg\n```",
    "isPrimop": false,
    "name": "addMetaAttrs",
    "position": {
      "column": 18,
      "file": "/home/johannes/git/nixpkgs/lib/meta.nix",
      "line": 21
    }
  },
  {
    "content": "Return `true` if the function *pred* returns `true` for all elements\nof *list*, and `false` otherwise.",
    "isPrimop": true,
    "name": "all",
    "position": null
  },
  {
    "content": "boolean “and”",
    "isPrimop": false,
    "name": "and",
    "position": {
      "column": 9,
      "file": "/home/johannes/git/nixpkgs/lib/trivial.nix",
      "line": 121
    }
  },
  {
    "content": "Return `true` if the function *pred* returns `true` for at least one\nelement of *list*, and `false` otherwise.",
    "isPrimop": true,
    "name": "any",
    "position": null
  },
  {
    "content": "Append a suffix to the name of a package (before the version\npart).",
    "isPrimop": false,
    "name": "appendToName",
    "position": {
      "column": 18,
      "file": "/home/johannes/git/nixpkgs/lib/meta.nix",
      "line": 54
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "applyModuleArgsIfFunction",
    "position": {
      "column": 31,
      "file": "/home/johannes/git/nixpkgs/lib/modules.nix",
      "line": 492
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "assertMsg",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/asserts.nix",
      "line": 28
    }
  },
  {
    "content": "Specialized `assertMsg` for checking if `val` is one of the elements\nof the list `xs`. Useful for checking enums.\n\n# Example\n\n```nix\nlet sslLibrary = \"libressl\";\nin assertOneOf \"sslLibrary\" sslLibrary [ \"openssl\" \"bearssl\" ]\nstderr> error: sslLibrary must be one of [\nstderr>   \"openssl\"\nstderr>   \"bearssl\"\nstderr> ], but is: \"libressl\"\n```\n\n# Type\n\n```haskell\nassertOneOf :: String -> ComparableVal -> List ComparableVal -> Bool\n```",
    "isPrimop": false,
    "name": "assertOneOf",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/asserts.nix",
      "line": 56
    }
  },
  {
    "content": "Return an attribute from nested attribute sets.\n\n# Example\n\n```nix\nx = { a = { b = 3; }; }\n# [\"a\" \"b\"] is equivalent to x.a.b\n# 6 is a default value to return if the path does not exist in attrset\nattrByPath [\"a\" \"b\"] 6 x\n=> 3\nattrByPath [\"z\" \"z\"] 6 x\n=> 6\n```\n\n# Type\n\n```haskell\nattrByPath :: [String] -> Any -> AttrSet -> Any\n```",
    "isPrimop": false,
    "name": "attrByPath",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/attrsets.nix",
      "line": 38
    }
  },
  {
    "content": "Return the names of the attributes in the set *set* in an\nalphabetically sorted list. For instance, `builtins.attrNames { y\n= 1; x = \"foo\"; }` evaluates to `[ \"x\" \"y\" ]`.",
    "isPrimop": true,
    "name": "attrNames",
    "position": null
  },
  {
    "content": "Return the specified attributes from a set.\n\n# Example\n\n```nix\nattrVals [\"a\" \"b\" \"c\"] as\n=> [as.a as.b as.c]\n```\n\n# Type\n\n```haskell\nattrVals :: [String] -> AttrSet -> [Any]\n```",
    "isPrimop": false,
    "name": "attrVals",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/attrsets.nix",
      "line": 296
    }
  },
  {
    "content": "Return the values of the attributes in the set *set* in the order\ncorresponding to the sorted attribute names.",
    "isPrimop": true,
    "name": "attrValues",
    "position": null
  },
  {
    "content": "Return the bitwise AND of the integers *e1* and *e2*.",
    "isPrimop": true,
    "name": "bitAnd",
    "position": null
  },
  {
    "content": "Return the difference between the numbers *e1* and *e2*.",
    "isPrimop": true,
    "name": "bitNot",
    "position": null
  },
  {
    "content": "Return the bitwise OR of the integers *e1* and *e2*.",
    "isPrimop": true,
    "name": "bitOr",
    "position": null
  },
  {
    "content": "Return the bitwise XOR of the integers *e1* and *e2*.",
    "isPrimop": true,
    "name": "bitXor",
    "position": null
  },
  {
    "content": "Convert a boolean to a string.\n\nThis function uses the strings \"true\" and \"false\" to represent\nboolean values. Calling `toString` on a bool instead returns \"1\"\nand \"\" (sic!).\n\n# Type\n\n```haskell\nboolToString :: bool -> string\n```",
    "isPrimop": false,
    "name": "boolToString",
    "position": {
      "column": 18,
      "file": "/home/johannes/git/nixpkgs/lib/trivial.nix",
      "line": 162
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "callPackageWith",
    "position": {
      "column": 21,
      "file": "/home/johannes/git/nixpkgs/lib/customisation.nix",
      "line": 125
    }
  },
  {
    "content": "Like callPackage, but for a function that returns an attribute\nset of derivations. The override function is added to the\nindividual attributes.",
    "isPrimop": false,
    "name": "callPackagesWith",
    "position": {
      "column": 22,
      "file": "/home/johannes/git/nixpkgs/lib/customisation.nix",
      "line": 184
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "canCleanSource",
    "position": {
      "column": 20,
      "file": "/home/johannes/git/nixpkgs/lib/sources.nix",
      "line": 247
    }
  },
  {
    "content": "Return the cartesian product of attribute set value combinations.\n\n# Example\n\n```nix\ncartesianProductOfSets { a = [ 1 2 ]; b = [ 10 20 ]; }\n=> [\n{ a = 1; b = 10; }\n{ a = 1; b = 20; }\n{ a = 2; b = 10; }\n{ a = 2; b = 20; }\n]\n```\n\n# Type\n\n```haskell\ncartesianProductOfSets :: AttrSet -> [AttrSet]\n```",
    "isPrimop": false,
    "name": "cartesianProductOfSets",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/attrsets.nix",
      "line": 577
    }
  },
  {
    "content": "Collect each attribute named *attr* from a list of attribute\nsets.  Attrsets that don't contain the named attribute are\nignored. For example,\n\n```nix\nbuiltins.catAttrs \"a\" [{a = 1;} {b = 0;} {a = 2;}]\n```\n\nevaluates to `[1 2]`.",
    "isPrimop": true,
    "name": "catAttrs",
    "position": null
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "checkFlag",
    "position": {
      "column": 15,
      "file": "/home/johannes/git/nixpkgs/lib/deprecated.nix",
      "line": 57
    }
  },
  {
    "content": "Check if the elements in a list are valid values from a enum, returning the identity function, or throwing an error message otherwise.\n\n# Example\n\n```nix\nlet colorVariants = [\"bright\" \"dark\" \"black\"]\nin checkListOfEnum \"color variants\" [ \"standard\" \"light\" \"dark\" ] colorVariants;\n=>\nerror: color variants: bright, black unexpected; valid ones: standard, light, dark\n```\n\n# Type\n\n```haskell\nString -> List ComparableVal -> List ComparableVal -> a -> a\n```",
    "isPrimop": false,
    "name": "checkListOfEnum",
    "position": {
      "column": 21,
      "file": "/home/johannes/git/nixpkgs/lib/trivial.nix",
      "line": 552
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "checkReqs",
    "position": {
      "column": 15,
      "file": "/home/johannes/git/nixpkgs/lib/deprecated.nix",
      "line": 78
    }
  },
  {
    "content": "Pick the outputs of packages to place in `buildInputs`\n\n# Type\n\n```haskell\nchooseDevOutputs :: [Derivation] -> [String]\n```",
    "isPrimop": false,
    "name": "chooseDevOutputs",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/attrsets.nix",
      "line": 1273
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "cleanSource",
    "position": {
      "column": 17,
      "file": "/home/johannes/git/nixpkgs/lib/sources.nix",
      "line": 52
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "cleanSourceFilter",
    "position": {
      "column": 23,
      "file": "/home/johannes/git/nixpkgs/lib/sources.nix",
      "line": 26
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "cleanSourceWith",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/sources.nix",
      "line": 76
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "closePropagation",
    "position": {
      "column": 26,
      "file": "/home/johannes/git/nixpkgs/lib/deprecated.nix",
      "line": 168
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "collect",
    "position": {
      "column": 3,
      "file": "/home/johannes/git/nixpkgs/lib/attrsets.nix",
      "line": 544
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "commitIdFromGitRepo",
    "position": {
      "column": 25,
      "file": "/home/johannes/git/nixpkgs/lib/sources.nix",
      "line": 184
    }
  },
  {
    "content": "C-style comparisons\n\na < b,  compare a b => -1\na == b, compare a b => 0\na > b,  compare a b => 1",
    "isPrimop": false,
    "name": "compare",
    "position": {
      "column": 13,
      "file": "/home/johannes/git/nixpkgs/lib/trivial.nix",
      "line": 367
    }
  },
  {
    "content": "Compare two lists element-by-element.\n\n# Example\n\n```nix\ncompareLists compare [] []\n=> 0\ncompareLists compare [] [ \"a\" ]\n=> -1\ncompareLists compare [ \"a\" ] []\n=> 1\ncompareLists compare [ \"a\" \"b\" ] [ \"a\" \"c\" ]\n=> -1\n```",
    "isPrimop": false,
    "name": "compareLists",
    "position": {
      "column": 18,
      "file": "/home/johannes/git/nixpkgs/lib/lists.nix",
      "line": 787
    }
  },
  {
    "content": "Compose two extending functions of the type expected by 'extends'\ninto one where changes made in the first are available in the\n'super' of the second",
    "isPrimop": false,
    "name": "composeExtensions",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/fixed-points.nix",
      "line": 107
    }
  },
  {
    "content": "“right fold” a binary function `op` between successive elements of\n`list` with `nul` as the starting value, i.e.,\n`foldr op nul [x_1 x_2 ... x_n] == op x_1 (op x_2 ... (op x_n nul))`.\n\n# Example\n\n```nix\nconcat = foldr (a: b: a + b) \"z\"\nconcat [ \"a\" \"b\" \"c\" ]\n=> \"abcz\"\n# different types\nstrange = foldr (int: str: toString (int + 1) + str) \"a\"\nstrange [ 1 2 3 4 ]\n=> \"2345a\"\n```\n\n# Type\n\n```haskell\nfoldr :: (a -> b -> b) -> b -> [a] -> b\n```",
    "isPrimop": false,
    "name": "composeManyExtensions",
    "position": {
      "column": 20,
      "file": "/home/johannes/git/nixpkgs/lib/lists.nix",
      "line": 77
    }
  },
  {
    "content": "Concatenate two lists\n\n# Example\n\n```nix\nconcat [ 1 2 ] [ 3 4 ]\n=> [ 1 2 3 4 ]\n```\n\n# Type\n\n```haskell\nconcat :: [a] -> [a] -> [a]\n```",
    "isPrimop": false,
    "name": "concat",
    "position": {
      "column": 12,
      "file": "/home/johannes/git/nixpkgs/lib/trivial.nix",
      "line": 111
    }
  },
  {
    "content": "Like `concatMapStrings` except that the f functions also gets the\nposition as a parameter.\n\n# Example\n\n```nix\nconcatImapStrings (pos: x: \"${toString pos}-${x}\") [\"foo\" \"bar\"]\n=> \"1-foo2-bar\"\n```\n\n# Type\n\n```haskell\nconcatImapStrings :: (int -> a -> string) -> [a] -> string\n```",
    "isPrimop": false,
    "name": "concatImapStrings",
    "position": {
      "column": 23,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 97
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "concatImapStringsSep",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 188
    }
  },
  {
    "content": "Map a function over a list and concatenate the resulting strings.\n\n# Example\n\n```nix\nconcatMapStrings (x: \"a\" + x) [\"foo\" \"bar\"]\n=> \"afooabar\"\n```\n\n# Type\n\n```haskell\nconcatMapStrings :: (a -> string) -> [a] -> string\n```",
    "isPrimop": false,
    "name": "concatLines",
    "position": {
      "column": 25,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 78
    }
  },
  {
    "content": "Concatenate a list of lists into a single list.",
    "isPrimop": true,
    "name": "concatLists",
    "position": null
  },
  {
    "content": "This function is equivalent to `builtins.concatLists (map f list)`\nbut is more efficient.",
    "isPrimop": true,
    "name": "concatMap",
    "position": null
  },
  {
    "content": "Map each attribute in the given set and merge them into a new attribute set.\n\n# Example\n\n```nix\nconcatMapAttrs\n(name: value: {\n${name} = value;\n${name + value} = value;\n})\n{ x = \"a\"; y = \"b\"; }\n=> { x = \"a\"; xa = \"a\"; y = \"b\"; yb = \"b\"; }\n```\n\n# Type\n\n```haskell\nconcatMapAttrs :: (String -> a -> AttrSet) -> AttrSet -> AttrSet\n```",
    "isPrimop": false,
    "name": "concatMapAttrs",
    "position": {
      "column": 20,
      "file": "/home/johannes/git/nixpkgs/lib/attrsets.nix",
      "line": 160
    }
  },
  {
    "content": "Map a function over a list and concatenate the resulting strings.\n\n# Example\n\n```nix\nconcatMapStrings (x: \"a\" + x) [\"foo\" \"bar\"]\n=> \"afooabar\"\n```\n\n# Type\n\n```haskell\nconcatMapStrings :: (a -> string) -> [a] -> string\n```",
    "isPrimop": false,
    "name": "concatMapStrings",
    "position": {
      "column": 22,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 78
    }
  },
  {
    "content": "Maps a function over a list of strings and then concatenates the\nresult with the specified separator interspersed between\nelements.\n\n# Example\n\n```nix\nconcatMapStringsSep \"-\" (x: toUpper x)  [\"foo\" \"bar\" \"baz\"]\n=> \"FOO-BAR-BAZ\"\n```\n\n# Type\n\n```haskell\nconcatMapStringsSep :: string -> (a -> string) -> [a] -> string\n```",
    "isPrimop": false,
    "name": "concatMapStringsSep",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 163
    }
  },
  {
    "content": "Concatenate a list of strings with a separator between each\nelement, e.g. `concatStringsSep \"/\" [\"usr\" \"local\" \"bin\"] ==\n\"usr/local/bin\"`.",
    "isPrimop": true,
    "name": "concatStrings",
    "position": null
  },
  {
    "content": "Concatenate a list of strings with a separator between each\nelement, e.g. `concatStringsSep \"/\" [\"usr\" \"local\" \"bin\"] ==\n\"usr/local/bin\"`.",
    "isPrimop": true,
    "name": "concatStringsSep",
    "position": null
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "condConcat",
    "position": {
      "column": 16,
      "file": "/home/johannes/git/nixpkgs/lib/deprecated.nix",
      "line": 114
    }
  },
  {
    "content": "The constant function\n\nIgnores the second argument. If called with only one argument,\nconstructs a function that always returns a static value.\n\n# Example\n\n```nix\nlet f = const 5; in f 10\n=> 5\n```\n\n# Type\n\n```haskell\nconst :: a -> b -> a\n```",
    "isPrimop": false,
    "name": "const",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/trivial.nix",
      "line": 42
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "converge",
    "position": {
      "column": 14,
      "file": "/home/johannes/git/nixpkgs/lib/fixed-points.nix",
      "line": 55
    }
  },
  {
    "content": "Count how many elements of `list` match the supplied predicate\nfunction.\n\n# Example\n\n```nix\ncount (x: x == 3) [ 3 2 3 4 6 ]\n=> 2\n```\n\n# Type\n\n```haskell\ncount :: (a -> bool) -> [a] -> int\n```",
    "isPrimop": false,
    "name": "count",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/lists.nix",
      "line": 420
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "crossLists",
    "position": {
      "column": 6,
      "file": "/home/johannes/git/nixpkgs/lib/lists.nix",
      "line": 1042
    }
  },
  {
    "content": "This is like `seq e1 e2`, except that *e1* is evaluated *deeply*:\nif it’s a list or set, its elements or attributes are also\nevaluated recursively.",
    "isPrimop": true,
    "name": "deepSeq",
    "position": null
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "defaultFunctor",
    "position": {
      "column": 20,
      "file": "/home/johannes/git/nixpkgs/lib/types.nix",
      "line": 99
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "defaultMerge",
    "position": {
      "column": 18,
      "file": "/home/johannes/git/nixpkgs/lib/deprecated.nix",
      "line": 22
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "defaultMergeArg",
    "position": {
      "column": 21,
      "file": "/home/johannes/git/nixpkgs/lib/deprecated.nix",
      "line": 18
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "defaultTypeMerge",
    "position": {
      "column": 22,
      "file": "/home/johannes/git/nixpkgs/lib/types.nix",
      "line": 79
    }
  },
  {
    "content": "Given a config value, expand mkMerge properties, and discharge\nany mkIf conditions.  That is, this is the place where mkIf\nconditions are actually evaluated.  The result is a list of\nconfig values.  For example, ‘mkIf false x’ yields ‘[]’,\n‘mkIf true x’ yields ‘[x]’, and\n\nmkMerge [ 1 (mkIf true 2) (mkIf true (mkIf false 3)) ]\n\nyields ‘[ 1 2 ]’.",
    "isPrimop": false,
    "name": "dischargeProperties",
    "position": {
      "column": 25,
      "file": "/home/johannes/git/nixpkgs/lib/modules.nix",
      "line": 900
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "doRename",
    "position": {
      "column": 14,
      "file": "/home/johannes/git/nixpkgs/lib/modules.nix",
      "line": 1285
    }
  },
  {
    "content": "Disable Hydra builds of given derivation.",
    "isPrimop": false,
    "name": "dontDistribute",
    "position": {
      "column": 20,
      "file": "/home/johannes/git/nixpkgs/lib/meta.nix",
      "line": 28
    }
  },
  {
    "content": "Undo the effect of recurseIntoAttrs.\n\n# Type\n\n```haskell\ndontRecurseIntoAttrs :: AttrSet -> AttrSet\n```",
    "isPrimop": false,
    "name": "dontRecurseIntoAttrs",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/attrsets.nix",
      "line": 1316
    }
  },
  {
    "content": "Remove the first (at most) N elements of a list.\n\n# Example\n\n```nix\ndrop 2 [ \"a\" \"b\" \"c\" \"d\" ]\n=> [ \"c\" \"d\" ]\ndrop 2 [ ]\n=> [ ]\n```\n\n# Type\n\n```haskell\ndrop :: int -> [a] -> [a]\n```",
    "isPrimop": false,
    "name": "drop",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/lists.nix",
      "line": 864
    }
  },
  {
    "content": "Return `true` if a value equal to *x* occurs in the list *xs*, and\n`false` otherwise.",
    "isPrimop": true,
    "name": "elem",
    "position": null
  },
  {
    "content": "Return element *n* from the list *xs*. Elements are counted starting\nfrom 0. A fatal error occurs if the index is out of bounds.",
    "isPrimop": true,
    "name": "elemAt",
    "position": null
  },
  {
    "content": "Create an --{enable,disable}-<feat> string that can be passed to\nstandard GNU Autoconf scripts.\n\n# Example\n\n```nix\nenableFeature true \"shared\"\n=> \"--enable-shared\"\nenableFeature false \"shared\"\n=> \"--disable-shared\"\n```",
    "isPrimop": false,
    "name": "enableFeature",
    "position": {
      "column": 19,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 1144
    }
  },
  {
    "content": "Create an --{enable-<feat>=<value>,disable-<feat>} string that can be passed to\nstandard GNU Autoconf scripts.\n\n# Example\n\n```nix\nenableFeatureAs true \"shared\" \"foo\"\n=> \"--enable-shared=foo\"\nenableFeatureAs false \"shared\" (throw \"ignored\")\n=> \"--disable-shared\"\n```",
    "isPrimop": false,
    "name": "enableFeatureAs",
    "position": {
      "column": 21,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 1161
    }
  },
  {
    "content": "Escape occurrence of the elements of `list` in `string` by\nprefixing it with a backslash.\n\n# Example\n\n```nix\nescape [\"(\" \")\"] \"(foo)\"\n=> \"\\\\(foo\\\\)\"\n```\n\n# Type\n\n```haskell\nescape :: [string] -> string -> string\n```",
    "isPrimop": false,
    "name": "escape",
    "position": {
      "column": 12,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 552
    }
  },
  {
    "content": "Given string *s*, replace every occurrence of the strings in *from*\nwith the corresponding string in *to*.\n\nThe argument *to* is lazy, that is, it is only evaluated when its corresponding pattern in *from* is matched in the string *s*\n\nExample:\n\n```nix\nbuiltins.replaceStrings [\"oo\" \"a\"] [\"a\" \"i\"] \"foobar\"\n```\n\nevaluates to `\"fabir\"`.",
    "isPrimop": true,
    "name": "escapeRegex",
    "position": null
  },
  {
    "content": "Quote string to be used safely within the Bourne shell.\n\n# Example\n\n```nix\nescapeShellArg \"esc'ape\\nme\"\n=> \"'esc'\\\\''ape\\nme'\"\n```\n\n# Type\n\n```haskell\nescapeShellArg :: string -> string\n```",
    "isPrimop": false,
    "name": "escapeShellArg",
    "position": {
      "column": 20,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 613
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "escapeShellArgs",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 167
    }
  },
  {
    "content": "Given string *s*, replace every occurrence of the strings in *from*\nwith the corresponding string in *to*.\n\nThe argument *to* is lazy, that is, it is only evaluated when its corresponding pattern in *from* is matched in the string *s*\n\nExample:\n\n```nix\nbuiltins.replaceStrings [\"oo\" \"a\"] [\"a\" \"i\"] \"foobar\"\n```\n\nevaluates to `\"fabir\"`.",
    "isPrimop": true,
    "name": "escapeURL",
    "position": null
  },
  {
    "content": "Given string *s*, replace every occurrence of the strings in *from*\nwith the corresponding string in *to*.\n\nThe argument *to* is lazy, that is, it is only evaluated when its corresponding pattern in *from* is matched in the string *s*\n\nExample:\n\n```nix\nbuiltins.replaceStrings [\"oo\" \"a\"] [\"a\" \"i\"] \"foobar\"\n```\n\nevaluates to `\"fabir\"`.",
    "isPrimop": true,
    "name": "escapeXML",
    "position": null
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "evalModules",
    "position": {
      "column": 17,
      "file": "/home/johannes/git/nixpkgs/lib/modules.nix",
      "line": 75
    }
  },
  {
    "content": "Merge all the definitions of an option to produce the final\nconfig value.",
    "isPrimop": false,
    "name": "evalOptionValue",
    "position": {
      "column": 21,
      "file": "/home/johannes/git/nixpkgs/lib/modules.nix",
      "line": 782
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "extend",
    "position": {
      "column": 25,
      "file": "/home/johannes/git/nixpkgs/lib/fixed-points.nix",
      "line": 153
    }
  },
  {
    "content": "Add attributes to each output of a derivation without changing\nthe derivation itself and check a given condition when evaluating.",
    "isPrimop": false,
    "name": "extendDerivation",
    "position": {
      "column": 22,
      "file": "/home/johannes/git/nixpkgs/lib/customisation.nix",
      "line": 203
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "extends",
    "position": {
      "column": 13,
      "file": "/home/johannes/git/nixpkgs/lib/fixed-points.nix",
      "line": 99
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "fileContents",
    "position": {
      "column": 18,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 1477
    }
  },
  {
    "content": "Return a list consisting of the elements of *list* for which the\nfunction *f* returns `true`.",
    "isPrimop": true,
    "name": "filter",
    "position": null
  },
  {
    "content": "Filter an attribute set by removing all attributes for which the\ngiven predicate return false.\n\n# Example\n\n```nix\nfilterAttrs (n: v: n == \"foo\") { foo = 1; bar = 2; }\n=> { foo = 1; }\n```\n\n# Type\n\n```haskell\nfilterAttrs :: (String -> Any -> Bool) -> AttrSet -> AttrSet\n```",
    "isPrimop": false,
    "name": "filterAttrs",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/attrsets.nix",
      "line": 384
    }
  },
  {
    "content": "Filter an attribute set recursively by removing all attributes for\nwhich the given predicate return false.\n\n# Example\n\n```nix\nfilterAttrsRecursive (n: v: v != null) { foo = { bar = null; }; }\n=> { foo = {}; }\n```\n\n# Type\n\n```haskell\nfilterAttrsRecursive :: (String -> Any -> Bool) -> AttrSet -> AttrSet\n```",
    "isPrimop": false,
    "name": "filterAttrsRecursive",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/attrsets.nix",
      "line": 409
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "filterOverrides",
    "position": {
      "column": 21,
      "file": "/home/johannes/git/nixpkgs/lib/modules.nix",
      "line": 934
    }
  },
  {
    "content": "Find the first element in the list matching the specified\npredicate or return `default` if no such element exists.\n\n# Example\n\n```nix\nfindFirst (x: x > 3) 7 [ 1 6 4 ]\n=> 6\nfindFirst (x: x > 9) 7 [ 1 6 4 ]\n=> 7\n```\n\n# Type\n\n```haskell\nfindFirst :: (a -> bool) -> a -> [a] -> a\n```",
    "isPrimop": false,
    "name": "findFirst",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/lists.nix",
      "line": 346
    }
  },
  {
    "content": "Find the sole element in the list matching the specified\npredicate, returns `default` if no such element exists, or\n`multiple` if there are multiple matching elements.\n\n# Example\n\n```nix\nfindSingle (x: x == 3) \"none\" \"multiple\" [ 1 3 3 ]\n=> \"multiple\"\nfindSingle (x: x == 3) \"none\" \"multiple\" [ 1 3 ]\n=> 3\nfindSingle (x: x == 3) \"none\" \"multiple\" [ 1 9 ]\n=> \"none\"\n```\n\n# Type\n\n```haskell\nfindSingle :: (a -> bool) -> a -> a -> [a] -> a\n```",
    "isPrimop": false,
    "name": "findSingle",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/lists.nix",
      "line": 254
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "fix",
    "position": {
      "column": 9,
      "file": "/home/johannes/git/nixpkgs/lib/fixed-points.nix",
      "line": 29
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "fix'",
    "position": {
      "column": 10,
      "file": "/home/johannes/git/nixpkgs/lib/fixed-points.nix",
      "line": 38
    }
  },
  {
    "content": "Compatibility.",
    "isPrimop": false,
    "name": "fixMergeModules",
    "position": {
      "column": 21,
      "file": "/home/johannes/git/nixpkgs/lib/modules.nix",
      "line": 1090
    }
  },
  {
    "content": "Format a number adding leading zeroes up to fixed width.\n\n# Example\n\n```nix\nfixedWidthNumber 5 15\n=> \"00015\"\n```",
    "isPrimop": false,
    "name": "fixedWidthNumber",
    "position": {
      "column": 22,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 1236
    }
  },
  {
    "content": "Create a fixed width string with additional prefix to match\nrequired width.\n\nThis function will fail if the input string is longer than the\nrequested length.\n\n# Example\n\n```nix\nfixedWidthString 5 \"0\" (toString 15)\n=> \"00015\"\n```\n\n# Type\n\n```haskell\nfixedWidthString :: int -> string -> string -> string\n```",
    "isPrimop": false,
    "name": "fixedWidthString",
    "position": {
      "column": 22,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 1215
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "fixupOptionType",
    "position": {
      "column": 21,
      "file": "/home/johannes/git/nixpkgs/lib/modules.nix",
      "line": 964
    }
  },
  {
    "content": "Flatten the argument into a single list; that is, nested lists are\nspliced into the top-level lists.\n\n# Example\n\n```nix\nflatten [1 [2 [3] 4] 5]\n=> [1 2 3 4 5]\nflatten 1\n=> [1]\n```",
    "isPrimop": false,
    "name": "flatten",
    "position": {
      "column": 13,
      "file": "/home/johannes/git/nixpkgs/lib/lists.nix",
      "line": 205
    }
  },
  {
    "content": "Flip the order of the arguments of a binary function.\n\n# Example\n\n```nix\nflip concat [1] [2]\n=> [ 2 1 ]\n```\n\n# Type\n\n```haskell\nflip :: (a -> b -> c) -> (b -> a -> c)\n```",
    "isPrimop": false,
    "name": "flip",
    "position": {
      "column": 10,
      "file": "/home/johannes/git/nixpkgs/lib/trivial.nix",
      "line": 198
    }
  },
  {
    "content": "“right fold” a binary function `op` between successive elements of\n`list` with `nul` as the starting value, i.e.,\n`foldr op nul [x_1 x_2 ... x_n] == op x_1 (op x_2 ... (op x_n nul))`.\n\n# Example\n\n```nix\nconcat = foldr (a: b: a + b) \"z\"\nconcat [ \"a\" \"b\" \"c\" ]\n=> \"abcz\"\n# different types\nstrange = foldr (int: str: toString (int + 1) + str) \"a\"\nstrange [ 1 2 3 4 ]\n=> \"2345a\"\n```\n\n# Type\n\n```haskell\nfoldr :: (a -> b -> b) -> b -> [a] -> b\n```",
    "isPrimop": false,
    "name": "fold",
    "position": {
      "column": 11,
      "file": "/home/johannes/git/nixpkgs/lib/lists.nix",
      "line": 77
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "foldArgs",
    "position": {
      "column": 14,
      "file": "/home/johannes/git/nixpkgs/lib/deprecated.nix",
      "line": 23
    }
  },
  {
    "content": "Apply fold functions to values grouped by key.\n\n# Example\n\n```nix\nfoldAttrs (item: acc: [item] ++ acc) [] [{ a = 2; } { a = 3; }]\n=> { a = [ 2 3 ]; }\n```\n\n# Type\n\n```haskell\nfoldAttrs :: (Any -> Any -> Any) -> Any -> [AttrSets] -> Any\n```",
    "isPrimop": false,
    "name": "foldAttrs",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/attrsets.nix",
      "line": 508
    }
  },
  {
    "content": "“left fold”, like `foldr`, but from the left:\n`foldl op nul [x_1 x_2 ... x_n] == op (... (op (op nul x_1) x_2) ... x_n)`.\n\n# Example\n\n```nix\nlconcat = foldl (a: b: a + b) \"z\"\nlconcat [ \"a\" \"b\" \"c\" ]\n=> \"zabc\"\n# different types\nlstrange = foldl (str: int: str + toString (int + 1)) \"a\"\nlstrange [ 1 2 3 4 ]\n=> \"a2345\"\n```\n\n# Type\n\n```haskell\nfoldl :: (b -> a -> b) -> b -> [a] -> b\n```",
    "isPrimop": false,
    "name": "foldl",
    "position": {
      "column": 11,
      "file": "/home/johannes/git/nixpkgs/lib/lists.nix",
      "line": 115
    }
  },
  {
    "content": "Reduce a list by applying a binary operator, from left to right,\ne.g. `foldl' op nul [x0 x1 x2 ...] = op (op (op nul x0) x1) x2)\n...`. For example, `foldl' (x: y: x + y) 0 [1 2 3]` evaluates to 6.\nThe return value of each application of `op` is evaluated immediately,\neven for intermediate values.",
    "isPrimop": true,
    "name": "foldl'",
    "position": null
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "foldlAttrs",
    "position": {
      "column": 16,
      "file": "/home/johannes/git/nixpkgs/lib/attrsets.nix",
      "line": 484
    }
  },
  {
    "content": "“right fold” a binary function `op` between successive elements of\n`list` with `nul` as the starting value, i.e.,\n`foldr op nul [x_1 x_2 ... x_n] == op x_1 (op x_2 ... (op x_n nul))`.\n\n# Example\n\n```nix\nconcat = foldr (a: b: a + b) \"z\"\nconcat [ \"a\" \"b\" \"c\" ]\n=> \"abcz\"\n# different types\nstrange = foldr (int: str: toString (int + 1) + str) \"a\"\nstrange [ 1 2 3 4 ]\n=> \"2345a\"\n```\n\n# Type\n\n```haskell\nfoldr :: (a -> b -> b) -> b -> [a] -> b\n```",
    "isPrimop": false,
    "name": "foldr",
    "position": {
      "column": 11,
      "file": "/home/johannes/git/nixpkgs/lib/lists.nix",
      "line": 77
    }
  },
  {
    "content": "Apply the function to each element in the list. Same as `map`, but arguments\nflipped.\n\n# Example\n\n```nix\nforEach [ 1 2 ] (x:\ntoString x\n)\n=> [ \"1\" \"2\" ]\n```\n\n# Type\n\n```haskell\nforEach :: [a] -> (a -> b) -> [b]\n```",
    "isPrimop": false,
    "name": "forEach",
    "position": {
      "column": 13,
      "file": "/home/johannes/git/nixpkgs/lib/lists.nix",
      "line": 52
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "fullDepEntry",
    "position": {
      "column": 18,
      "file": "/home/johannes/git/nixpkgs/lib/strings-with-deps.nix",
      "line": 81
    }
  },
  {
    "content": "Extract the expected function arguments from a function.\nThis works both with nix-native { a, b ? foo, ... }: style\nfunctions and functions with args set with 'setFunctionArgs'. It\nhas the same return type and semantics as builtins.functionArgs.\nsetFunctionArgs : (a → b) → Map String Bool.",
    "isPrimop": false,
    "name": "functionArgs",
    "position": {
      "column": 18,
      "file": "/home/johannes/git/nixpkgs/lib/trivial.nix",
      "line": 589
    }
  },
  {
    "content": "Generate an attribute set by mapping a function over a list of\nattribute names.\n\n# Example\n\n```nix\ngenAttrs [ \"foo\" \"bar\" ] (name: \"x_\" + name)\n=> { foo = \"x_foo\"; bar = \"x_bar\"; }\n```\n\n# Type\n\n```haskell\ngenAttrs :: [ String ] -> (String -> Any) -> AttrSet\n```",
    "isPrimop": false,
    "name": "genAttrs",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/attrsets.nix",
      "line": 778
    }
  },
  {
    "content": "Generate list of size *length*, with each element *i* equal to the\nvalue returned by *generator* `i`. For example,\n\n```nix\nbuiltins.genList (x: x * x) 5\n```\n\nreturns the list `[ 0 1 4 9 16 ]`.",
    "isPrimop": true,
    "name": "genList",
    "position": null
  },
  {
    "content": "Take an *attrset* with values named `startSet` and `operator` in order to\nreturn a *list of attrsets* by starting with the `startSet` and recursively\napplying the `operator` function to each `item`. The *attrsets* in the\n`startSet` and the *attrsets* produced by `operator` must contain a value\nnamed `key` which is comparable. The result is produced by calling `operator`\nfor each `item` with a value for `key` that has not been called yet including\nnewly produced `item`s. The function terminates when no new `item`s are\nproduced. The resulting *list of attrsets* contains only *attrsets* with a\nunique key. For example,\n\n```\nbuiltins.genericClosure {\n  startSet = [ {key = 5;} ];\n  operator = item: [{\n    key = if (item.key / 2 ) * 2 == item.key\n         then item.key / 2\n         else 3 * item.key + 1;\n  }];\n}\n```\nevaluates to\n```\n[ { key = 5; } { key = 16; } { key = 8; } { key = 4; } { key = 2; } { key = 1; } ]\n```",
    "isPrimop": true,
    "name": "genericClosure",
    "position": null
  },
  {
    "content": "`getAttr` returns the attribute named *s* from *set*. Evaluation\naborts if the attribute doesn’t exist. This is a dynamic version of\nthe `.` operator, since *s* is an expression rather than an\nidentifier.",
    "isPrimop": true,
    "name": "getAttr",
    "position": null
  },
  {
    "content": "Like `attrByPath`, but without a default value. If it doesn't find the\npath it will throw an error.\n\n# Example\n\n```nix\nx = { a = { b = 3; }; }\ngetAttrFromPath [\"a\" \"b\"] x\n=> 3\ngetAttrFromPath [\"z\" \"z\"] x\n=> error: cannot find attribute `z.z'\n```\n\n# Type\n\n```haskell\ngetAttrFromPath :: [String] -> AttrSet -> Any\n```",
    "isPrimop": false,
    "name": "getAttrFromPath",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/attrsets.nix",
      "line": 133
    }
  },
  {
    "content": "Given a set of attribute names, return the set of the corresponding\nattributes from the given set.\n\n# Example\n\n```nix\ngetAttrs [ \"a\" \"b\" ] { a = 1; b = 2; c = 3; }\n=> { a = 1; b = 2; }\n```\n\n# Type\n\n```haskell\ngetAttrs :: [String] -> AttrSet -> AttrSet\n```",
    "isPrimop": false,
    "name": "getAttrs",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/attrsets.nix",
      "line": 340
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "getBin",
    "position": {
      "column": 23,
      "file": "/home/johannes/git/nixpkgs/lib/attrsets.nix",
      "line": 1178
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "getDev",
    "position": {
      "column": 23,
      "file": "/home/johannes/git/nixpkgs/lib/attrsets.nix",
      "line": 1178
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "getExe",
    "position": {
      "column": 12,
      "file": "/home/johannes/git/nixpkgs/lib/meta.nix",
      "line": 182
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "getExe'",
    "position": {
      "column": 13,
      "file": "/home/johannes/git/nixpkgs/lib/meta.nix",
      "line": 211
    }
  },
  {
    "content": "Apply the function *f* to each element in the list *list*. For\nexample,\n\n```nix\nmap (x: \"foo\" + x) [ \"bar\" \"bla\" \"abc\" ]\n```\n\nevaluates to `[ \"foobar\" \"foobla\" \"fooabc\" ]`.",
    "isPrimop": true,
    "name": "getFiles",
    "position": null
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "getLib",
    "position": {
      "column": 23,
      "file": "/home/johannes/git/nixpkgs/lib/attrsets.nix",
      "line": 1178
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "getLicenseFromSpdxId",
    "position": {
      "column": 8,
      "file": "/home/johannes/git/nixpkgs/lib/meta.nix",
      "line": 158
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "getMan",
    "position": {
      "column": 23,
      "file": "/home/johannes/git/nixpkgs/lib/attrsets.nix",
      "line": 1178
    }
  },
  {
    "content": "This function takes an argument that's either a derivation or a\nderivation's \"name\" attribute and extracts the name part from that\nargument.\n\n# Example\n\n```nix\ngetName \"youtube-dl-2016.01.01\"\n=> \"youtube-dl\"\ngetName pkgs.youtube-dl\n=> \"youtube-dl\"\n```",
    "isPrimop": false,
    "name": "getName",
    "position": {
      "column": 13,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 1004
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "getOutput",
    "position": {
      "column": 15,
      "file": "/home/johannes/git/nixpkgs/lib/attrsets.nix",
      "line": 1178
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "getValue",
    "position": {
      "column": 14,
      "file": "/home/johannes/git/nixpkgs/lib/deprecated.nix",
      "line": 66
    }
  },
  {
    "content": "Apply the function *f* to each element in the list *list*. For\nexample,\n\n```nix\nmap (x: \"foo\" + x) [ \"bar\" \"bla\" \"abc\" ]\n```\n\nevaluates to `[ \"foobar\" \"foobla\" \"fooabc\" ]`.",
    "isPrimop": true,
    "name": "getValues",
    "position": null
  },
  {
    "content": "This function takes an argument that's either a derivation or a\nderivation's \"name\" attribute and extracts the version part from that\nargument.\n\n# Example\n\n```nix\ngetVersion \"youtube-dl-2016.01.01\"\n=> \"2016.01.01\"\ngetVersion pkgs.youtube-dl\n=> \"2016.01.01\"\n```",
    "isPrimop": false,
    "name": "getVersion",
    "position": {
      "column": 16,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 1025
    }
  },
  {
    "content": "Groups elements of *list* together by the string returned from the\nfunction *f* called on each element. It returns an attribute set\nwhere each attribute value contains the elements of *list* that are\nmapped to the same corresponding attribute name returned by *f*.\n\nFor example,\n\n```nix\nbuiltins.groupBy (builtins.substring 0 1) [\"foo\" \"bar\" \"baz\"]\n```\n\nevaluates to\n\n```nix\n{ b = [ \"bar\" \"baz\" ]; f = [ \"foo\" ]; }\n```",
    "isPrimop": true,
    "name": "groupBy",
    "position": null
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "groupBy'",
    "position": {
      "column": 14,
      "file": "/home/johannes/git/nixpkgs/lib/lists.nix",
      "line": 583
    }
  },
  {
    "content": "`hasAttr` returns `true` if *set* has an attribute named *s*, and\n`false` otherwise. This is a dynamic version of the `?` operator,\nsince *s* is an expression rather than an identifier.",
    "isPrimop": true,
    "name": "hasAttr",
    "position": null
  },
  {
    "content": "Return if an attribute from nested attribute set exists.\n\n# Example\n\n```nix\nx = { a = { b = 3; }; }\nhasAttrByPath [\"a\" \"b\"] x\n=> true\nhasAttrByPath [\"z\" \"z\"] x\n=> false\n```\n\n# Type\n\n```haskell\nhasAttrByPath :: [String] -> AttrSet -> Bool\n```",
    "isPrimop": false,
    "name": "hasAttrByPath",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/attrsets.nix",
      "line": 71
    }
  },
  {
    "content": "Determine whether a string contains the given infix\n\n# Example\n\n```nix\nhasInfix \"bc\" \"abcd\"\n=> true\nhasInfix \"ab\" \"abcd\"\n=> true\nhasInfix \"cd\" \"abcd\"\n=> true\nhasInfix \"foo\" \"abcd\"\n=> false\n```\n\n# Type\n\n```haskell\nhasInfix :: string -> string -> bool\n```",
    "isPrimop": false,
    "name": "hasInfix",
    "position": {
      "column": 14,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 449
    }
  },
  {
    "content": "Determine whether a string has given prefix.\n\n# Example\n\n```nix\nhasPrefix \"foo\" \"foobar\"\n=> true\nhasPrefix \"foo\" \"barfoo\"\n=> false\n```\n\n# Type\n\n```haskell\nhasPrefix :: string -> string -> bool\n```",
    "isPrimop": false,
    "name": "hasPrefix",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 371
    }
  },
  {
    "content": "Determine whether a string has given suffix.\n\n# Example\n\n```nix\nhasSuffix \"foo\" \"foobar\"\n=> false\nhasSuffix \"foo\" \"barfoo\"\n=> true\n```\n\n# Type\n\n```haskell\nhasSuffix :: string -> string -> bool\n```",
    "isPrimop": false,
    "name": "hasSuffix",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 406
    }
  },
  {
    "content": "Return the first element of a list; abort evaluation if the argument\nisn’t a list or is an empty list. You can test whether a list is\nempty by comparing it with `[]`.",
    "isPrimop": true,
    "name": "head",
    "position": null
  },
  {
    "content": "Add to or override the meta attributes of the given\nderivation.\n\n# Example\n\n```nix\naddMetaAttrs {description = \"Bla blah\";} somePkg\n```",
    "isPrimop": false,
    "name": "hiPrio",
    "position": {
      "column": 28,
      "file": "/home/johannes/git/nixpkgs/lib/meta.nix",
      "line": 21
    }
  },
  {
    "content": "Apply hiPrio to an attrset with derivations",
    "isPrimop": false,
    "name": "hiPrioSet",
    "position": {
      "column": 15,
      "file": "/home/johannes/git/nixpkgs/lib/meta.nix",
      "line": 89
    }
  },
  {
    "content": "Strip a derivation of all non-essential attributes, returning\nonly those needed by hydra-eval-jobs. Also strictly evaluate the\nresult to ensure that there are no thunks kept alive to prevent\ngarbage collection.",
    "isPrimop": false,
    "name": "hydraJob",
    "position": {
      "column": 14,
      "file": "/home/johannes/git/nixpkgs/lib/customisation.nix",
      "line": 239
    }
  },
  {
    "content": "The identity function\nFor when you need a function that does “nothing”.\n\n# Type\n\n```haskell\nid :: a -> a\n```",
    "isPrimop": false,
    "name": "id",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/trivial.nix",
      "line": 19
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "ifEnable",
    "position": {
      "column": 14,
      "file": "/home/johannes/git/nixpkgs/lib/deprecated.nix",
      "line": 47
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "imap",
    "position": {
      "column": 11,
      "file": "/home/johannes/git/nixpkgs/lib/lists.nix",
      "line": 172
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "imap0",
    "position": {
      "column": 11,
      "file": "/home/johannes/git/nixpkgs/lib/lists.nix",
      "line": 154
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "imap1",
    "position": {
      "column": 11,
      "file": "/home/johannes/git/nixpkgs/lib/lists.nix",
      "line": 172
    }
  },
  {
    "content": "Reads a JSON file.\n\n# Type\n\n```haskell\nimportJSON :: path -> any\n```",
    "isPrimop": false,
    "name": "importJSON",
    "position": {
      "column": 16,
      "file": "/home/johannes/git/nixpkgs/lib/trivial.nix",
      "line": 425
    }
  },
  {
    "content": "Reads a TOML file.\n\n# Type\n\n```haskell\nimportTOML :: path -> any\n```",
    "isPrimop": false,
    "name": "importTOML",
    "position": {
      "column": 16,
      "file": "/home/johannes/git/nixpkgs/lib/trivial.nix",
      "line": 437
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "info",
    "position": {
      "column": 10,
      "file": "/home/johannes/git/nixpkgs/lib/trivial.nix",
      "line": 559
    }
  },
  {
    "content": "Return all elements but the last.\n\nThis function throws an error if the list is empty.\n\n# Example\n\n```nix\ninit [ 1 2 3 ]\n=> [ 1 2 ]\n```\n\n# Type\n\n```haskell\ninit :: [a] -> [a]\n```",
    "isPrimop": false,
    "name": "init",
    "position": {
      "column": 10,
      "file": "/home/johannes/git/nixpkgs/lib/lists.nix",
      "line": 1025
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "innerClosePropagation",
    "position": {
      "column": 27,
      "file": "/home/johannes/git/nixpkgs/lib/deprecated.nix",
      "line": 143
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "innerModifySumArgs",
    "position": {
      "column": 24,
      "file": "/home/johannes/git/nixpkgs/lib/deprecated.nix",
      "line": 138
    }
  },
  {
    "content": "Intersects list 'e' and another list. O(nm) complexity.\n\n# Example\n\n```nix\nintersectLists [ 1 2 3 ] [ 6 3 2 ]\n=> [ 3 2 ]\n```",
    "isPrimop": false,
    "name": "intersectLists",
    "position": {
      "column": 20,
      "file": "/home/johannes/git/nixpkgs/lib/lists.nix",
      "line": 1073
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "intersperse",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 117
    }
  },
  {
    "content": "Return `true` if *e* evaluates to a set, and `false` otherwise.",
    "isPrimop": true,
    "name": "isAttrs",
    "position": null
  },
  {
    "content": "Return `true` if *e* evaluates to a bool, and `false` otherwise.",
    "isPrimop": true,
    "name": "isBool",
    "position": null
  },
  {
    "content": "Check whether the argument is a derivation. Any set with\n`{ type = \"derivation\"; }` counts as a derivation.\n\n# Example\n\n```nix\nnixpkgs = import <nixpkgs> {}\nisDerivation nixpkgs.ruby\n=> true\nisDerivation \"foobar\"\n=> false\n```\n\n# Type\n\n```haskell\nisDerivation :: Any -> Bool\n```",
    "isPrimop": false,
    "name": "isDerivation",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/attrsets.nix",
      "line": 806
    }
  },
  {
    "content": "Return `true` if *e* evaluates to a float, and `false` otherwise.",
    "isPrimop": true,
    "name": "isFloat",
    "position": null
  },
  {
    "content": "Check whether something is a function or something\nannotated with function args.",
    "isPrimop": false,
    "name": "isFunction",
    "position": {
      "column": 16,
      "file": "/home/johannes/git/nixpkgs/lib/trivial.nix",
      "line": 598
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "isInOldestRelease",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/trivial.nix",
      "line": 263
    }
  },
  {
    "content": "Return `true` if *e* evaluates to an integer, and `false` otherwise.",
    "isPrimop": true,
    "name": "isInt",
    "position": null
  },
  {
    "content": "Return `true` if *e* evaluates to a list, and `false` otherwise.",
    "isPrimop": true,
    "name": "isList",
    "position": null
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "isOption",
    "position": {
      "column": 18,
      "file": "/home/johannes/git/nixpkgs/lib/types.nix",
      "line": 70
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "isOptionType",
    "position": {
      "column": 18,
      "file": "/home/johannes/git/nixpkgs/lib/types.nix",
      "line": 70
    }
  },
  {
    "content": "Return `true` if *e* evaluates to a path, and `false` otherwise.",
    "isPrimop": true,
    "name": "isPath",
    "position": null
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "isStorePath",
    "position": {
      "column": 17,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 1306
    }
  },
  {
    "content": "Return `true` if *e* evaluates to a string, and `false` otherwise.",
    "isPrimop": true,
    "name": "isString",
    "position": null
  },
  {
    "content": "Check whether a value can be coerced to a string.\nThe value must be a string, path, or attribute set.\n\nString-like values can be used without explicit conversion in\nstring interpolations and in most functions that expect a string.",
    "isPrimop": false,
    "name": "isStringLike",
    "position": {
      "column": 18,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 1284
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "isType",
    "position": {
      "column": 12,
      "file": "/home/johannes/git/nixpkgs/lib/types.nix",
      "line": 70
    }
  },
  {
    "content": "Test whether the given name is a valid POSIX shell variable name.\n\n# Example\n\n```nix\nisValidPosixName \"foo_bar000\"\n=> true\nisValidPosixName \"0-bad.jpg\"\n=> false\n```\n\n# Type\n\n```haskell\nstring -> bool\n```",
    "isPrimop": false,
    "name": "isValidPosixName",
    "position": {
      "column": 22,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 651
    }
  },
  {
    "content": "Return the last element of a list.\n\nThis function throws an error if the list is empty.\n\n# Example\n\n```nix\nlast [ 1 2 3 ]\n=> 3\n```\n\n# Type\n\n```haskell\nlast :: [a] -> a\n```",
    "isPrimop": false,
    "name": "last",
    "position": {
      "column": 10,
      "file": "/home/johannes/git/nixpkgs/lib/lists.nix",
      "line": 1003
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "lazyDerivation",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/derivations.nix",
      "line": 53
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "lazyGenericClosure",
    "position": {
      "column": 24,
      "file": "/home/johannes/git/nixpkgs/lib/deprecated.nix",
      "line": 124
    }
  },
  {
    "content": "Return the length of the list *e*.",
    "isPrimop": true,
    "name": "length",
    "position": null
  },
  {
    "content": "Return `true` if the number *e1* is less than the number *e2*, and\n`false` otherwise. Evaluation aborts if either *e1* or *e2* does not\nevaluate to a number.",
    "isPrimop": true,
    "name": "lessThan",
    "position": null
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "listDfs",
    "position": {
      "column": 13,
      "file": "/home/johannes/git/nixpkgs/lib/lists.nix",
      "line": 681
    }
  },
  {
    "content": "Construct a set from a list specifying the names and values of each\nattribute. Each element of the list should be a set consisting of a\nstring-valued attribute `name` specifying the name of the attribute,\nand an attribute `value` specifying its value.\n\nIn case of duplicate occurrences of the same name, the first\ntakes precedence.\n\nExample:\n\n```nix\nbuiltins.listToAttrs\n  [ { name = \"foo\"; value = 123; }\n    { name = \"bar\"; value = 456; }\n    { name = \"bar\"; value = 420; }\n  ]\n```\n\nevaluates to\n\n```nix\n{ foo = 123; bar = 456; }\n```",
    "isPrimop": true,
    "name": "listToAttrs",
    "position": null
  },
  {
    "content": "For use in the `defaultText` and `example` option attributes. Causes the\ngiven string to be rendered verbatim in the documentation as Nix code. This\nis necessary for complex values, e.g. functions, or values that depend on\nother values or packages.",
    "isPrimop": false,
    "name": "literalExample",
    "position": {
      "column": 23,
      "file": "/home/johannes/git/nixpkgs/lib/options.nix",
      "line": 387
    }
  },
  {
    "content": "For use in the `defaultText` and `example` option attributes. Causes the\ngiven string to be rendered verbatim in the documentation as Nix code. This\nis necessary for complex values, e.g. functions, or values that depend on\nother values or packages.",
    "isPrimop": false,
    "name": "literalExpression",
    "position": {
      "column": 23,
      "file": "/home/johannes/git/nixpkgs/lib/options.nix",
      "line": 387
    }
  },
  {
    "content": "For use in the `defaultText` and `example` option attributes. Causes the\ngiven MD text to be inserted verbatim in the documentation, for when\na `literalExpression` would be too hard to read.",
    "isPrimop": false,
    "name": "literalMD",
    "position": {
      "column": 15,
      "file": "/home/johannes/git/nixpkgs/lib/options.nix",
      "line": 404
    }
  },
  {
    "content": "Add to or override the meta attributes of the given\nderivation.\n\n# Example\n\n```nix\naddMetaAttrs {description = \"Bla blah\";} somePkg\n```",
    "isPrimop": false,
    "name": "lowPrio",
    "position": {
      "column": 28,
      "file": "/home/johannes/git/nixpkgs/lib/meta.nix",
      "line": 21
    }
  },
  {
    "content": "Apply lowPrio to an attrset with derivations",
    "isPrimop": false,
    "name": "lowPrioSet",
    "position": {
      "column": 16,
      "file": "/home/johannes/git/nixpkgs/lib/meta.nix",
      "line": 77
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "makeBinPath",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 264
    }
  },
  {
    "content": "Same as `makeExtensible` but the name of the extending attribute is\ncustomized.",
    "isPrimop": false,
    "name": "makeExtensible",
    "position": {
      "column": 48,
      "file": "/home/johannes/git/nixpkgs/lib/fixed-points.nix",
      "line": 151
    }
  },
  {
    "content": "Same as `makeExtensible` but the name of the extending attribute is\ncustomized.",
    "isPrimop": false,
    "name": "makeExtensibleWithCustomName",
    "position": {
      "column": 34,
      "file": "/home/johannes/git/nixpkgs/lib/fixed-points.nix",
      "line": 151
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "makeLibraryPath",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 264
    }
  },
  {
    "content": "`makeOverridable` takes a function from attribute set to attribute set and\ninjects `override` attribute which can be used to override arguments of\nthe function.\n\nnix-repl> x = {a, b}: { result = a + b; }\n\nnix-repl> y = lib.makeOverridable x { a = 1; b = 2; }\n\nnix-repl> y\n{ override = «lambda»; overrideDerivation = «lambda»; result = 3; }\n\nnix-repl> y.override { a = 10; }\n{ override = «lambda»; overrideDerivation = «lambda»; result = 12; }\n\nPlease refer to \"Nixpkgs Contributors Guide\" section\n\"<pkg>.overrideDerivation\" to learn about `overrideDerivation` and caveats\nrelated to its use.",
    "isPrimop": false,
    "name": "makeOverridable",
    "position": {
      "column": 21,
      "file": "/home/johannes/git/nixpkgs/lib/customisation.nix",
      "line": 74
    }
  },
  {
    "content": "Make a set of packages with a common scope. All packages called\nwith the provided `callPackage` will be evaluated with the same\narguments. Any package in the set may depend on any other. The\n`overrideScope'` function allows subsequent modification of the package\nset in a consistent way, i.e. all packages in the set will be\ncalled with the overridden packages. The package sets may be\nhierarchical: the packages in the set are called with the scope\nprovided by `newScope` and the set provides a `newScope` attribute\nwhich can form the parent scope for later package sets.",
    "isPrimop": false,
    "name": "makeScope",
    "position": {
      "column": 15,
      "file": "/home/johannes/git/nixpkgs/lib/customisation.nix",
      "line": 279
    }
  },
  {
    "content": "backward compatibility with old uncurried form; deprecated",
    "isPrimop": false,
    "name": "makeScopeWithSplicing",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/customisation.nix",
      "line": 296
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "makeScopeWithSplicing'",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/customisation.nix",
      "line": 306
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "makeSearchPath",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 234
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "makeSearchPathOutput",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 260
    }
  },
  {
    "content": "Apply function *f* to every element of *attrset*. For example,\n\n```nix\nbuiltins.mapAttrs (name: value: value * 10) { a = 1; b = 2; }\n```\n\nevaluates to `{ a = 10; b = 20; }`.",
    "isPrimop": true,
    "name": "mapAttrs",
    "position": null
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "mapAttrs'",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/attrsets.nix",
      "line": 652
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "mapAttrsFlatten",
    "position": {
      "column": 21,
      "file": "/home/johannes/git/nixpkgs/lib/deprecated.nix",
      "line": 192
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "mapAttrsRecursive",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/attrsets.nix",
      "line": 710
    }
  },
  {
    "content": "Like `mapAttrsRecursive`, but it takes an additional predicate\nfunction that tells it whether to recurse into an attribute\nset.  If it returns false, `mapAttrsRecursiveCond` does not\nrecurse, but does apply the map function.  If it returns true, it\ndoes recurse, and does not apply the map function.\n\n# Example\n\n```nix\n# To prevent recursing into derivations (which are attribute\n# sets with the attribute \"type\" equal to \"derivation\"):\nmapAttrsRecursiveCond\n(as: !(as ? \"type\" && as.type == \"derivation\"))\n(x: ... do something ...)\nattrs\n```\n\n# Type\n\n```haskell\nmapAttrsRecursiveCond :: (AttrSet -> Bool) -> ([String] -> a -> b) -> AttrSet -> AttrSet\n```",
    "isPrimop": false,
    "name": "mapAttrsRecursiveCond",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/attrsets.nix",
      "line": 742
    }
  },
  {
    "content": "Call a function for each attribute in the given set and return\nthe result in a list.\n\n# Example\n\n```nix\nmapAttrsToList (name: value: name + value)\n{ x = \"a\"; y = \"b\"; }\n=> [ \"xa\" \"yb\" ]\n```\n\n# Type\n\n```haskell\nmapAttrsToList :: (String -> a -> b) -> AttrSet -> [b]\n```",
    "isPrimop": false,
    "name": "mapAttrsToList",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/attrsets.nix",
      "line": 678
    }
  },
  {
    "content": "Apply a function to each derivation and only to derivations in an attrset.",
    "isPrimop": false,
    "name": "mapDerivationAttrset",
    "position": {
      "column": 26,
      "file": "/home/johannes/git/nixpkgs/lib/meta.nix",
      "line": 61
    }
  },
  {
    "content": "Apply function if the supplied argument is non-null.\n\n# Example\n\n```nix\nmapNullable (x: x+1) null\n=> null\nmapNullable (x: x+1) 22\n=> 23\n```",
    "isPrimop": false,
    "name": "mapNullable",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/trivial.nix",
      "line": 214
    }
  },
  {
    "content": "Returns true if the pattern is contained in the set. False otherwise.\n\n# Example\n\n```nix\nmatchAttrs { cpu = {}; } { cpu = { bits = 64; }; }\n=> true\n```\n\n# Type\n\n```haskell\nmatchAttrs :: AttrSet -> AttrSet -> Bool\n```",
    "isPrimop": false,
    "name": "matchAttrs",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/attrsets.nix",
      "line": 1092
    }
  },
  {
    "content": "Return maximum of two numbers.",
    "isPrimop": false,
    "name": "max",
    "position": {
      "column": 9,
      "file": "/home/johannes/git/nixpkgs/lib/trivial.nix",
      "line": 341
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "maybeAttr",
    "position": {
      "column": 15,
      "file": "/home/johannes/git/nixpkgs/lib/deprecated.nix",
      "line": 42
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "maybeAttrNullable",
    "position": {
      "column": 15,
      "file": "/home/johannes/git/nixpkgs/lib/deprecated.nix",
      "line": 42
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "maybeEnv",
    "position": {
      "column": 14,
      "file": "/home/johannes/git/nixpkgs/lib/deprecated.nix",
      "line": 14
    }
  },
  {
    "content": "The identity function\nFor when you need a function that does “nothing”.\n\n# Type\n\n```haskell\nid :: a -> a\n```",
    "isPrimop": false,
    "name": "mdDoc",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/trivial.nix",
      "line": 19
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "mergeAttrByFunc",
    "position": {
      "column": 21,
      "file": "/home/johannes/git/nixpkgs/lib/deprecated.nix",
      "line": 251
    }
  },
  {
    "content": "Merge two attribute sets shallowly, right side trumps left\n\nmergeAttrs :: attrs -> attrs -> attrs\n\n# Example\n\n```nix\nmergeAttrs { a = 1; b = 2; } { b = 3; c = 4; }\n=> { a = 1; b = 3; c = 4; }\n```",
    "isPrimop": false,
    "name": "mergeAttrs",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/trivial.nix",
      "line": 178
    }
  },
  {
    "content": "“left fold”, like `foldr`, but from the left:\n`foldl op nul [x_1 x_2 ... x_n] == op (... (op (op nul x_1) x_2) ... x_n)`.\n\n# Example\n\n```nix\nlconcat = foldl (a: b: a + b) \"z\"\nlconcat [ \"a\" \"b\" \"c\" ]\n=> \"zabc\"\n# different types\nlstrange = foldl (str: int: str + toString (int + 1)) \"a\"\nlstrange [ 1 2 3 4 ]\n=> \"a2345\"\n```\n\n# Type\n\n```haskell\nfoldl :: (b -> a -> b) -> b -> [a] -> b\n```",
    "isPrimop": false,
    "name": "mergeAttrsByFuncDefaults",
    "position": {
      "column": 20,
      "file": "/home/johannes/git/nixpkgs/lib/lists.nix",
      "line": 115
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "mergeAttrsByFuncDefaultsClean",
    "position": {
      "column": 35,
      "file": "/home/johannes/git/nixpkgs/lib/deprecated.nix",
      "line": 272
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "mergeAttrsConcatenateValues",
    "position": {
      "column": 27,
      "file": "/home/johannes/git/nixpkgs/lib/deprecated.nix",
      "line": 208
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "mergeAttrsNoOverride",
    "position": {
      "column": 26,
      "file": "/home/johannes/git/nixpkgs/lib/deprecated.nix",
      "line": 225
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "mergeAttrsWithFunc",
    "position": {
      "column": 24,
      "file": "/home/johannes/git/nixpkgs/lib/deprecated.nix",
      "line": 208
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "mergeDefaultOption",
    "position": {
      "column": 24,
      "file": "/home/johannes/git/nixpkgs/lib/options.nix",
      "line": 234
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "mergeDefinitions",
    "position": {
      "column": 22,
      "file": "/home/johannes/git/nixpkgs/lib/modules.nix",
      "line": 822
    }
  },
  {
    "content": "\"Merge\" option definitions by checking that they all have the same value.",
    "isPrimop": false,
    "name": "mergeEqualOption",
    "position": {
      "column": 22,
      "file": "/home/johannes/git/nixpkgs/lib/options.nix",
      "line": 256
    }
  },
  {
    "content": "Merge a list of modules.  This will recurse over the option\ndeclarations in all modules, combining them into a single set.\nAt the same time, for each option declaration, it will merge the\ncorresponding option definitions in all machines, returning them\nin the ‘value’ attribute of each option.\n\nThis returns a set like\n{\n# A recursive set of options along with their final values\nmatchedOptions = {\nfoo = { _type = \"option\"; value = \"option value of foo\"; ... };\nbar.baz = { _type = \"option\"; value = \"option value of bar.baz\"; ... };\n...\n};\n# A list of definitions that weren't matched by any option\nunmatchedDefns = [\n{ file = \"file.nix\"; prefix = [ \"qux\" ]; value = \"qux\"; }\n...\n];\n}",
    "isPrimop": false,
    "name": "mergeModules",
    "position": {
      "column": 18,
      "file": "/home/johannes/git/nixpkgs/lib/modules.nix",
      "line": 543
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "mergeModules'",
    "position": {
      "column": 19,
      "file": "/home/johannes/git/nixpkgs/lib/modules.nix",
      "line": 547
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "mergeOneOption",
    "position": {
      "column": 36,
      "file": "/home/johannes/git/nixpkgs/lib/options.nix",
      "line": 247
    }
  },
  {
    "content": "Merge multiple option declarations into a single declaration.  In\ngeneral, there should be only one declaration of each option.\nThe exception is the ‘options’ attribute, which specifies\nsub-options.  These can be specified multiple times to allow one\nmodule to add sub-options to an option declared somewhere else\n(e.g. multiple modules define sub-options for ‘fileSystems’).\n\n'loc' is the list of attribute names where the option is located.\n\n'opts' is a list of modules.  Each module has an options attribute which\ncorrespond to the definition of 'loc' in 'opt.file'.",
    "isPrimop": false,
    "name": "mergeOptionDecls",
    "position": {
      "column": 4,
      "file": "/home/johannes/git/nixpkgs/lib/modules.nix",
      "line": 748
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "mergeUniqueOption",
    "position": {
      "column": 23,
      "file": "/home/johannes/git/nixpkgs/lib/options.nix",
      "line": 247
    }
  },
  {
    "content": "Create a -D<condition>={true,false} string that can be passed to typical\nMeson invocations.\n\n# Example\n\n```nix\nmesonBool \"hardened\" true\n=> \"-Dhardened=true\"\nmesonBool \"static\" false\n=> \"-Dstatic=false\"\n```\n\n# Type\n\n```haskell\nmesonBool :: string -> bool -> string\n\n@param condition The condition to be made true or false\n@param flag The controlling flag of the condition\n```",
    "isPrimop": false,
    "name": "mesonBool",
    "position": {
      "column": 15,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 1099
    }
  },
  {
    "content": "Create a -D<feature>={enabled,disabled} string that can be passed to\ntypical Meson invocations.\n\n# Example\n\n```nix\nmesonEnable \"docs\" true\n=> \"-Ddocs=enabled\"\nmesonEnable \"savage\" false\n=> \"-Dsavage=disabled\"\n```\n\n# Type\n\n```haskell\nmesonEnable :: string -> bool -> string\n\n@param feature The feature to be enabled or disabled\n@param flag The controlling flag\n```",
    "isPrimop": false,
    "name": "mesonEnable",
    "position": {
      "column": 17,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 1126
    }
  },
  {
    "content": "Create a -D<feature>=<value> string that can be passed to typical Meson\ninvocations.\n\n# Example\n\n```nix\nmesonOption \"engine\" \"opengl\"\n=> \"-Dengine=opengl\"\n```\n\n# Type\n\n```haskell\nmesonOption :: string -> string -> string\n\n@param feature The feature to be set\n@param value The desired value\n```",
    "isPrimop": false,
    "name": "mesonOption",
    "position": {
      "column": 17,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 1072
    }
  },
  {
    "content": "Return minimum of two numbers.",
    "isPrimop": false,
    "name": "min",
    "position": {
      "column": 9,
      "file": "/home/johannes/git/nixpkgs/lib/trivial.nix",
      "line": 336
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "mkAfter",
    "position": {
      "column": 23,
      "file": "/home/johannes/git/nixpkgs/lib/modules.nix",
      "line": 1042
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "mkAliasAndWrapDefinitions",
    "position": {
      "column": 31,
      "file": "/home/johannes/git/nixpkgs/lib/modules.nix",
      "line": 1071
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "mkAliasDefinitions",
    "position": {
      "column": 37,
      "file": "/home/johannes/git/nixpkgs/lib/modules.nix",
      "line": 1071
    }
  },
  {
    "content": "Like ‘mkRenamedOptionModule’, but doesn't show a warning.",
    "isPrimop": false,
    "name": "mkAliasOptionModule",
    "position": {
      "column": 25,
      "file": "/home/johannes/git/nixpkgs/lib/modules.nix",
      "line": 1250
    }
  },
  {
    "content": "Like ‘mkRenamedOptionModule’, but doesn't show a warning.",
    "isPrimop": false,
    "name": "mkAliasOptionModuleMD",
    "position": {
      "column": 25,
      "file": "/home/johannes/git/nixpkgs/lib/modules.nix",
      "line": 1250
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "mkAssert",
    "position": {
      "column": 14,
      "file": "/home/johannes/git/nixpkgs/lib/modules.nix",
      "line": 1016
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "mkBefore",
    "position": {
      "column": 23,
      "file": "/home/johannes/git/nixpkgs/lib/modules.nix",
      "line": 1042
    }
  },
  {
    "content": "Single \"from\" version of mkMergedOptionModule.\nReturn a module that causes a warning to be shown if the \"from\" option is\ndefined; the defined value can be used in the \"mergeFn\" to set the \"to\"\nvalue.\nThis function can be used to change an option into another that has a\ndifferent type.\n\n\"mergeFn\" takes the module \"config\" as a parameter and must return a value of\n\"to\" option type.\n\nmkChangedOptionModule [ \"a\" \"b\" \"c\" ] [ \"x\" \"y\" \"z\" ]\n(config:\nlet value = getAttrFromPath [ \"a\" \"b\" \"c\" ] config;\nin\nif   value > 100 then \"high\"\nelse \"normal\")\n\n- options.a.b.c is a removed int option\n- options.x.y.z is a new str option that supersedes a.b.c\n\nThis show a warning if a.b.c is set, and set the value of x.y.z to the\nresult of the change function",
    "isPrimop": false,
    "name": "mkChangedOptionModule",
    "position": {
      "column": 27,
      "file": "/home/johannes/git/nixpkgs/lib/modules.nix",
      "line": 1244
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "mkDefault",
    "position": {
      "column": 26,
      "file": "/home/johannes/git/nixpkgs/lib/modules.nix",
      "line": 1026
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "mkDerivedConfig",
    "position": {
      "column": 21,
      "file": "/home/johannes/git/nixpkgs/lib/modules.nix",
      "line": 1280
    }
  },
  {
    "content": "Creates an Option attribute set for a boolean value option i.e an\noption to be toggled on or off:\n\n# Example\n\n```nix\nmkEnableOption \"foo\"\n=> { _type = \"option\"; default = false; description = \"Whether to enable foo.\"; example = true; type = { ... }; }\n```",
    "isPrimop": false,
    "name": "mkEnableOption",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/options.nix",
      "line": 116
    }
  },
  {
    "content": "The identity function\nFor when you need a function that does “nothing”.\n\n# Type\n\n```haskell\nid :: a -> a\n```",
    "isPrimop": false,
    "name": "mkFixStrictness",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/trivial.nix",
      "line": 19
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "mkForce",
    "position": {
      "column": 26,
      "file": "/home/johannes/git/nixpkgs/lib/modules.nix",
      "line": 1026
    }
  },
  {
    "content": "Properties.",
    "isPrimop": false,
    "name": "mkIf",
    "position": {
      "column": 10,
      "file": "/home/johannes/git/nixpkgs/lib/modules.nix",
      "line": 1011
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "mkImageMediaOverride",
    "position": {
      "column": 26,
      "file": "/home/johannes/git/nixpkgs/lib/modules.nix",
      "line": 1026
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "mkMerge",
    "position": {
      "column": 13,
      "file": "/home/johannes/git/nixpkgs/lib/modules.nix",
      "line": 1021
    }
  },
  {
    "content": "Return a module that causes a warning to be shown if any of the \"from\"\noption is defined; the defined values can be used in the \"mergeFn\" to set\nthe \"to\" value.\nThis function can be used to merge multiple options into one that has a\ndifferent type.\n\n\"mergeFn\" takes the module \"config\" as a parameter and must return a value\nof \"to\" option type.\n\nmkMergedOptionModule\n[ [ \"a\" \"b\" \"c\" ]\n[ \"d\" \"e\" \"f\" ] ]\n[ \"x\" \"y\" \"z\" ]\n(config:\nlet value = p: getAttrFromPath p config;\nin\nif      (value [ \"a\" \"b\" \"c\" ]) == true then \"foo\"\nelse if (value [ \"d\" \"e\" \"f\" ]) == true then \"bar\"\nelse \"baz\")\n\n- options.a.b.c is a removed boolean option\n- options.d.e.f is a removed boolean option\n- options.x.y.z is a new str option that combines a.b.c and d.e.f\nfunctionality\n\nThis show a warning if any a.b.c or d.e.f is set, and set the value of\nx.y.z to the result of the merge function",
    "isPrimop": false,
    "name": "mkMergedOptionModule",
    "position": {
      "column": 26,
      "file": "/home/johannes/git/nixpkgs/lib/modules.nix",
      "line": 1196
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "mkOption",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/options.nix",
      "line": 79
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "mkOptionDefault",
    "position": {
      "column": 26,
      "file": "/home/johannes/git/nixpkgs/lib/modules.nix",
      "line": 1026
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "mkOptionType",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/types.nix",
      "line": 109
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "mkOrder",
    "position": {
      "column": 13,
      "file": "/home/johannes/git/nixpkgs/lib/modules.nix",
      "line": 1042
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "mkOverride",
    "position": {
      "column": 16,
      "file": "/home/johannes/git/nixpkgs/lib/modules.nix",
      "line": 1026
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "mkPackageOption",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/options.nix",
      "line": 174
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "mkPackageOptionMD",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/options.nix",
      "line": 174
    }
  },
  {
    "content": "Return a module that causes a warning to be shown if the\nspecified option is defined. For example,\n\nmkRemovedOptionModule [ \"boot\" \"loader\" \"grub\" \"bootDevice\" ] \"<replacement instructions>\"\n\ncauses a assertion if the user defines boot.loader.grub.bootDevice.\n\nreplacementInstructions is a string that provides instructions on\nhow to achieve the same functionality without the removed option,\nor alternatively a reasoning why the functionality is not needed.\nreplacementInstructions SHOULD be provided!",
    "isPrimop": false,
    "name": "mkRemovedOptionModule",
    "position": {
      "column": 27,
      "file": "/home/johannes/git/nixpkgs/lib/modules.nix",
      "line": 1106
    }
  },
  {
    "content": "Return a module that causes a warning to be shown if the\nspecified \"from\" option is defined; the defined value is however\nforwarded to the \"to\" option. This can be used to rename options\nwhile providing backward compatibility. For example,\n\nmkRenamedOptionModule [ \"boot\" \"copyKernels\" ] [ \"boot\" \"loader\" \"grub\" \"copyKernels\" ]\n\nforwards any definitions of boot.copyKernels to\nboot.loader.grub.copyKernels while printing a warning.\n\nThis also copies over the priority from the aliased option to the\nnon-aliased option.",
    "isPrimop": false,
    "name": "mkRenamedOptionModule",
    "position": {
      "column": 27,
      "file": "/home/johannes/git/nixpkgs/lib/modules.nix",
      "line": 1136
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "mkRenamedOptionModuleWith",
    "position": {
      "column": 31,
      "file": "/home/johannes/git/nixpkgs/lib/modules.nix",
      "line": 1143
    }
  },
  {
    "content": "This option accepts anything, but it does not produce any result.\n\nThis is useful for sharing a module across different module sets\nwithout having to implement similar features as long as the\nvalues of the options are not accessed.",
    "isPrimop": false,
    "name": "mkSinkUndeclaredOptions",
    "position": {
      "column": 29,
      "file": "/home/johannes/git/nixpkgs/lib/options.nix",
      "line": 221
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "mkVMOverride",
    "position": {
      "column": 26,
      "file": "/home/johannes/git/nixpkgs/lib/modules.nix",
      "line": 1026
    }
  },
  {
    "content": "Integer modulus\n\n# Example\n\n```nix\nmod 11 10\n=> 1\nmod 1 10\n=> 1\n```",
    "isPrimop": false,
    "name": "mod",
    "position": {
      "column": 9,
      "file": "/home/johannes/git/nixpkgs/lib/trivial.nix",
      "line": 355
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "modifySumArgs",
    "position": {
      "column": 19,
      "file": "/home/johannes/git/nixpkgs/lib/deprecated.nix",
      "line": 140
    }
  },
  {
    "content": "Test if two lists have no common element.\nIt should be slightly more efficient than (intersectLists a b == [])",
    "isPrimop": false,
    "name": "mutuallyExclusive",
    "position": {
      "column": 23,
      "file": "/home/johannes/git/nixpkgs/lib/lists.nix",
      "line": 1091
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "nameFromURL",
    "position": {
      "column": 17,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 1045
    }
  },
  {
    "content": "Utility function that creates a `{name, value}` pair as expected by `builtins.listToAttrs`.\n\n# Example\n\n```nix\nnameValuePair \"some\" 6\n=> { name = \"some\"; value = 6; }\n```\n\n# Type\n\n```haskell\nnameValuePair :: String -> Any -> { name :: String; value :: Any; }\n```",
    "isPrimop": false,
    "name": "nameValuePair",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/attrsets.nix",
      "line": 603
    }
  },
  {
    "content": "Sort list using \"Natural sorting\".\nNumeric portions of strings are sorted in numeric order.\n\n# Example\n\n```nix\nnaturalSort [\"disk11\" \"disk8\" \"disk100\" \"disk9\"]\n=> [\"disk8\" \"disk9\" \"disk11\" \"disk100\"]\nnaturalSort [\"10.46.133.149\" \"10.5.16.62\" \"10.54.16.25\"]\n=> [\"10.5.16.62\" \"10.46.133.149\" \"10.54.16.25\"]\nnaturalSort [\"v0.2\" \"v0.15\" \"v0.0.9\"]\n=> [ \"v0.0.9\" \"v0.2\" \"v0.15\" ]\n```",
    "isPrimop": false,
    "name": "naturalSort",
    "position": {
      "column": 17,
      "file": "/home/johannes/git/nixpkgs/lib/lists.nix",
      "line": 814
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "nixType",
    "position": {
      "column": 13,
      "file": "/home/johannes/git/nixpkgs/lib/deprecated.nix",
      "line": 282
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "noDepEntry",
    "position": {
      "column": 16,
      "file": "/home/johannes/git/nixpkgs/lib/strings-with-deps.nix",
      "line": 80
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "nvs",
    "position": {
      "column": 9,
      "file": "/home/johannes/git/nixpkgs/lib/deprecated.nix",
      "line": 195
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "optionAttrSetToDocList",
    "position": {
      "column": 32,
      "file": "/home/johannes/git/nixpkgs/lib/options.nix",
      "line": 308
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "optionAttrSetToDocList'",
    "position": {
      "column": 29,
      "file": "/home/johannes/git/nixpkgs/lib/options.nix",
      "line": 308
    }
  },
  {
    "content": "Return a singleton list or an empty list, depending on a boolean\nvalue.  Useful when building lists with optional elements\n(e.g. `++ optional (system == \"i686-linux\") firefox`).\n\n# Example\n\n```nix\noptional true \"foo\"\n=> [ \"foo\" ]\noptional false \"foo\"\n=> [ ]\n```\n\n# Type\n\n```haskell\noptional :: bool -> a -> [a]\n```",
    "isPrimop": false,
    "name": "optional",
    "position": {
      "column": 14,
      "file": "/home/johannes/git/nixpkgs/lib/lists.nix",
      "line": 442
    }
  },
  {
    "content": "If `cond` is true, return the attribute set `as`,\notherwise an empty attribute set.\n\n# Example\n\n```nix\noptionalAttrs (true) { my = \"set\"; }\n=> { my = \"set\"; }\noptionalAttrs (false) { my = \"set\"; }\n=> { }\n```\n\n# Type\n\n```haskell\noptionalAttrs :: Bool -> AttrSet -> AttrSet\n```",
    "isPrimop": false,
    "name": "optionalAttrs",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/attrsets.nix",
      "line": 854
    }
  },
  {
    "content": "Depending on the boolean `cond', return either the given string\nor the empty string. Useful to concatenate against a bigger string.\n\n# Example\n\n```nix\noptionalString true \"some-string\"\n=> \"some-string\"\noptionalString false \"some-string\"\n=> \"\"\n```\n\n# Type\n\n```haskell\noptionalString :: bool -> string -> string\n```",
    "isPrimop": false,
    "name": "optionalString",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 347
    }
  },
  {
    "content": "Return a list or an empty list, depending on a boolean value.\n\n# Example\n\n```nix\noptionals true [ 2 3 ]\n=> [ 2 3 ]\noptionals false [ 2 3 ]\n=> [ ]\n```\n\n# Type\n\n```haskell\noptionals :: bool -> [a] -> [a]\n```",
    "isPrimop": false,
    "name": "optionals",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/lists.nix",
      "line": 464
    }
  },
  {
    "content": "boolean “or”",
    "isPrimop": false,
    "name": "or",
    "position": {
      "column": 8,
      "file": "/home/johannes/git/nixpkgs/lib/trivial.nix",
      "line": 116
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "overrideDerivation",
    "position": {
      "column": 24,
      "file": "/home/johannes/git/nixpkgs/lib/customisation.nix",
      "line": 40
    }
  },
  {
    "content": "Override only the attributes that are already present in the old set\nuseful for deep-overriding.\n\n# Example\n\n```nix\noverrideExisting {} { a = 1; }\n=> {}\noverrideExisting { b = 2; } { a = 1; }\n=> { b = 2; }\noverrideExisting { a = 3; b = 2; } { a = 1; }\n=> { a = 1; b = 2; }\n```\n\n# Type\n\n```haskell\noverrideExisting :: AttrSet -> AttrSet -> AttrSet\n```",
    "isPrimop": false,
    "name": "overrideExisting",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/attrsets.nix",
      "line": 1127
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "packEntry",
    "position": {
      "column": 15,
      "file": "/home/johannes/git/nixpkgs/lib/strings-with-deps.nix",
      "line": 82
    }
  },
  {
    "content": "Given a predicate function *pred*, this function returns an\nattrset containing a list named `right`, containing the elements\nin *list* for which *pred* returned `true`, and a list named\n`wrong`, containing the elements for which it returned\n`false`. For example,\n\n```nix\nbuiltins.partition (x: x > 10) [1 23 9 3 42]\n```\n\nevaluates to\n\n```nix\n{ right = [ 23 42 ]; wrong = [ 1 9 3 ]; }\n```",
    "isPrimop": true,
    "name": "partition",
    "position": null
  },
  {
    "content": "Return `true` if the path *path* exists at evaluation time, and\n`false` otherwise.",
    "isPrimop": true,
    "name": "pathExists",
    "position": null
  },
  {
    "content": "Return `true` if string *s* has a non-empty context. The\ncontext can be obtained with\n[`getContext`](#builtins-getContext).",
    "isPrimop": true,
    "name": "pathHasContext",
    "position": null
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "pathIsDirectory",
    "position": {
      "column": 21,
      "file": "/home/johannes/git/nixpkgs/lib/filesystem.nix",
      "line": 77
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "pathIsGitRepo",
    "position": {
      "column": 19,
      "file": "/home/johannes/git/nixpkgs/lib/sources.nix",
      "line": 173
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "pathIsRegularFile",
    "position": {
      "column": 23,
      "file": "/home/johannes/git/nixpkgs/lib/filesystem.nix",
      "line": 102
    }
  },
  {
    "content": "Determine the directory entry type of a filesystem node, being\none of \"directory\", \"regular\", \"symlink\", or \"unknown\".",
    "isPrimop": true,
    "name": "pathType",
    "position": null
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "pipe",
    "position": {
      "column": 10,
      "file": "/home/johannes/git/nixpkgs/lib/trivial.nix",
      "line": 84
    }
  },
  {
    "content": "Given a config set, expand mkMerge properties, and push down the\nother properties into the children.  The result is a list of\nconfig sets that do not have properties at top-level.  For\nexample,\n\nmkMerge [ { boot = set1; } (mkIf cond { boot = set2; services = set3; }) ]\n\nis transformed into\n\n[ { boot = set1; } { boot = mkIf cond set2; services = mkIf cond set3; } ].\n\nThis transform is the critical step that allows mkIf conditions\nto refer to the full configuration without creating an infinite\nrecursion.",
    "isPrimop": false,
    "name": "pushDownProperties",
    "position": {
      "column": 24,
      "file": "/home/johannes/git/nixpkgs/lib/modules.nix",
      "line": 879
    }
  },
  {
    "content": "Return a list of integers from `first` up to and including `last`.\n\n# Example\n\n```nix\nrange 2 4\n=> [ 2 3 4 ]\nrange 3 2\n=> [ ]\n```\n\n# Type\n\n```haskell\nrange :: int -> int -> [int]\n```",
    "isPrimop": false,
    "name": "range",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/lists.nix",
      "line": 505
    }
  },
  {
    "content": "Return the contents of the file *path* as a string.",
    "isPrimop": true,
    "name": "readFile",
    "position": null
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "readPathsFromFile",
    "position": {
      "column": 6,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 1450
    }
  },
  {
    "content": "Make various Nix tools consider the contents of the resulting\nattribute set when looking for what to build, find, etc.\n\nThis function only affects a single attribute set; it does not\napply itself recursively for nested attribute sets.\n\n# Example\n\n```nix\n{ pkgs ? import <nixpkgs> {} }:\n{\nmyTools = pkgs.lib.recurseIntoAttrs {\ninherit (pkgs) hello figlet;\n};\n}\n```\n\n# Type\n\n```haskell\nrecurseIntoAttrs :: AttrSet -> AttrSet\n```",
    "isPrimop": false,
    "name": "recurseIntoAttrs",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/attrsets.nix",
      "line": 1302
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "recursiveUpdate",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/attrsets.nix",
      "line": 1068
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "recursiveUpdateUntil",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/attrsets.nix",
      "line": 1021
    }
  },
  {
    "content": "Remove elements equal to 'e' from a list.  Useful for buildInputs.\n\n# Example\n\n```nix\nremove 3 [ 1 3 4 3 ]\n=> [ 1 4 ]\n```\n\n# Type\n\n```haskell\nremove :: a -> [a] -> [a]\n```",
    "isPrimop": false,
    "name": "remove",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/lists.nix",
      "line": 228
    }
  },
  {
    "content": "Return a string without the specified prefix, if the prefix matches.\n\n# Example\n\n```nix\nremovePrefix \"foo.\" \"foo.bar.baz\"\n=> \"bar.baz\"\nremovePrefix \"xxx\" \"foo.bar.baz\"\n=> \"foo.bar.baz\"\n```\n\n# Type\n\n```haskell\nstring -> string -> string\n```",
    "isPrimop": false,
    "name": "removePrefix",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 898
    }
  },
  {
    "content": "Return a string without the specified suffix, if the suffix matches.\n\n# Example\n\n```nix\nremoveSuffix \"front\" \"homefront\"\n=> \"home\"\nremoveSuffix \"xxx\" \"homefront\"\n=> \"homefront\"\n```\n\n# Type\n\n```haskell\nstring -> string -> string\n```",
    "isPrimop": false,
    "name": "removeSuffix",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 939
    }
  },
  {
    "content": "Given string *s*, replace every occurrence of the strings in *from*\nwith the corresponding string in *to*.\n\nThe argument *to* is lazy, that is, it is only evaluated when its corresponding pattern in *from* is matched in the string *s*\n\nExample:\n\n```nix\nbuiltins.replaceStrings [\"oo\" \"a\"] [\"a\" \"i\"] \"foobar\"\n```\n\nevaluates to `\"fabir\"`.",
    "isPrimop": true,
    "name": "replaceChars",
    "position": null
  },
  {
    "content": "Given string *s*, replace every occurrence of the strings in *from*\nwith the corresponding string in *to*.\n\nThe argument *to* is lazy, that is, it is only evaluated when its corresponding pattern in *from* is matched in the string *s*\n\nExample:\n\n```nix\nbuiltins.replaceStrings [\"oo\" \"a\"] [\"a\" \"i\"] \"foobar\"\n```\n\nevaluates to `\"fabir\"`.",
    "isPrimop": true,
    "name": "replaceStrings",
    "position": null
  },
  {
    "content": "Return a list with `n` copies of an element.\n\n# Example\n\n```nix\nreplicate 3 \"a\"\n=> [ \"a\" \"a\" \"a\" ]\nreplicate 2 true\n=> [ true true ]\n```\n\n# Type\n\n```haskell\nreplicate :: int -> a -> [a]\n```",
    "isPrimop": false,
    "name": "replicate",
    "position": {
      "column": 15,
      "file": "/home/johannes/git/nixpkgs/lib/lists.nix",
      "line": 531
    }
  },
  {
    "content": "Reverse the order of the elements of a list.\n\n# Example\n\n```nix\nreverseList [ \"b\" \"o\" \"j\" ]\n=> [ \"j\" \"o\" \"b\" ]\n```\n\n# Type\n\n```haskell\nreverseList :: [a] -> [a]\n```",
    "isPrimop": false,
    "name": "reverseList",
    "position": {
      "column": 17,
      "file": "/home/johannes/git/nixpkgs/lib/lists.nix",
      "line": 656
    }
  },
  {
    "content": "Evaluates a set of tests.\n\nA test is an attribute set `{expr, expected}`,\ndenoting an expression and its expected result.\n\nThe result is a `list` of __failed tests__, each represented as\n`{name, expected, result}`,\n\n- expected\n- What was passed as `expected`\n- result\n- The actual `result` of the test\n\nUsed for regression testing of the functions in lib; see\ntests.nix for more examples.\n\nImportant: Only attributes that start with `test` are executed.\n\n- If you want to run only a subset of the tests add the attribute `tests = [\"testName\"];`\n\n# Example\n\n```nix\nrunTests {\ntestAndOk = {\nexpr = lib.and true false;\nexpected = false;\n};\ntestAndFail = {\nexpr = lib.and true false;\nexpected = true;\n};\n}\n->\n[\n{\nname = \"testAndFail\";\nexpected = true;\nresult = false;\n}\n]\n```\n\n# Type\n\n```haskell\nrunTests :: {\ntests = [ String ];\n${testName} :: {\nexpr :: a;\nexpected :: a;\n};\n}\n->\n[\n{\nname :: String;\nexpected :: a;\nresult :: a;\n}\n]\n```",
    "isPrimop": false,
    "name": "runTests",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/debug.nix",
      "line": 289
    }
  },
  {
    "content": "This function recursively removes all derivation attributes from\n`x` except for the `name` attribute.\n\nThis is to make the generation of `options.xml` much more\nefficient: the XML representation of derivations is very large\n(on the order of megabytes) and is not actually used by the\nmanual generator.\n\nThis function was made obsolete by renderOptionValue and is kept for\ncompatibility with out-of-tree code.",
    "isPrimop": false,
    "name": "scrubOptionValue",
    "position": {
      "column": 22,
      "file": "/home/johannes/git/nixpkgs/lib/options.nix",
      "line": 361
    }
  },
  {
    "content": "Evaluate *e1*, then evaluate and return *e2*. This ensures that a\ncomputation is strict in the value of *e1*.",
    "isPrimop": true,
    "name": "seq",
    "position": null
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "setAttr",
    "position": {
      "column": 13,
      "file": "/home/johannes/git/nixpkgs/lib/deprecated.nix",
      "line": 197
    }
  },
  {
    "content": "Create a new attribute set with `value` set at the nested attribute location specified in `attrPath`.\n\n# Example\n\n```nix\nsetAttrByPath [\"a\" \"b\"] 3\n=> { a = { b = 3; }; }\n```\n\n# Type\n\n```haskell\nsetAttrByPath :: [String] -> Any -> AttrSet\n```",
    "isPrimop": false,
    "name": "setAttrByPath",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/attrsets.nix",
      "line": 100
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "setAttrMerge",
    "position": {
      "column": 18,
      "file": "/home/johannes/git/nixpkgs/lib/deprecated.nix",
      "line": 202
    }
  },
  {
    "content": "Wrap a module with a default location for reporting errors.",
    "isPrimop": false,
    "name": "setDefaultModuleLocation",
    "position": {
      "column": 30,
      "file": "/home/johannes/git/nixpkgs/lib/modules.nix",
      "line": 451
    }
  },
  {
    "content": "Add metadata about expected function arguments to a function.\nThe metadata should match the format given by\nbuiltins.functionArgs, i.e. a set from expected argument to a bool\nrepresenting whether that argument has a default or not.\nsetFunctionArgs : (a → b) → Map String Bool → (a → b)\n\nThis function is necessary because you can't dynamically create a\nfunction of the { a, b ? foo, ... }: format, but some facilities\nlike callPackage expect to be able to query expected arguments.",
    "isPrimop": false,
    "name": "setFunctionArgs",
    "position": {
      "column": 21,
      "file": "/home/johannes/git/nixpkgs/lib/trivial.nix",
      "line": 576
    }
  },
  {
    "content": "Change the symbolic name of a package for presentation purposes\n(i.e., so that nix-env users can tell them apart).",
    "isPrimop": false,
    "name": "setName",
    "position": {
      "column": 13,
      "file": "/home/johannes/git/nixpkgs/lib/meta.nix",
      "line": 35
    }
  },
  {
    "content": "Set the nix-env priority of the package.",
    "isPrimop": false,
    "name": "setPrio",
    "position": {
      "column": 13,
      "file": "/home/johannes/git/nixpkgs/lib/meta.nix",
      "line": 66
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "setType",
    "position": {
      "column": 13,
      "file": "/home/johannes/git/nixpkgs/lib/types.nix",
      "line": 72
    }
  },
  {
    "content": "Turns a list of strings into a human-readable description of those\nstrings represented as an attribute path. The result of this function is\nnot intended to be machine-readable.\nCreate a new attribute set with `value` set at the nested attribute location specified in `attrPath`.\n\n# Example\n\n```nix\nshowAttrPath [ \"foo\" \"10\" \"bar\" ]\n=> \"foo.\\\"10\\\".bar\"\nshowAttrPath []\n=> \"<root attribute path>\"\n```\n\n# Type\n\n```haskell\nshowAttrPath :: [String] -> String\n```",
    "isPrimop": false,
    "name": "showAttrPath",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/attrsets.nix",
      "line": 1156
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "showFiles",
    "position": {
      "column": 15,
      "file": "/home/johannes/git/nixpkgs/lib/options.nix",
      "line": 440
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "showOption",
    "position": {
      "column": 16,
      "file": "/home/johannes/git/nixpkgs/lib/options.nix",
      "line": 426
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "showOptionWithDefLocs",
    "position": {
      "column": 27,
      "file": "/home/johannes/git/nixpkgs/lib/options.nix",
      "line": 461
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "showWarnings",
    "position": {
      "column": 18,
      "file": "/home/johannes/git/nixpkgs/lib/trivial.nix",
      "line": 561
    }
  },
  {
    "content": "Create a list consisting of a single element.  `singleton x` is\nsometimes more convenient with respect to indentation than `[x]`\nwhen x spans multiple lines.\n\n# Example\n\n```nix\nsingleton \"foo\"\n=> [ \"foo\" ]\n```\n\n# Type\n\n```haskell\nsingleton :: a -> [a]\n```",
    "isPrimop": false,
    "name": "singleton",
    "position": {
      "column": 15,
      "file": "/home/johannes/git/nixpkgs/lib/lists.nix",
      "line": 31
    }
  },
  {
    "content": "Return *list* in sorted order. It repeatedly calls the function\n*comparator* with two elements. The comparator should return `true`\nif the first element is less than the second, and `false` otherwise.\nFor example,\n\n```nix\nbuiltins.sort builtins.lessThan [ 483 249 526 147 42 77 ]\n```\n\nproduces the list `[ 42 77 147 249 483 526 ]`.\n\nThis is a stable sort: it preserves the relative order of elements\ndeemed equal by the comparator.",
    "isPrimop": true,
    "name": "sort",
    "position": null
  },
  {
    "content": "Sort a list of properties.  The sort priority of a property is\ndefaultOrderPriority by default, but can be overridden by wrapping the property\nusing mkOrder.",
    "isPrimop": false,
    "name": "sortProperties",
    "position": {
      "column": 20,
      "file": "/home/johannes/git/nixpkgs/lib/modules.nix",
      "line": 951
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "sourceByRegex",
    "position": {
      "column": 19,
      "file": "/home/johannes/git/nixpkgs/lib/sources.nix",
      "line": 134
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "sourceFilesBySuffices",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/sources.nix",
      "line": 165
    }
  },
  {
    "content": "Split type into two subtypes by predicate `p`, take all elements\nof the first subtype to be less than all the elements of the\nsecond subtype, compare elements of a single subtype with `yes`\nand `no` respectively.\n\n# Example\n\n```nix\nlet cmp = splitByAndCompare (hasPrefix \"foo\") compare compare; in\n\ncmp \"a\" \"z\" => -1\ncmp \"fooa\" \"fooz\" => -1\n\ncmp \"f\" \"a\" => 1\ncmp \"fooa\" \"a\" => -1\n# while\ncompare \"fooa\" \"a\" => 1\n```\n\n# Type\n\n```haskell\n(a -> bool) -> (a -> a -> int) -> (a -> a -> int) -> (a -> a -> int)\n```",
    "isPrimop": false,
    "name": "splitByAndCompare",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/trivial.nix",
      "line": 402
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "splitString",
    "position": {
      "column": 17,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 872
    }
  },
  {
    "content": "Split a string representing a version into its components, by the\nsame version splitting logic underlying the version comparison in\n[`nix-env -u`](../command-ref/nix-env.md#operation---upgrade).",
    "isPrimop": true,
    "name": "splitVersion",
    "position": null
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "stringAfter",
    "position": {
      "column": 17,
      "file": "/home/johannes/git/nixpkgs/lib/strings-with-deps.nix",
      "line": 84
    }
  },
  {
    "content": "Manipulate a string character by character and replace them by\nstrings before concatenating the results.\n\n# Example\n\n```nix\nstringAsChars (x: if x == \"a\" then \"i\" else x) \"nax\"\n=> \"nix\"\n```\n\n# Type\n\n```haskell\nstringAsChars :: (string -> string) -> string -> string\n```",
    "isPrimop": false,
    "name": "stringAsChars",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 509
    }
  },
  {
    "content": "Return the length of the string *e*. If *e* is not a string,\nevaluation is aborted.",
    "isPrimop": true,
    "name": "stringLength",
    "position": null
  },
  {
    "content": "Convert a string to a list of characters (i.e. singleton strings).\nThis allows you to, e.g., map a function over each character.  However,\nnote that this will likely be horribly inefficient; Nix is not a\ngeneral purpose programming language. Complex string manipulations\nshould, if appropriate, be done in a derivation.\nAlso note that Nix treats strings as a list of bytes and thus doesn't\nhandle unicode.\n\n# Example\n\n```nix\nstringToCharacters \"\"\n=> [ ]\nstringToCharacters \"abc\"\n=> [ \"a\" \"b\" \"c\" ]\nstringToCharacters \"🦄\"\n=> [ \"�\" \"�\" \"�\" \"�\" ]\n```\n\n# Type\n\n```haskell\nstringToCharacters :: string -> [string]\n```",
    "isPrimop": false,
    "name": "stringToCharacters",
    "position": {
      "column": 24,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 487
    }
  },
  {
    "content": "Return the difference between the numbers *e1* and *e2*.",
    "isPrimop": true,
    "name": "sub",
    "position": null
  },
  {
    "content": "Return a list consisting of at most `count` elements of `list`,\nstarting at index `start`.\n\n# Example\n\n```nix\nsublist 1 3 [ \"a\" \"b\" \"c\" \"d\" \"e\" ]\n=> [ \"b\" \"c\" \"d\" ]\nsublist 1 3 [ ]\n=> [ ]\n```\n\n# Type\n\n```haskell\nsublist :: int -> int -> [a] -> [a]\n```",
    "isPrimop": false,
    "name": "sublist",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/lists.nix",
      "line": 939
    }
  },
  {
    "content": "Return the substring of *s* from character position *start*\n(zero-based) up to but not including *start + len*. If *start* is\ngreater than the length of the string, an empty string is returned,\nand if *start + len* lies beyond the end of the string, only the\nsubstring up to the end of the string is returned. *start* must be\nnon-negative. For example,\n\n```nix\nbuiltins.substring 0 3 \"nixos\"\n```\n\nevaluates to `\"nix\"`.",
    "isPrimop": true,
    "name": "substring",
    "position": null
  },
  {
    "content": "Subtracts list 'e' from another list. O(nm) complexity.\n\n# Example\n\n```nix\nsubtractLists [ 3 2 ] [ 1 2 3 4 5 3 ]\n=> [ 1 4 5 ]\n```",
    "isPrimop": false,
    "name": "subtractLists",
    "position": {
      "column": 19,
      "file": "/home/johannes/git/nixpkgs/lib/lists.nix",
      "line": 1085
    }
  },
  {
    "content": "Return the second to last elements of a list; abort evaluation if\nthe argument isn’t a list or is an empty list.\n\n> **Warning**\n>\n> This function should generally be avoided since it's inefficient:\n> unlike Haskell's `tail`, it takes O(n) time, so recursing over a\n> list by repeatedly calling `tail` takes O(n^2) time.",
    "isPrimop": true,
    "name": "tail",
    "position": null
  },
  {
    "content": "Return the first (at most) N elements of a list.\n\n# Example\n\n```nix\ntake 2 [ \"a\" \"b\" \"c\" \"d\" ]\n=> [ \"a\" \"b\" ]\ntake 2 [ ]\n=> [ ]\n```\n\n# Type\n\n```haskell\ntake :: int -> [a] -> [a]\n```",
    "isPrimop": false,
    "name": "take",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/lists.nix",
      "line": 842
    }
  },
  {
    "content": "Create a test assuming that list elements are `true`.\n\n# Example\n\n```nix\n{ testX = allTrue [ true ]; }\n```",
    "isPrimop": false,
    "name": "testAllTrue",
    "position": {
      "column": 17,
      "file": "/home/johannes/git/nixpkgs/lib/debug.nix",
      "line": 307
    }
  },
  {
    "content": "!!! The interface of this function is kind of messed up, since\nit's way too overloaded and almost but not quite computes a\ntopological sort of the depstrings.",
    "isPrimop": false,
    "name": "textClosureList",
    "position": {
      "column": 21,
      "file": "/home/johannes/git/nixpkgs/lib/strings-with-deps.nix",
      "line": 61
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "textClosureMap",
    "position": {
      "column": 20,
      "file": "/home/johannes/git/nixpkgs/lib/strings-with-deps.nix",
      "line": 77
    }
  },
  {
    "content": "Like throwIfNot, but negated (throw if the first argument is `true`).\n\n# Type\n\n```haskell\nbool -> string -> a -> a\n```",
    "isPrimop": false,
    "name": "throwIf",
    "position": {
      "column": 13,
      "file": "/home/johannes/git/nixpkgs/lib/trivial.nix",
      "line": 532
    }
  },
  {
    "content": "Like the `assert b; e` expression, but with a custom error message and\nwithout the semicolon.\n\nIf true, return the identity function, `r: r`.\n\nIf false, throw the error message.\n\nCalls can be juxtaposed using function application, as `(r: r) a = a`, so\n`(r: r) (r: r) a = a`, and so forth.\n\n# Example\n\n```nix\nthrowIfNot (lib.isList overlays) \"The overlays argument to nixpkgs must be a list.\"\nlib.foldr (x: throwIfNot (lib.isFunction x) \"All overlays passed to nixpkgs must be functions.\") (r: r) overlays\npkgs\n```\n\n# Type\n\n```haskell\nbool -> string -> a -> a\n```",
    "isPrimop": false,
    "name": "throwIfNot",
    "position": {
      "column": 16,
      "file": "/home/johannes/git/nixpkgs/lib/trivial.nix",
      "line": 521
    }
  },
  {
    "content": "`toBaseDigits base i` converts the positive integer i to a list of its\ndigits in the given base. For example:\n\ntoBaseDigits 10 123 => [ 1 2 3 ]\n\ntoBaseDigits 2 6 => [ 1 1 0 ]\n\ntoBaseDigits 16 250 => [ 15 10 ]",
    "isPrimop": false,
    "name": "toBaseDigits",
    "position": {
      "column": 18,
      "file": "/home/johannes/git/nixpkgs/lib/trivial.nix",
      "line": 659
    }
  },
  {
    "content": "Converts a store path to a fake derivation.\n\n# Type\n\n```haskell\ntoDerivation :: Path -> Derivation\n```",
    "isPrimop": false,
    "name": "toDerivation",
    "position": {
      "column": 6,
      "file": "/home/johannes/git/nixpkgs/lib/attrsets.nix",
      "line": 819
    }
  },
  {
    "content": "Turns any non-callable values into constant functions.\nReturns callable values as is.\n\n# Example\n\n```nix\nnix-repl> lib.toFunction 1 2\n1\n\nnix-repl> lib.toFunction (x: x + 1) 2\n3\n```",
    "isPrimop": false,
    "name": "toFunction",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/trivial.nix",
      "line": 617
    }
  },
  {
    "content": "Convert the given positive integer to a string of its hexadecimal\nrepresentation. For example:\n\ntoHexString 0 => \"0\"\n\ntoHexString 16 => \"10\"\n\ntoHexString 250 => \"FA\"",
    "isPrimop": false,
    "name": "toHexString",
    "position": {
      "column": 17,
      "file": "/home/johannes/git/nixpkgs/lib/trivial.nix",
      "line": 632
    }
  },
  {
    "content": "Parse a string as an int. Does not support parsing of integers with preceding zero due to\nambiguity between zero-padded and octal numbers. See toIntBase10.\n\n# Example\n\n```nix\ntoInt \"1337\"\n=> 1337\n\ntoInt \"-4\"\n=> -4\n\ntoInt \" 123 \"\n=> 123\n\ntoInt \"00024\"\n=> error: Ambiguity in interpretation of 00024 between octal and zero padded integer.\n\ntoInt \"3.14\"\n=> error: floating point JSON numbers are not supported\n```\n\n# Type\n\n```haskell\nstring -> int\n```",
    "isPrimop": false,
    "name": "toInt",
    "position": {
      "column": 11,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 1343
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "toIntBase10",
    "position": {
      "column": 17,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 1402
    }
  },
  {
    "content": "If argument is a list, return it; else, wrap it in a singleton\nlist.  If you're using this, you should almost certainly\nreconsider if there isn't a more \"well-typed\" approach.\n\n# Example\n\n```nix\ntoList [ 1 2 ]\n=> [ 1 2 ]\ntoList \"hi\"\n=> [ \"hi \"]\n```",
    "isPrimop": false,
    "name": "toList",
    "position": {
      "column": 12,
      "file": "/home/johannes/git/nixpkgs/lib/lists.nix",
      "line": 483
    }
  },
  {
    "content": "Given string *s*, replace every occurrence of the strings in *from*\nwith the corresponding string in *to*.\n\nThe argument *to* is lazy, that is, it is only evaluated when its corresponding pattern in *from* is matched in the string *s*\n\nExample:\n\n```nix\nbuiltins.replaceStrings [\"oo\" \"a\"] [\"a\" \"i\"] \"foobar\"\n```\n\nevaluates to `\"fabir\"`.",
    "isPrimop": true,
    "name": "toLower",
    "position": null
  },
  {
    "content": "Translate a Nix value into a shell variable declaration, with proper escaping.\n\nThe value can be a string (mapped to a regular variable), a list of strings\n(mapped to a Bash-style array) or an attribute set of strings (mapped to a\nBash-style associative array). Note that \"string\" includes string-coercible\nvalues like paths or derivations.\n\nStrings are translated into POSIX sh-compatible code; lists and attribute sets\nassume a shell that understands Bash syntax (e.g. Bash or ZSH).\n\n# Example\n\n```nix\n''\n${toShellVar \"foo\" \"some string\"}\n[[ \"$foo\" == \"some string\" ]]\n''\n```\n\n# Type\n\n```haskell\nstring -> (string | listOf string | attrsOf string) -> string\n```",
    "isPrimop": false,
    "name": "toShellVar",
    "position": {
      "column": 16,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 679
    }
  },
  {
    "content": "Translate an attribute set into corresponding shell variable declarations\nusing `toShellVar`.\n\n# Example\n\n```nix\nlet\nfoo = \"value\";\nbar = foo;\nin ''\n${toShellVars { inherit foo bar; }}\n[[ \"$foo\" == \"$bar\" ]]\n''\n```\n\n# Type\n\n```haskell\nattrsOf (string | listOf string | attrsOf string) -> string\n```",
    "isPrimop": false,
    "name": "toShellVars",
    "position": {
      "column": 17,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 715
    }
  },
  {
    "content": "Given string *s*, replace every occurrence of the strings in *from*\nwith the corresponding string in *to*.\n\nThe argument *to* is lazy, that is, it is only evaluated when its corresponding pattern in *from* is matched in the string *s*\n\nExample:\n\n```nix\nbuiltins.replaceStrings [\"oo\" \"a\"] [\"a\" \"i\"] \"foobar\"\n```\n\nevaluates to `\"fabir\"`.",
    "isPrimop": true,
    "name": "toUpper",
    "position": null
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "toposort",
    "position": {
      "column": 14,
      "file": "/home/johannes/git/nixpkgs/lib/lists.nix",
      "line": 722
    }
  },
  {
    "content": "Evaluate *e1* and print its abstract syntax representation on\nstandard error. Then return *e2*. This function is useful for\ndebugging.",
    "isPrimop": true,
    "name": "trace",
    "position": null
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "traceFnSeqN",
    "position": {
      "column": 17,
      "file": "/home/johannes/git/nixpkgs/lib/debug.nix",
      "line": 209
    }
  },
  {
    "content": "Conditionally trace the supplied message, based on a predicate.\n\n# Example\n\n```nix\ntraceIf true \"hello\" 3\ntrace: hello\n=> 3\n```\n\n# Type\n\n```haskell\ntraceIf :: bool -> string -> a -> a\n```",
    "isPrimop": false,
    "name": "traceIf",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/debug.nix",
      "line": 55
    }
  },
  {
    "content": "`builtins.trace`, but the value is `builtins.deepSeq`ed first.\n\n# Example\n\n```nix\ntrace { a.b.c = 3; } null\ntrace: { a = <CODE>; }\n=> null\ntraceSeq { a.b.c = 3; } null\ntrace: { a = { b = { c = 3; }; }; }\n=> null\n```\n\n# Type\n\n```haskell\ntraceSeq :: a -> b -> b\n```",
    "isPrimop": false,
    "name": "traceSeq",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/debug.nix",
      "line": 126
    }
  },
  {
    "content": "Like `traceSeq`, but only evaluate down to depth n.\nThis is very useful because lots of `traceSeq` usages\nlead to an infinite recursion.\n\n# Example\n\n```nix\ntraceSeqN 2 { a.b.c = 3; } null\ntrace: { a = { b = {…}; }; }\n=> null\n```\n\n# Type\n\n```haskell\ntraceSeqN :: Int -> a -> b -> b\n```",
    "isPrimop": false,
    "name": "traceSeqN",
    "position": {
      "column": 15,
      "file": "/home/johannes/git/nixpkgs/lib/debug.nix",
      "line": 149
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "traceVal",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/debug.nix",
      "line": 83
    }
  },
  {
    "content": "Trace the supplied value after applying a function to it, and\nreturn the original value.\n\n# Example\n\n```nix\ntraceValFn (v: \"mystring ${v}\") \"foo\"\ntrace: mystring foo\n=> \"foo\"\n```\n\n# Type\n\n```haskell\ntraceValFn :: (a -> b) -> a -> a\n```",
    "isPrimop": false,
    "name": "traceValFn",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/debug.nix",
      "line": 81
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "traceValSeq",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/debug.nix",
      "line": 171
    }
  },
  {
    "content": "A combination of `traceVal` and `traceSeq` that applies a\nprovided function to the value to be traced after `deepSeq`ing\nit.",
    "isPrimop": false,
    "name": "traceValSeqFn",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/debug.nix",
      "line": 169
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "traceValSeqN",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/debug.nix",
      "line": 185
    }
  },
  {
    "content": "A combination of `traceVal` and `traceSeqN` that applies a\nprovided function to the value to be traced.",
    "isPrimop": false,
    "name": "traceValSeqNFn",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/debug.nix",
      "line": 184
    }
  },
  {
    "content": "Massage a module into canonical form, that is, a set consisting\nof ‘options’, ‘config’ and ‘imports’ attributes.",
    "isPrimop": false,
    "name": "unifyModuleSyntax",
    "position": {
      "column": 23,
      "file": "/home/johannes/git/nixpkgs/lib/modules.nix",
      "line": 458
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "uniqList",
    "position": {
      "column": 14,
      "file": "/home/johannes/git/nixpkgs/lib/deprecated.nix",
      "line": 91
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "uniqListExt",
    "position": {
      "column": 17,
      "file": "/home/johannes/git/nixpkgs/lib/deprecated.nix",
      "line": 100
    }
  },
  {
    "content": "Reduce a list by applying a binary operator, from left to right,\ne.g. `foldl' op nul [x0 x1 x2 ...] = op (op (op nul x0) x1) x2)\n...`. For example, `foldl' (x: y: x + y) 0 [1 2 3]` evaluates to 6.\nThe return value of each application of `op` is evaluated immediately,\neven for intermediate values.",
    "isPrimop": true,
    "name": "unique",
    "position": null
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "updateManyAttrsByPath",
    "position": {
      "column": 6,
      "file": "/home/johannes/git/nixpkgs/lib/attrsets.nix",
      "line": 276
    }
  },
  {
    "content": "Like `setName`, but takes the previous name as an argument.\n\n# Example\n\n```nix\nupdateName (oldName: oldName + \"-experimental\") somePkg\n```",
    "isPrimop": false,
    "name": "updateName",
    "position": {
      "column": 16,
      "file": "/home/johannes/git/nixpkgs/lib/meta.nix",
      "line": 47
    }
  },
  {
    "content": "Return true if string v1 denotes a version equal to or newer than v2.\n\n# Example\n\n```nix\nversionAtLeast \"1.1\" \"1.0\"\n=> true\nversionAtLeast \"1.1\" \"1.1\"\n=> true\nversionAtLeast \"1.1\" \"1.2\"\n=> false\n```",
    "isPrimop": false,
    "name": "versionAtLeast",
    "position": {
      "column": 20,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 988
    }
  },
  {
    "content": "Return true if string v1 denotes a version older than v2.\n\n# Example\n\n```nix\nversionOlder \"1.1\" \"1.2\"\n=> true\nversionOlder \"1.1\" \"1.1\"\n=> false\n```",
    "isPrimop": false,
    "name": "versionOlder",
    "position": {
      "column": 18,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 972
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "warn",
    "position": {
      "column": 10,
      "file": "/home/johannes/git/nixpkgs/lib/trivial.nix",
      "line": 472
    }
  },
  {
    "content": "Like warn, but only warn when the first argument is `true`.\n\n# Type\n\n```haskell\nbool -> string -> a -> a\n```",
    "isPrimop": false,
    "name": "warnIf",
    "position": {
      "column": 12,
      "file": "/home/johannes/git/nixpkgs/lib/trivial.nix",
      "line": 483
    }
  },
  {
    "content": "Like warnIf, but negated (warn if the first argument is `false`).\n\n# Type\n\n```haskell\nbool -> string -> a -> a\n```",
    "isPrimop": false,
    "name": "warnIfNot",
    "position": {
      "column": 15,
      "file": "/home/johannes/git/nixpkgs/lib/trivial.nix",
      "line": 494
    }
  },
  {
    "content": "Create an --{with,without}-<feat> string that can be passed to\nstandard GNU Autoconf scripts.\n\n# Example\n\n```nix\nwithFeature true \"shared\"\n=> \"--with-shared\"\nwithFeature false \"shared\"\n=> \"--without-shared\"\n```",
    "isPrimop": false,
    "name": "withFeature",
    "position": {
      "column": 17,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 1176
    }
  },
  {
    "content": "Create an --{with-<feat>=<value>,without-<feat>} string that can be passed to\nstandard GNU Autoconf scripts.\n\n# Example\n\n```nix\nwithFeatureAs true \"shared\" \"foo\"\n=> \"--with-shared=foo\"\nwithFeatureAs false \"shared\" (throw \"ignored\")\n=> \"--without-shared\"\n```",
    "isPrimop": false,
    "name": "withFeatureAs",
    "position": {
      "column": 19,
      "file": "/home/johannes/git/nixpkgs/lib/strings.nix",
      "line": 1193
    }
  },
  {
    "content": "Transpose a list of attribute sets into an attribute set of lists,\nthen apply `mapAttrs`.\n\n`f` receives two arguments: the attribute name and a non-empty\nlist of all values encountered for that attribute name.\n\nThe result is an attribute set where the attribute names are the\nunion of the attribute names in each element of `list`. The attribute\nvalues are the return values of `f`.\n\n```nix\nbuiltins.zipAttrsWith\n  (name: values: { inherit name values; })\n  [ { a = \"x\"; } { a = \"y\"; b = \"z\"; } ]\n```\n\nevaluates to\n\n```\n{\n  a = { name = \"a\"; values = [ \"x\" \"y\" ]; };\n  b = { name = \"b\"; values = [ \"z\" ]; };\n}\n```",
    "isPrimop": true,
    "name": "zip",
    "position": null
  },
  {
    "content": "Merge sets of attributes and combine each attribute value in to a list.\n\nLike `lib.attrsets.zipAttrsWith` with `(name: values: values)` as the function.\n\n# Example\n\n```nix\nzipAttrs [{a = \"x\";} {a = \"y\"; b = \"z\";}]\n=> { a = [\"x\" \"y\"]; b = [\"z\"]; }\n```\n\n# Type\n\n```haskell\nzipAttrs :: [ AttrSet ] -> AttrSet\n```",
    "isPrimop": false,
    "name": "zipAttrs",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/attrsets.nix",
      "line": 936
    }
  },
  {
    "content": "Transpose a list of attribute sets into an attribute set of lists,\nthen apply `mapAttrs`.\n\n`f` receives two arguments: the attribute name and a non-empty\nlist of all values encountered for that attribute name.\n\nThe result is an attribute set where the attribute names are the\nunion of the attribute names in each element of `list`. The attribute\nvalues are the return values of `f`.\n\n```nix\nbuiltins.zipAttrsWith\n  (name: values: { inherit name values; })\n  [ { a = \"x\"; } { a = \"y\"; b = \"z\"; } ]\n```\n\nevaluates to\n\n```\n{\n  a = { name = \"a\"; values = [ \"x\" \"y\" ]; };\n  b = { name = \"b\"; values = [ \"z\" ]; };\n}\n```",
    "isPrimop": true,
    "name": "zipAttrsWith",
    "position": null
  },
  {
    "content": "Merge sets of attributes and use the function `f` to merge attributes\nvalues.\n\n# Example\n\n```nix\nzipAttrsWithNames [\"a\"] (name: vs: vs) [{a = \"x\";} {a = \"y\"; b = \"z\";}]\n=> { a = [\"x\" \"y\"]; }\n```\n\n# Type\n\n```haskell\nzipAttrsWithNames :: [ String ] -> (String -> [ Any ] -> Any) -> [ AttrSet ] -> AttrSet\n```",
    "isPrimop": false,
    "name": "zipAttrsWithNames",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/attrsets.nix",
      "line": 879
    }
  },
  {
    "content": "",
    "isPrimop": false,
    "name": "zipLists",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/lists.nix",
      "line": 615
    }
  },
  {
    "content": "Merges two lists of the same size together. If the sizes aren't the same\nthe merging stops at the shortest. How both lists are merged is defined\nby the first argument.\n\n# Example\n\n```nix\nzipListsWith (a: b: a + b) [\"h\" \"l\"] [\"e\" \"o\"]\n=> [\"he\" \"lo\"]\n```\n\n# Type\n\n```haskell\nzipListsWith :: (a -> b -> c) -> [a] -> [b] -> [c]\n```",
    "isPrimop": false,
    "name": "zipListsWith",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/lists.nix",
      "line": 613
    }
  },
  {
    "content": "Merge sets of attributes and use the function `f` to merge attributes\nvalues.\n\n# Example\n\n```nix\nzipAttrsWithNames [\"a\"] (name: vs: vs) [{a = \"x\";} {a = \"y\"; b = \"z\";}]\n=> { a = [\"x\" \"y\"]; }\n```\n\n# Type\n\n```haskell\nzipAttrsWithNames :: [ String ] -> (String -> [ Any ] -> Any) -> [ AttrSet ] -> AttrSet\n```",
    "isPrimop": false,
    "name": "zipWithNames",
    "position": {
      "column": 5,
      "file": "/home/johannes/git/nixpkgs/lib/attrsets.nix",
      "line": 879
    }
  }
]
